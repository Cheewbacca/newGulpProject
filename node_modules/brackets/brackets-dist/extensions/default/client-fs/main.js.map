{"version":3,"file":"main.js","sources":["../../brackets-src/src/thirdparty/i18n/i18n.js","nls/strings.js","nls/root/strings.js","strings.js","../../brackets-src/src/thirdparty/text/text.js","templates/contents.html!text","text!templates/open-dialog.html","lib/open-dialog.js","text!templates/create-folder.html","text!templates/confirm-replace.html","lib/confirm-replace.js","text!templates/save-dialog.html","lib/save-dialog.js","thirdparty/socket.io.js","lib/file-system.js","lib/fs-wrapper.js","main.js"],"names":["eval"],"mappings":"AAAAA,KAAA,49PCAAA,KAAA,6wBCAAA,KDEA,u7BEFAA,KAAA,qlBCAAA,KDEA,yqfEDAA,KAAA,+zBAEAA,KAAA,muQCFAA,KAAA,ypBCDAA,KDGA,m5CEFAA,KAAA,yrBAEAA,KAAA,8tDCFAA,KAAA,gnBCDAA,KDGA,igCEFAA,KAAA,k4BAEAA,KAAA,8vICDAA,KCFA,84hKAEAA,KAAA,64jBCAAA,KCFA,0tGCAAA,KAAA","sourcesContent":["eval(\"/**\\n * @license RequireJS i18n 2.0.2 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.\\n * Available via the MIT or new BSD license.\\n * see: http://github.com/requirejs/i18n for details\\n */\\n/*jslint regexp: true */\\n/*global require: false, navigator: false, define: false */\\n\\n/**\\n * This plugin handles i18n! prefixed modules. It does the following:\\n *\\n * 1) A regular module can have a dependency on an i18n bundle, but the regular\\n * module does not want to specify what locale to load. So it just specifies\\n * the top-level bundle, like \\\"i18n!nls/colors\\\".\\n *\\n * This plugin will load the i18n bundle at nls/colors, see that it is a root/master\\n * bundle since it does not have a locale in its name. It will then try to find\\n * the best match locale available in that master bundle, then request all the\\n * locale pieces for that best match locale. For instance, if the locale is \\\"en-us\\\",\\n * then the plugin will ask for the \\\"en-us\\\", \\\"en\\\" and \\\"root\\\" bundles to be loaded\\n * (but only if they are specified on the master bundle).\\n *\\n * Once all the bundles for the locale pieces load, then it mixes in all those\\n * locale pieces into each other, then finally sets the context.defined value\\n * for the nls/colors bundle to be that mixed in locale.\\n *\\n * 2) A regular module specifies a specific locale to load. For instance,\\n * i18n!nls/fr-fr/colors. In this case, the plugin needs to load the master bundle\\n * first, at nls/colors, then figure out what the best match locale is for fr-fr,\\n * since maybe only fr or just root is defined for that locale. Once that best\\n * fit is found, all of its locale pieces need to have their bundles loaded.\\n *\\n * Once all the bundles for the locale pieces load, then it mixes in all those\\n * locale pieces into each other, then finally sets the context.defined value\\n * for the nls/fr-fr/colors bundle to be that mixed in locale.\\n */\\n(function () {\\n    \\'use strict\\';\\n\\n    //regexp for reconstructing the master bundle name from parts of the regexp match\\n    //nlsRegExp.exec(\\\"foo/bar/baz/nls/en-ca/foo\\\") gives:\\n    //[\\\"foo/bar/baz/nls/en-ca/foo\\\", \\\"foo/bar/baz/nls/\\\", \\\"/\\\", \\\"/\\\", \\\"en-ca\\\", \\\"foo\\\"]\\n    //nlsRegExp.exec(\\\"foo/bar/baz/nls/foo\\\") gives:\\n    //[\\\"foo/bar/baz/nls/foo\\\", \\\"foo/bar/baz/nls/\\\", \\\"/\\\", \\\"/\\\", \\\"foo\\\", \\\"\\\"]\\n    //so, if match[5] is blank, it means this is the top bundle definition.\\n    var nlsRegExp = /(^.*(^|\\\\/)nls(\\\\/|$))([^\\\\/]*)\\\\/?([^\\\\/]*)/;\\n\\n    //Helper function to avoid repeating code. Lots of arguments in the\\n    //desire to stay functional and support RequireJS contexts without having\\n    //to know about the RequireJS contexts.\\n    function addPart(locale, master, needed, toLoad, prefix, suffix) {\\n        if (master[locale]) {\\n            needed.push(locale);\\n            if (master[locale] === true || master[locale] === 1) {\\n                toLoad.push(prefix + locale + \\'/\\' + suffix);\\n            }\\n        }\\n    }\\n\\n    function addIfExists(req, locale, toLoad, prefix, suffix) {\\n        var fullName = prefix + locale + \\'/\\' + suffix;\\n        if (require._fileExists(req.toUrl(fullName + \\'.js\\'))) {\\n            toLoad.push(fullName);\\n        }\\n    }\\n\\n    /**\\n     * Simple function to mix in properties from source into target,\\n     * but only if target does not already have a property of the same name.\\n     * This is not robust in IE for transferring methods that match\\n     * Object.prototype names, but the uses of mixin here seem unlikely to\\n     * trigger a problem related to that.\\n     */\\n    function mixin(target, source, force) {\\n        var prop;\\n        for (prop in source) {\\n            if (source.hasOwnProperty(prop) && (!target.hasOwnProperty(prop) || force)) {\\n                target[prop] = source[prop];\\n            } else if (typeof source[prop] === \\'object\\') {\\n                mixin(target[prop], source[prop], force);\\n            }\\n        }\\n    }\\n\\n    define(\\'i18n\\',[\\'module\\'], function (module) {\\n        var masterConfig = module.config ? module.config() : {};\\n\\n        return {\\n            version: \\'2.0.1+\\',\\n            /**\\n             * Called when a dependency needs to be loaded.\\n             */\\n            load: function (name, req, onLoad, config) {\\n                config = config || {};\\n\\n                if (config.locale) {\\n                    masterConfig.locale = config.locale;\\n                }\\n\\n                var masterName,\\n                    match = nlsRegExp.exec(name),\\n                    prefix = match[1],\\n                    locale = match[4],\\n                    suffix = match[5],\\n                    parts = locale.split(\\\"-\\\"),\\n                    toLoad = [],\\n                    value = {},\\n                    i, part, current = \\\"\\\";\\n\\n                //If match[5] is blank, it means this is the top bundle definition,\\n                //so it does not have to be handled. Locale-specific requests\\n                //will have a match[4] value but no match[5]\\n                if (match[5]) {\\n                    //locale-specific bundle\\n                    prefix = match[1];\\n                    masterName = prefix + suffix;\\n                } else {\\n                    //Top-level bundle.\\n                    masterName = name;\\n                    suffix = match[4];\\n                    locale = masterConfig.locale;\\n                    if (!locale) {\\n                        locale = masterConfig.locale =\\n                            typeof navigator === \\\"undefined\\\" ? \\\"root\\\" :\\n                            (navigator.language ||\\n                             navigator.userLanguage || \\\"root\\\").toLowerCase();\\n                    }\\n                    parts = locale.split(\\\"-\\\");\\n                }\\n\\n                if (config.isBuild) {\\n                    //Check for existence of all locale possible files and\\n                    //require them if exist.\\n                    toLoad.push(masterName);\\n                    addIfExists(req, \\\"root\\\", toLoad, prefix, suffix);\\n                    for (i = 0; i < parts.length; i++) {\\n                        part = parts[i];\\n                        current += (current ? \\\"-\\\" : \\\"\\\") + part;\\n                        addIfExists(req, current, toLoad, prefix, suffix);\\n                    }\\n\\n                    req(toLoad, function () {\\n                        onLoad();\\n                    });\\n                } else {\\n                    //First, fetch the master bundle, it knows what locales are available.\\n                    req([masterName], function (master) {\\n                        //Figure out the best fit\\n                        var needed = [],\\n                            part;\\n\\n                        //Always allow for root, then do the rest of the locale parts.\\n                        addPart(\\\"root\\\", master, needed, toLoad, prefix, suffix);\\n                        for (i = 0; i < parts.length; i++) {\\n                            part = parts[i];\\n                            current += (current ? \\\"-\\\" : \\\"\\\") + part;\\n                            addPart(current, master, needed, toLoad, prefix, suffix);\\n                        }\\n\\n                        //Load all the parts missing.\\n                        req(toLoad, function () {\\n                            var i, partBundle, part;\\n                            for (i = needed.length - 1; i > -1 && needed[i]; i--) {\\n                                part = needed[i];\\n                                partBundle = master[part];\\n                                if (partBundle === true || partBundle === 1) {\\n                                    partBundle = req(prefix + part + \\'/\\' + suffix);\\n                                }\\n                                mixin(value, partBundle);\\n                            }\\n\\n                            //All done, notify the loader.\\n                            onLoad(value);\\n                        });\\n                    });\\n                }\\n            }\\n        };\\n    });\\n}());\\n\\n//# sourceURL=/var/src/brackets/brackets-src/src/thirdparty/i18n/i18n.js\");\n\n","eval(\"/*\\n *  @see: https://github.com/adobe/brackets/tree/master/src/extensions/samples/LocalizationExample\\n */\\ndefine(\\'nls/strings\\',[\\'require\\',\\'exports\\',\\'module\\'],function (require, exports, module) {\\n    \\\"use strict\\\";\\n\\n    // Code that needs to display user strings should call require(\\\"strings\\\") to load\\n    // strings.js. This file will dynamically load strings.js for the specified by bracketes.locale.\\n    //\\n    // Translations for other locales should be placed in nls/<locale<optional country code>>/strings.js\\n    // Localization is provided via the i18n plugin.\\n    // All other bundles for languages need to add a prefix to the exports below so i18n can find them.\\n    module.exports = {\\n        root: true\\n    };\\n\\n});\\n\\n//# sourceURL=/nls/strings.js\");\n\n","eval(\"define(\\'nls/root/strings\\',{\\n    BUTTON_OPEN             : \\\"Open\\\",\\n    BUTTON_SAVE             : \\\"Save\\\",\\n    BUTTON_CANCEL           : \\\"Cancel\\\",\\n    BUTTON_OPEN_FOLDER      : \\\"List contents\\\",\\n    BUTTON_CREATE_FOLDER    : \\\"Create Folder ...\\\",\\n    BUTTON_OK               : \\\"OK\\\",\\n    BUTTON_REPLACE          : \\\"Replace\\\",\\n    LABEL_FILE_NAME         : \\\"Name:\\\",\\n    LABEL_FOLDER_NAME       : \\\"Folder Name\\\",\\n    MSG_FILE_EXISTS         : \\\"There is already a file with the same name!\\\",\\n    MSG_CONFIRM_REPLACE     : \\\"<p>The file <strong>\\\\\\\"{0}\\\\\\\"</strong> already exists in \\\\\\\"{1}\\\\\\\".  Replacing it will overwrite its contents.</p> Do you want to replace it?\\\",\\n    TITLE_CONFIRM_REPLACE   : \\\"A file with the same name already exists.\\\",\\n    MENU_OPEN               : \\\"Open Remote File...\\\",\\n    MENU_OPEN_FOLDER        : \\\"Open Remote Folder...\\\",\\n    MENU_SAVE_AS            : \\\"Save As Remote...\\\"\\n});\\n\\n//# sourceURL=/nls/root/strings.js\");\n\n","eval(\"/**\\n * This file provides the interface to user visible strings in Brackets. Code that needs\\n * to display strings should should load this module by calling var Strings = require(\\\"strings\\\").\\n * The i18n plugin will dynamically load the strings for the right locale and populate\\n * the exports variable. See nls/root/strings.js for the master file of English strings.\\n */\\ndefine(\\'strings\\',[\\'require\\',\\'exports\\',\\'module\\',\\'i18n!nls/strings\\'],function (require, exports, module) {\\n    \\\"use strict\\\";\\n\\n    module.exports = require(\\\"i18n!nls/strings\\\");\\n});\\n\\n//# sourceURL=/strings.js\");\n\n","eval(\"/**\\n * @license RequireJS text 2.0.10 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.\\n * Available via the MIT or new BSD license.\\n * see: http://github.com/requirejs/text for details\\n */\\n/*jslint regexp: true */\\n/*global require, XMLHttpRequest, ActiveXObject,\\n  define, window, process, Packages,\\n  java, location, Components, FileUtils */\\n\\ndefine(\\'text\\',[\\'module\\'], function (module) {\\n    \\'use strict\\';\\n\\n    var text, fs, Cc, Ci, xpcIsWindows,\\n        progIds = [\\'Msxml2.XMLHTTP\\', \\'Microsoft.XMLHTTP\\', \\'Msxml2.XMLHTTP.4.0\\'],\\n        xmlRegExp = /^\\\\s*<\\\\?xml(\\\\s)+version=[\\\\\\'\\\\\\\"](\\\\d)*.(\\\\d)*[\\\\\\'\\\\\\\"](\\\\s)*\\\\?>/im,\\n        bodyRegExp = /<body[^>]*>\\\\s*([\\\\s\\\\S]+)\\\\s*<\\\\/body>/im,\\n        hasLocation = typeof location !== \\'undefined\\' && location.href,\\n        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\\\\:/, \\'\\'),\\n        defaultHostName = hasLocation && location.hostname,\\n        defaultPort = hasLocation && (location.port || undefined),\\n        buildMap = {},\\n        masterConfig = (module.config && module.config()) || {};\\n\\n    text = {\\n        version: \\'2.0.10\\',\\n\\n        strip: function (content) {\\n            //Strips <?xml ...?> declarations so that external SVG and XML\\n            //documents can be added to a document without worry. Also, if the string\\n            //is an HTML document, only the part inside the body tag is returned.\\n            if (content) {\\n                content = content.replace(xmlRegExp, \\\"\\\");\\n                var matches = content.match(bodyRegExp);\\n                if (matches) {\\n                    content = matches[1];\\n                }\\n            } else {\\n                content = \\\"\\\";\\n            }\\n            return content;\\n        },\\n\\n        jsEscape: function (content) {\\n            return content.replace(/([\\'\\\\\\\\])/g, \\'\\\\\\\\$1\\')\\n                .replace(/[\\\\f]/g, \\\"\\\\\\\\f\\\")\\n                .replace(/[\\\\b]/g, \\\"\\\\\\\\b\\\")\\n                .replace(/[\\\\n]/g, \\\"\\\\\\\\n\\\")\\n                .replace(/[\\\\t]/g, \\\"\\\\\\\\t\\\")\\n                .replace(/[\\\\r]/g, \\\"\\\\\\\\r\\\")\\n                .replace(/[\\\\u2028]/g, \\\"\\\\\\\\u2028\\\")\\n                .replace(/[\\\\u2029]/g, \\\"\\\\\\\\u2029\\\");\\n        },\\n\\n        createXhr: masterConfig.createXhr || function () {\\n            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.\\n            var xhr, i, progId;\\n            if (typeof XMLHttpRequest !== \\\"undefined\\\") {\\n                return new XMLHttpRequest();\\n            } else if (typeof ActiveXObject !== \\\"undefined\\\") {\\n                for (i = 0; i < 3; i += 1) {\\n                    progId = progIds[i];\\n                    try {\\n                        xhr = new ActiveXObject(progId);\\n                    } catch (e) {}\\n\\n                    if (xhr) {\\n                        progIds = [progId];  // so faster next time\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return xhr;\\n        },\\n\\n        /**\\n         * Parses a resource name into its component parts. Resource names\\n         * look like: module/name.ext!strip, where the !strip part is\\n         * optional.\\n         * @param {String} name the resource name\\n         * @returns {Object} with properties \\\"moduleName\\\", \\\"ext\\\" and \\\"strip\\\"\\n         * where strip is a boolean.\\n         */\\n        parseName: function (name) {\\n            var modName, ext, temp,\\n                strip = false,\\n                index = name.indexOf(\\\".\\\"),\\n                isRelative = name.indexOf(\\'./\\') === 0 ||\\n                             name.indexOf(\\'../\\') === 0;\\n\\n            if (index !== -1 && (!isRelative || index > 1)) {\\n                modName = name.substring(0, index);\\n                ext = name.substring(index + 1, name.length);\\n            } else {\\n                modName = name;\\n            }\\n\\n            temp = ext || modName;\\n            index = temp.indexOf(\\\"!\\\");\\n            if (index !== -1) {\\n                //Pull off the strip arg.\\n                strip = temp.substring(index + 1) === \\\"strip\\\";\\n                temp = temp.substring(0, index);\\n                if (ext) {\\n                    ext = temp;\\n                } else {\\n                    modName = temp;\\n                }\\n            }\\n\\n            return {\\n                moduleName: modName,\\n                ext: ext,\\n                strip: strip\\n            };\\n        },\\n\\n        xdRegExp: /^((\\\\w+)\\\\:)?\\\\/\\\\/([^\\\\/\\\\\\\\]+)/,\\n\\n        /**\\n         * Is an URL on another domain. Only works for browser use, returns\\n         * false in non-browser environments. Only used to know if an\\n         * optimized .js version of a text resource should be loaded\\n         * instead.\\n         * @param {String} url\\n         * @returns Boolean\\n         */\\n        useXhr: function (url, protocol, hostname, port) {\\n            var uProtocol, uHostName, uPort,\\n                match = text.xdRegExp.exec(url);\\n            if (!match) {\\n                return true;\\n            }\\n            uProtocol = match[2];\\n            uHostName = match[3];\\n\\n            uHostName = uHostName.split(\\':\\');\\n            uPort = uHostName[1];\\n            uHostName = uHostName[0];\\n\\n            return (!uProtocol || uProtocol === protocol) &&\\n                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&\\n                   ((!uPort && !uHostName) || uPort === port);\\n        },\\n\\n        finishLoad: function (name, strip, content, onLoad) {\\n            content = strip ? text.strip(content) : content;\\n            if (masterConfig.isBuild) {\\n                buildMap[name] = content;\\n            }\\n            onLoad(content);\\n        },\\n\\n        load: function (name, req, onLoad, config) {\\n            //Name has format: some.module.filext!strip\\n            //The strip part is optional.\\n            //if strip is present, then that means only get the string contents\\n            //inside a body tag in an HTML string. For XML/SVG content it means\\n            //removing the <?xml ...?> declarations so the content can be inserted\\n            //into the current doc without problems.\\n\\n            // Do not bother with the work if a build and text will\\n            // not be inlined.\\n            if (config.isBuild && !config.inlineText) {\\n                onLoad();\\n                return;\\n            }\\n\\n            masterConfig.isBuild = config.isBuild;\\n\\n            var parsed = text.parseName(name),\\n                nonStripName = parsed.moduleName +\\n                    (parsed.ext ? \\'.\\' + parsed.ext : \\'\\'),\\n                url = req.toUrl(nonStripName),\\n                useXhr = (masterConfig.useXhr) ||\\n                         text.useXhr;\\n\\n            // Do not load if it is an empty: url\\n            if (url.indexOf(\\'empty:\\') === 0) {\\n                onLoad();\\n                return;\\n            }\\n\\n            //Load the text. Use XHR if possible and in a browser.\\n            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {\\n                text.get(url, function (content) {\\n                    text.finishLoad(name, parsed.strip, content, onLoad);\\n                }, function (err) {\\n                    if (onLoad.error) {\\n                        onLoad.error(err);\\n                    }\\n                });\\n            } else {\\n                //Need to fetch the resource across domains. Assume\\n                //the resource has been optimized into a JS module. Fetch\\n                //by the module name + extension, but do not include the\\n                //!strip part to avoid file system issues.\\n                req([nonStripName], function (content) {\\n                    text.finishLoad(parsed.moduleName + \\'.\\' + parsed.ext,\\n                                    parsed.strip, content, onLoad);\\n                });\\n            }\\n        },\\n\\n        write: function (pluginName, moduleName, write, config) {\\n            if (buildMap.hasOwnProperty(moduleName)) {\\n                var content = text.jsEscape(buildMap[moduleName]);\\n                write.asModule(pluginName + \\\"!\\\" + moduleName,\\n                               \\\"define(function () { return \\'\\\" +\\n                                   content +\\n                               \\\"\\';});\\\\n\\\");\\n            }\\n        },\\n\\n        writeFile: function (pluginName, moduleName, req, write, config) {\\n            var parsed = text.parseName(moduleName),\\n                extPart = parsed.ext ? \\'.\\' + parsed.ext : \\'\\',\\n                nonStripName = parsed.moduleName + extPart,\\n                //Use a \\'.js\\' file name so that it indicates it is a\\n                //script that can be loaded across domains.\\n                fileName = req.toUrl(parsed.moduleName + extPart) + \\'.js\\';\\n\\n            //Leverage own load() method to load plugin value, but only\\n            //write out values that do not have the strip argument,\\n            //to avoid any potential issues with ! in file names.\\n            text.load(nonStripName, req, function (value) {\\n                //Use own write() method to construct full module value.\\n                //But need to create shell that translates writeFile\\'s\\n                //write() to the right interface.\\n                var textWrite = function (contents) {\\n                    return write(fileName, contents);\\n                };\\n                textWrite.asModule = function (moduleName, contents) {\\n                    return write.asModule(moduleName, fileName, contents);\\n                };\\n\\n                text.write(pluginName, nonStripName, textWrite, config);\\n            }, config);\\n        }\\n    };\\n\\n    if (masterConfig.env === \\'node\\' || (!masterConfig.env &&\\n            typeof process !== \\\"undefined\\\" &&\\n            process.versions &&\\n            !!process.versions.node &&\\n            !process.versions[\\'node-webkit\\'])) {\\n        //Using special require.nodeRequire, something added by r.js.\\n        fs = require.nodeRequire(\\'fs\\');\\n\\n        text.get = function (url, callback, errback) {\\n            try {\\n                var file = fs.readFileSync(url, \\'utf8\\');\\n                //Remove BOM (Byte Mark Order) from utf8 files if it is there.\\n                if (file.indexOf(\\'\\\\uFEFF\\') === 0) {\\n                    file = file.substring(1);\\n                }\\n                callback(file);\\n            } catch (e) {\\n                errback(e);\\n            }\\n        };\\n    } else if (masterConfig.env === \\'xhr\\' || (!masterConfig.env &&\\n            text.createXhr())) {\\n        text.get = function (url, callback, errback, headers) {\\n            var xhr = text.createXhr(), header;\\n            xhr.open(\\'GET\\', url, true);\\n\\n            //Allow plugins direct access to xhr headers\\n            if (headers) {\\n                for (header in headers) {\\n                    if (headers.hasOwnProperty(header)) {\\n                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);\\n                    }\\n                }\\n            }\\n\\n            //Allow overrides specified in config\\n            if (masterConfig.onXhr) {\\n                masterConfig.onXhr(xhr, url);\\n            }\\n\\n            xhr.onreadystatechange = function (evt) {\\n                var status, err;\\n                //Do not explicitly handle errors, those should be\\n                //visible via console output in the browser.\\n                if (xhr.readyState === 4) {\\n                    status = xhr.status;\\n                    if (status > 399 && status < 600) {\\n                        //An http 4xx or 5xx error. Signal an error.\\n                        err = new Error(url + \\' HTTP status: \\' + status);\\n                        err.xhr = xhr;\\n                        errback(err);\\n                    } else {\\n                        callback(xhr.responseText);\\n                    }\\n\\n                    if (masterConfig.onXhrComplete) {\\n                        masterConfig.onXhrComplete(xhr, url);\\n                    }\\n                }\\n            };\\n            xhr.send(null);\\n        };\\n    } else if (masterConfig.env === \\'rhino\\' || (!masterConfig.env &&\\n            typeof Packages !== \\'undefined\\' && typeof java !== \\'undefined\\')) {\\n        //Why Java, why is this so awkward?\\n        text.get = function (url, callback) {\\n            var stringBuffer, line,\\n                encoding = \\\"utf-8\\\",\\n                file = new java.io.File(url),\\n                lineSeparator = java.lang.System.getProperty(\\\"line.separator\\\"),\\n                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),\\n                content = \\'\\';\\n            try {\\n                stringBuffer = new java.lang.StringBuffer();\\n                line = input.readLine();\\n\\n                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324\\n                // http://www.unicode.org/faq/utf_bom.html\\n\\n                // Note that when we use utf-8, the BOM should appear as \\\"EF BB BF\\\", but it doesn\\'t due to this bug in the JDK:\\n                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058\\n                if (line && line.length() && line.charAt(0) === 0xfeff) {\\n                    // Eat the BOM, since we\\'ve already found the encoding on this file,\\n                    // and we plan to concatenating this buffer with others; the BOM should\\n                    // only appear at the top of a file.\\n                    line = line.substring(1);\\n                }\\n\\n                if (line !== null) {\\n                    stringBuffer.append(line);\\n                }\\n\\n                while ((line = input.readLine()) !== null) {\\n                    stringBuffer.append(lineSeparator);\\n                    stringBuffer.append(line);\\n                }\\n                //Make sure we return a JavaScript string and not a Java string.\\n                content = String(stringBuffer.toString()); //String\\n            } finally {\\n                input.close();\\n            }\\n            callback(content);\\n        };\\n    } else if (masterConfig.env === \\'xpconnect\\' || (!masterConfig.env &&\\n            typeof Components !== \\'undefined\\' && Components.classes &&\\n            Components.interfaces)) {\\n        //Avert your gaze!\\n        Cc = Components.classes,\\n        Ci = Components.interfaces;\\n        Components.utils[\\'import\\'](\\'resource://gre/modules/FileUtils.jsm\\');\\n        xpcIsWindows = (\\'@mozilla.org/windows-registry-key;1\\' in Cc);\\n\\n        text.get = function (url, callback) {\\n            var inStream, convertStream, fileObj,\\n                readData = {};\\n\\n            if (xpcIsWindows) {\\n                url = url.replace(/\\\\//g, \\'\\\\\\\\\\');\\n            }\\n\\n            fileObj = new FileUtils.File(url);\\n\\n            //XPCOM, you so crazy\\n            try {\\n                inStream = Cc[\\'@mozilla.org/network/file-input-stream;1\\']\\n                           .createInstance(Ci.nsIFileInputStream);\\n                inStream.init(fileObj, 1, 0, false);\\n\\n                convertStream = Cc[\\'@mozilla.org/intl/converter-input-stream;1\\']\\n                                .createInstance(Ci.nsIConverterInputStream);\\n                convertStream.init(inStream, \\\"utf-8\\\", inStream.available(),\\n                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);\\n\\n                convertStream.readString(inStream.available(), readData);\\n                convertStream.close();\\n                inStream.close();\\n                callback(readData.value);\\n            } catch (e) {\\n                throw new Error((fileObj && fileObj.path || \\'\\') + \\': \\' + e);\\n            }\\n        };\\n    }\\n    return text;\\n});\\n\\n//# sourceURL=/var/src/brackets/brackets-src/src/thirdparty/text/text.js\");\n\n","\neval(\"define(\\'text!templates/contents.html\\',[],function () { return \\'<div id=\\\"rfs-trail\\\">\\\\n    <ul>\\\\n        {{#trail}}<li {{#curr}}class=\\\"{{curr}}\\\"{{/curr}} data-path=\\\"{{path}}\\\">{{name}}</li>{{/trail}}\\\\n    </ul>\\\\n</div>\\\\n<div id=\\\"rfs-files-list\\\">\\\\n    <table class=\\\"bottom-panel-table table table-striped table-condensed\\\">\\\\n        <tbody>\\\\n            {{#files}}\\\\n            <tr class=\\\"rfs-file {{disabled}}\\\" data-path=\\\"{{fullPath}}\\\" title={{fullPath}}>\\\\n                <td class=\\\"icons-column\\\">\\\\n                    <div class=\\\"rfs-icon {{type}}\\\" {{#isDirectory}}title=\\\"{{OPEN_FOLDER}}\\\"{{/isDirectory}}></div>\\\\n                </td>\\\\n                <td>{{name}}</td>\\\\n            </tr>\\\\n            {{/files}}\\\\n        </tbody>\\\\n    </table>\\\\n</div>\\\\n\\';});\\n\\n//# sourceURL=/text!templates/contents.html\");\n\n","\neval(\"define(\\'text!templates/open-dialog.html\\',[],function () { return \\'<div id=\\\"rfs-files-dialog\\\" class=\\\"modal\\\">\\\\n    <div class=\\\"modal-header\\\">\\\\n        <h1 class=\\\"dialog-title\\\">{{TITLE}}</h1>\\\\n    </div>\\\\n    <div class=\\\"modal-body\\\">\\\\n        <div id=\\\"rfs-contents\\\"></div>\\\\n    </div>\\\\n    <div class=\\\"modal-footer\\\">\\\\n        <span id=\\\"rfs-save-name\\\"></span>\\\\n        <button data-button-id=\\\"cancel\\\" class=\\\"dialog-button btn cancel btn-80\\\" >{{BUTTON_CANCEL}}</button>\\\\n        <button data-button-id=\\\"ok\\\" class=\\\"dialog-button btn primary btn-80\\\">{{BUTTON_OPEN}}</button>\\\\n    </div>\\\\n</div>\\\\n\\';});\\n\\n//# sourceURL=/text!templates/open-dialog.html\");\n\n","eval(\"define(\\'lib/open-dialog\\',[\\'require\\',\\'exports\\',\\'module\\',\\'../strings\\',\\'./contents\\',\\'text!../templates/open-dialog.html\\'],function (require, exports) {\\n    \\\"use strict\\\";\\n\\n    var Dialogs             = brackets.getModule(\\\"widgets/Dialogs\\\"),\\n        Strings             = require(\\\"../strings\\\"),\\n        contents            = require(\\\"./contents\\\"),\\n        dialogTemplate      = require(\\\"text!../templates/open-dialog.html\\\");\\n\\n    exports.show = function (allowMultipleSelection, chooseDirectories, title, initialPath, fileTypes, callback) {\\n        if (initialPath.indexOf(\\\"/samples/\\\") === 0) {\\n            initialPath = null;\\n        }\\n\\n        var context = {\\n                TITLE: title,\\n                BUTTON_CANCEL: Strings.BUTTON_CANCEL,\\n                BUTTON_OPEN: Strings.BUTTON_OPEN\\n            },\\n            path        = initialPath || brackets.app.getUserDocumentsDirectory(),\\n            dialog      = Dialogs.showModalDialogUsingTemplate(Mustache.render(dialogTemplate, context)),\\n            $dialog     = dialog.getElement(),\\n            cnts        = contents($dialog, allowMultipleSelection, chooseDirectories, title, path, fileTypes, null, callback, null);\\n\\n        dialog.done(function (buttonId) {\\n            if (buttonId === \\\"ok\\\") {\\n                callback(null, cnts.getSelected());\\n            }\\n        });\\n    };\\n});\\n\\n//# sourceURL=/lib/open-dialog.js\");\n\n","\neval(\"define(\\'text!templates/create-folder.html\\',[],function () { return \\'<div id=\\\"rfs-create-folder-dialog\\\" class=\\\"modal\\\">\\\\n    <div class=\\\"modal-header\\\">\\\\n        <h1 class=\\\"dialog-title\\\">{{TITLE}}</h1>\\\\n    </div>\\\\n    <div class=\\\"modal-body rfs-body\\\">\\\\n        <input type=\\\"text\\\" id=\\\"rfs-folder-name\\\" />\\\\n        <span id=\\\"rfs-msg\\\">&nbsp;</span>\\\\n    </div>\\\\n    <div class=\\\"modal-footer\\\">\\\\n        <button data-button-id=\\\"cancel\\\" class=\\\"dialog-button btn cancel btn-80\\\" >{{BUTTON_CANCEL}}</button>\\\\n        <button data-button-id=\\\"ok\\\" class=\\\"dialog-button btn primary btn-80\\\">{{BUTTON_OK}}</button>\\\\n    </div>\\\\n</div>\\\\n\\';});\\n\\n//# sourceURL=/text!templates/create-folder.html\");\n\n","\neval(\"define(\\'text!templates/confirm-replace.html\\',[],function () { return \\'<div id=\\\"rfs-create-folder-dialog\\\" class=\\\"modal\\\">\\\\n    <div class=\\\"modal-header\\\">\\\\n        <h1 class=\\\"dialog-title\\\">{{TITLE}}</h1>\\\\n    </div>\\\\n    <div class=\\\"modal-body rfs-body\\\">{{{REPLACE_MESSAGE}}}</div>\\\\n    <div class=\\\"modal-footer\\\">\\\\n        <button data-button-id=\\\"cancel\\\" class=\\\"dialog-button btn cancel btn-80\\\" >{{BUTTON_CANCEL}}</button>\\\\n        <button data-button-id=\\\"ok\\\" class=\\\"dialog-button btn primary btn-80\\\">{{BUTTON_REPLACE}}</button>\\\\n    </div>\\\\n</div>\\\\n\\';});\\n\\n//# sourceURL=/text!templates/confirm-replace.html\");\n\n","eval(\"define(\\'lib/confirm-replace\\',[\\'require\\',\\'exports\\',\\'module\\',\\'../strings\\',\\'text!../templates/confirm-replace.html\\'],function (require, exports) {\\n    \\\"use strict\\\";\\n\\n    var Dialogs             = brackets.getModule(\\\"widgets/Dialogs\\\"),\\n        StringUtils         = brackets.getModule(\\\"utils/StringUtils\\\"),\\n        Strings             = require(\\\"../strings\\\"),\\n        dialogTemplate      = require(\\\"text!../templates/confirm-replace.html\\\");\\n\\n    exports.show = function (folderName, fileName, callback) {\\n        var context = {\\n                TITLE: Strings.TITLE_CONFIRM_REPLACE,\\n                REPLACE_MESSAGE: StringUtils.format(Strings.MSG_CONFIRM_REPLACE, fileName, folderName),\\n                BUTTON_CANCEL: Strings.BUTTON_CANCEL,\\n                BUTTON_REPLACE: Strings.BUTTON_REPLACE\\n            },\\n            dialog  = Dialogs.showModalDialogUsingTemplate(Mustache.render(dialogTemplate, context));\\n\\n        dialog.done(callback);\\n    };\\n});\\n\\n//# sourceURL=/lib/confirm-replace.js\");\n\n","\neval(\"define(\\'text!templates/save-dialog.html\\',[],function () { return \\'<div id=\\\"rfs-files-dialog\\\" class=\\\"modal\\\">\\\\n    <div class=\\\"modal-header\\\">\\\\n        <h1 class=\\\"dialog-title\\\">{{TITLE}}</h1>\\\\n    </div>\\\\n    <div class=\\\"modal-body\\\">\\\\n        <label for=\\\"rfs-file-name\\\">{{LABEL_FILE_NAME}}</label><input type=\\\"text\\\" id=\\\"rfs-file-name\\\" value=\\\"{{proposed}}\\\" />\\\\n        <button id=\\\"rfs-create-folder\\\" class=\\\"dialog-button btn right\\\">{{BUTTON_CREATE_FOLDER}}</button>\\\\n        <div id=\\\"rfs-contents\\\"></div>\\\\n    </div>\\\\n    <div class=\\\"modal-footer\\\">\\\\n        <span id=\\\"rfs-save-name\\\"></span>\\\\n        <button data-button-id=\\\"cancel\\\" class=\\\"dialog-button btn cancel btn-80\\\" >{{BUTTON_CANCEL}}</button>\\\\n        <button data-button-id=\\\"ok\\\" class=\\\"dialog-button btn primary btn-80\\\">{{BUTTON_SAVE}}</button>\\\\n    </div>\\\\n</div>\\\\n\\';});\\n\\n//# sourceURL=/text!templates/save-dialog.html\");\n\n","eval(\"define(\\'lib/save-dialog\\',[\\'require\\',\\'exports\\',\\'module\\',\\'../strings\\',\\'./create-folder\\',\\'./confirm-replace\\',\\'./contents\\',\\'text!../templates/save-dialog.html\\'],function (require, exports) {\\n    \\\"use strict\\\";\\n\\n    var Dialogs             = brackets.getModule(\\\"widgets/Dialogs\\\"),\\n        FileSystem          = brackets.getModule(\\\"filesystem/FileSystem\\\"),\\n        FileUtils           = brackets.getModule(\\\"file/FileUtils\\\"),\\n        Strings             = require(\\\"../strings\\\"),\\n        CreateFolder        = require(\\\"./create-folder\\\"),\\n        ConfirmReplace      = require(\\\"./confirm-replace\\\"),\\n        contents            = require(\\\"./contents\\\"),\\n        dialogTemplate      = require(\\\"text!../templates/save-dialog.html\\\");\\n\\n    exports.show = function (title, initialPath, proposedNewFilename, callback) {\\n        if (initialPath.indexOf(\\\"/samples/\\\") === 0) {\\n            initialPath = null;\\n        }\\n\\n        var context = {\\n                TITLE: title,\\n                BUTTON_CANCEL: Strings.BUTTON_CANCEL,\\n                BUTTON_SAVE: Strings.BUTTON_SAVE,\\n                LABEL_FILE_NAME: Strings.LABEL_FILE_NAME,\\n                OPEN_FOLDER: Strings.BUTTON_OPEN_FOLDER,\\n                BUTTON_CREATE_FOLDER: Strings.BUTTON_CREATE_FOLDER,\\n                proposed: proposedNewFilename\\n            },\\n            path        = initialPath || brackets.app.getUserDocumentsDirectory(),\\n            dialog      = Dialogs.showModalDialogUsingTemplate(Mustache.render(dialogTemplate, context)),\\n            $dialog     = dialog.getElement(),\\n            btnOk       = $dialog.find(\\\"button[data-button-id=\\'ok\\']\\\")[0],\\n            $input      = $dialog.find(\\\"#rfs-file-name\\\"),\\n            $saveName   = $dialog.find(\\\"#rfs-save-name\\\"),\\n            $newFolder  = $dialog.find(\\\"#rfs-create-folder\\\"),\\n            cnts;\\n\\n        function getFullName() {\\n            return FileUtils.stripTrailingSlash(path) + \\\"/\\\" + $input.val().trim();\\n        }\\n\\n        function handleButton() {\\n            if (!$input.val().trim()) {\\n                btnOk.disabled = true;\\n            } else if (btnOk.disabled) {\\n                btnOk.disabled = false;\\n            }\\n            $saveName.text(getFullName());\\n        }\\n\\n        function onSelected(val) {\\n            if (val.path) {\\n                path = val.path;\\n            }\\n\\n            if (val.fileName) {\\n                $input.val(val.fileName);\\n                handleButton();\\n            }\\n\\n            $saveName.text(getFullName());\\n        }\\n\\n        $input.keyup(handleButton);\\n        $newFolder.click(function (event) {\\n            event.stopImmediatePropagation();\\n            var names = [];\\n            cnts.files.forEach(function (el) {\\n                names.push(el.name);\\n            });\\n            CreateFolder.show(names, function (name) {\\n                var fullName    = FileUtils.stripTrailingSlash(path) + \\\"/\\\" + name,\\n                    dir         = FileSystem.getDirectoryForPath(fullName);\\n\\n                dir.create(function (err) {\\n                    if (err) {\\n                        return callback(err);\\n                    }\\n\\n                    path = fullName;\\n                    cnts = contents($dialog, false, false, title, path, null, null, callback, onSelected);\\n                });\\n            });\\n        });\\n\\n        cnts = contents($dialog, false, false, title, path, null, null, callback, onSelected);\\n\\n        dialog.done(function (buttonId) {\\n            if (buttonId === \\\"ok\\\") {\\n                var fullName = getFullName(),\\n                    file = FileSystem.getFileForPath(fullName);\\n\\n                file.exists(function (err, exists) {\\n                    if (err) {\\n                        return callback(err);\\n                    }\\n\\n                    if (exists) {\\n                        ConfirmReplace.show(path, $input.val().trim(), function (buttonId) {\\n                            if (buttonId === \\\"ok\\\") {\\n                                callback(null, fullName);\\n                            }\\n                        });\\n                    } else {\\n                        callback(null, fullName);\\n                    }\\n                });\\n            }\\n        });\\n    };\\n});\\n\\n//# sourceURL=/lib/save-dialog.js\");\n\n","eval(\"!function(e){if(\\\"object\\\"==typeof exports&&\\\"undefined\\\"!=typeof module)module.exports=e();else if(\\\"function\\\"==typeof define&&define.amd)define(\\'thirdparty/socket.io\\',[],e);else{var f;\\\"undefined\\\"!=typeof window?f=window:\\\"undefined\\\"!=typeof global?f=global:\\\"undefined\\\"!=typeof self&&(f=self),f.io=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\\\"function\\\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\\\"Cannot find module \\'\\\"+o+\\\"\\'\\\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\\\"function\\\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\\n\\nmodule.exports = _dereq_(\\'./lib/\\');\\n\\n},{\\\"./lib/\\\":2}],2:[function(_dereq_,module,exports){\\n\\n/**\\n * Module dependencies.\\n */\\n\\nvar url = _dereq_(\\'./url\\');\\nvar parser = _dereq_(\\'socket.io-parser\\');\\nvar Manager = _dereq_(\\'./manager\\');\\nvar debug = _dereq_(\\'debug\\')(\\'socket.io-client\\');\\n\\n/**\\n * Module exports.\\n */\\n\\nmodule.exports = exports = lookup;\\n\\n/**\\n * Managers cache.\\n */\\n\\nvar cache = exports.managers = {};\\n\\n/**\\n * Looks up an existing `Manager` for multiplexing.\\n * If the user summons:\\n *\\n *   `io(\\'http://localhost/a\\');`\\n *   `io(\\'http://localhost/b\\');`\\n *\\n * We reuse the existing instance based on same scheme/port/host,\\n * and we initialize sockets for each namespace.\\n *\\n * @api public\\n */\\n\\nfunction lookup(uri, opts) {\\n  if (typeof uri == \\'object\\') {\\n    opts = uri;\\n    uri = undefined;\\n  }\\n\\n  opts = opts || {};\\n\\n  var parsed = url(uri);\\n  var source = parsed.source;\\n  var id = parsed.id;\\n  var io;\\n\\n  if (opts.forceNew || opts[\\'force new connection\\'] || false === opts.multiplex) {\\n    debug(\\'ignoring socket cache for %s\\', source);\\n    io = Manager(source, opts);\\n  } else {\\n    if (!cache[id]) {\\n      debug(\\'new io instance for %s\\', source);\\n      cache[id] = Manager(source, opts);\\n    }\\n    io = cache[id];\\n  }\\n\\n  return io.socket(parsed.path);\\n}\\n\\n/**\\n * Protocol version.\\n *\\n * @api public\\n */\\n\\nexports.protocol = parser.protocol;\\n\\n/**\\n * `connect`.\\n *\\n * @param {String} uri\\n * @api public\\n */\\n\\nexports.connect = lookup;\\n\\n/**\\n * Expose constructors for standalone build.\\n *\\n * @api public\\n */\\n\\nexports.Manager = _dereq_(\\'./manager\\');\\nexports.Socket = _dereq_(\\'./socket\\');\\n\\n},{\\\"./manager\\\":3,\\\"./socket\\\":5,\\\"./url\\\":6,\\\"debug\\\":9,\\\"socket.io-parser\\\":40}],3:[function(_dereq_,module,exports){\\n\\n/**\\n * Module dependencies.\\n */\\n\\nvar url = _dereq_(\\'./url\\');\\nvar eio = _dereq_(\\'engine.io-client\\');\\nvar Socket = _dereq_(\\'./socket\\');\\nvar Emitter = _dereq_(\\'component-emitter\\');\\nvar parser = _dereq_(\\'socket.io-parser\\');\\nvar on = _dereq_(\\'./on\\');\\nvar bind = _dereq_(\\'component-bind\\');\\nvar object = _dereq_(\\'object-component\\');\\nvar debug = _dereq_(\\'debug\\')(\\'socket.io-client:manager\\');\\n\\n/**\\n * Module exports\\n */\\n\\nmodule.exports = Manager;\\n\\n/**\\n * `Manager` constructor.\\n *\\n * @param {String} engine instance or engine uri/opts\\n * @param {Object} options\\n * @api public\\n */\\n\\nfunction Manager(uri, opts){\\n  if (!(this instanceof Manager)) return new Manager(uri, opts);\\n  if (uri && (\\'object\\' == typeof uri)) {\\n    opts = uri;\\n    uri = undefined;\\n  }\\n  opts = opts || {};\\n\\n  opts.path = opts.path || \\'/socket.io\\';\\n  this.nsps = {};\\n  this.subs = [];\\n  this.opts = opts;\\n  this.reconnection(opts.reconnection !== false);\\n  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\\n  this.reconnectionDelay(opts.reconnectionDelay || 1000);\\n  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\\n  this.timeout(null == opts.timeout ? 20000 : opts.timeout);\\n  this.readyState = \\'closed\\';\\n  this.uri = uri;\\n  this.connected = 0;\\n  this.attempts = 0;\\n  this.encoding = false;\\n  this.packetBuffer = [];\\n  this.encoder = new parser.Encoder();\\n  this.decoder = new parser.Decoder();\\n  this.autoConnect = opts.autoConnect !== false;\\n  if (this.autoConnect) this.open();\\n}\\n\\n/**\\n * Propagate given event to sockets and emit on `this`\\n *\\n * @api private\\n */\\n\\nManager.prototype.emitAll = function() {\\n  this.emit.apply(this, arguments);\\n  for (var nsp in this.nsps) {\\n    this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);\\n  }\\n};\\n\\n/**\\n * Mix in `Emitter`.\\n */\\n\\nEmitter(Manager.prototype);\\n\\n/**\\n * Sets the `reconnection` config.\\n *\\n * @param {Boolean} true/false if it should automatically reconnect\\n * @return {Manager} self or value\\n * @api public\\n */\\n\\nManager.prototype.reconnection = function(v){\\n  if (!arguments.length) return this._reconnection;\\n  this._reconnection = !!v;\\n  return this;\\n};\\n\\n/**\\n * Sets the reconnection attempts config.\\n *\\n * @param {Number} max reconnection attempts before giving up\\n * @return {Manager} self or value\\n * @api public\\n */\\n\\nManager.prototype.reconnectionAttempts = function(v){\\n  if (!arguments.length) return this._reconnectionAttempts;\\n  this._reconnectionAttempts = v;\\n  return this;\\n};\\n\\n/**\\n * Sets the delay between reconnections.\\n *\\n * @param {Number} delay\\n * @return {Manager} self or value\\n * @api public\\n */\\n\\nManager.prototype.reconnectionDelay = function(v){\\n  if (!arguments.length) return this._reconnectionDelay;\\n  this._reconnectionDelay = v;\\n  return this;\\n};\\n\\n/**\\n * Sets the maximum delay between reconnections.\\n *\\n * @param {Number} delay\\n * @return {Manager} self or value\\n * @api public\\n */\\n\\nManager.prototype.reconnectionDelayMax = function(v){\\n  if (!arguments.length) return this._reconnectionDelayMax;\\n  this._reconnectionDelayMax = v;\\n  return this;\\n};\\n\\n/**\\n * Sets the connection timeout. `false` to disable\\n *\\n * @return {Manager} self or value\\n * @api public\\n */\\n\\nManager.prototype.timeout = function(v){\\n  if (!arguments.length) return this._timeout;\\n  this._timeout = v;\\n  return this;\\n};\\n\\n/**\\n * Starts trying to reconnect if reconnection is enabled and we have not\\n * started reconnecting yet\\n *\\n * @api private\\n */\\n\\nManager.prototype.maybeReconnectOnOpen = function() {\\n  // Only try to reconnect if it\\'s the first time we\\'re connecting\\n  if (!this.openReconnect && !this.reconnecting && this._reconnection && this.attempts === 0) {\\n    // keeps reconnection from firing twice for the same reconnection loop\\n    this.openReconnect = true;\\n    this.reconnect();\\n  }\\n};\\n\\n\\n/**\\n * Sets the current transport `socket`.\\n *\\n * @param {Function} optional, callback\\n * @return {Manager} self\\n * @api public\\n */\\n\\nManager.prototype.open =\\nManager.prototype.connect = function(fn){\\n  debug(\\'readyState %s\\', this.readyState);\\n  if (~this.readyState.indexOf(\\'open\\')) return this;\\n\\n  debug(\\'opening %s\\', this.uri);\\n  this.engine = eio(this.uri, this.opts);\\n  var socket = this.engine;\\n  var self = this;\\n  this.readyState = \\'opening\\';\\n\\n  // emit `open`\\n  var openSub = on(socket, \\'open\\', function() {\\n    self.onopen();\\n    fn && fn();\\n  });\\n\\n  // emit `connect_error`\\n  var errorSub = on(socket, \\'error\\', function(data){\\n    debug(\\'connect_error\\');\\n    self.cleanup();\\n    self.readyState = \\'closed\\';\\n    self.emitAll(\\'connect_error\\', data);\\n    if (fn) {\\n      var err = new Error(\\'Connection error\\');\\n      err.data = data;\\n      fn(err);\\n    }\\n\\n    self.maybeReconnectOnOpen();\\n  });\\n\\n  // emit `connect_timeout`\\n  if (false !== this._timeout) {\\n    var timeout = this._timeout;\\n    debug(\\'connect attempt will timeout after %d\\', timeout);\\n\\n    // set timer\\n    var timer = setTimeout(function(){\\n      debug(\\'connect attempt timed out after %d\\', timeout);\\n      openSub.destroy();\\n      socket.close();\\n      socket.emit(\\'error\\', \\'timeout\\');\\n      self.emitAll(\\'connect_timeout\\', timeout);\\n    }, timeout);\\n\\n    this.subs.push({\\n      destroy: function(){\\n        clearTimeout(timer);\\n      }\\n    });\\n  }\\n\\n  this.subs.push(openSub);\\n  this.subs.push(errorSub);\\n\\n  return this;\\n};\\n\\n/**\\n * Called upon transport open.\\n *\\n * @api private\\n */\\n\\nManager.prototype.onopen = function(){\\n  debug(\\'open\\');\\n\\n  // clear old subs\\n  this.cleanup();\\n\\n  // mark as open\\n  this.readyState = \\'open\\';\\n  this.emit(\\'open\\');\\n\\n  // add new subs\\n  var socket = this.engine;\\n  this.subs.push(on(socket, \\'data\\', bind(this, \\'ondata\\')));\\n  this.subs.push(on(this.decoder, \\'decoded\\', bind(this, \\'ondecoded\\')));\\n  this.subs.push(on(socket, \\'error\\', bind(this, \\'onerror\\')));\\n  this.subs.push(on(socket, \\'close\\', bind(this, \\'onclose\\')));\\n};\\n\\n/**\\n * Called with data.\\n *\\n * @api private\\n */\\n\\nManager.prototype.ondata = function(data){\\n  this.decoder.add(data);\\n};\\n\\n/**\\n * Called when parser fully decodes a packet.\\n *\\n * @api private\\n */\\n\\nManager.prototype.ondecoded = function(packet) {\\n  this.emit(\\'packet\\', packet);\\n};\\n\\n/**\\n * Called upon socket error.\\n *\\n * @api private\\n */\\n\\nManager.prototype.onerror = function(err){\\n  debug(\\'error\\', err);\\n  this.emitAll(\\'error\\', err);\\n};\\n\\n/**\\n * Creates a new socket for the given `nsp`.\\n *\\n * @return {Socket}\\n * @api public\\n */\\n\\nManager.prototype.socket = function(nsp){\\n  var socket = this.nsps[nsp];\\n  if (!socket) {\\n    socket = new Socket(this, nsp);\\n    this.nsps[nsp] = socket;\\n    var self = this;\\n    socket.on(\\'connect\\', function(){\\n      self.connected++;\\n    });\\n  }\\n  return socket;\\n};\\n\\n/**\\n * Called upon a socket close.\\n *\\n * @param {Socket} socket\\n */\\n\\nManager.prototype.destroy = function(socket){\\n  --this.connected || this.close();\\n};\\n\\n/**\\n * Writes a packet.\\n *\\n * @param {Object} packet\\n * @api private\\n */\\n\\nManager.prototype.packet = function(packet){\\n  debug(\\'writing packet %j\\', packet);\\n  var self = this;\\n\\n  if (!self.encoding) {\\n    // encode, then write to engine with result\\n    self.encoding = true;\\n    this.encoder.encode(packet, function(encodedPackets) {\\n      for (var i = 0; i < encodedPackets.length; i++) {\\n        self.engine.write(encodedPackets[i]);\\n      }\\n      self.encoding = false;\\n      self.processPacketQueue();\\n    });\\n  } else { // add packet to the queue\\n    self.packetBuffer.push(packet);\\n  }\\n};\\n\\n/**\\n * If packet buffer is non-empty, begins encoding the\\n * next packet in line.\\n *\\n * @api private\\n */\\n\\nManager.prototype.processPacketQueue = function() {\\n  if (this.packetBuffer.length > 0 && !this.encoding) {\\n    var pack = this.packetBuffer.shift();\\n    this.packet(pack);\\n  }\\n};\\n\\n/**\\n * Clean up transport subscriptions and packet buffer.\\n *\\n * @api private\\n */\\n\\nManager.prototype.cleanup = function(){\\n  var sub;\\n  while (sub = this.subs.shift()) sub.destroy();\\n\\n  this.packetBuffer = [];\\n  this.encoding = false;\\n\\n  this.decoder.destroy();\\n};\\n\\n/**\\n * Close the current socket.\\n *\\n * @api private\\n */\\n\\nManager.prototype.close =\\nManager.prototype.disconnect = function(){\\n  this.skipReconnect = true;\\n  this.engine.close();\\n};\\n\\n/**\\n * Called upon engine close.\\n *\\n * @api private\\n */\\n\\nManager.prototype.onclose = function(reason){\\n  debug(\\'close\\');\\n  this.cleanup();\\n  this.readyState = \\'closed\\';\\n  this.emit(\\'close\\', reason);\\n  if (this._reconnection && !this.skipReconnect) {\\n    this.reconnect();\\n  }\\n};\\n\\n/**\\n * Attempt a reconnection.\\n *\\n * @api private\\n */\\n\\nManager.prototype.reconnect = function(){\\n  if (this.reconnecting) return this;\\n\\n  var self = this;\\n  this.attempts++;\\n\\n  if (this.attempts > this._reconnectionAttempts) {\\n    debug(\\'reconnect failed\\');\\n    this.emitAll(\\'reconnect_failed\\');\\n    this.reconnecting = false;\\n  } else {\\n    var delay = this.attempts * this.reconnectionDelay();\\n    delay = Math.min(delay, this.reconnectionDelayMax());\\n    debug(\\'will wait %dms before reconnect attempt\\', delay);\\n\\n    this.reconnecting = true;\\n    var timer = setTimeout(function(){\\n      debug(\\'attempting reconnect\\');\\n      self.emitAll(\\'reconnect_attempt\\', self.attempts);\\n      self.emitAll(\\'reconnecting\\', self.attempts);\\n      self.open(function(err){\\n        if (err) {\\n          debug(\\'reconnect attempt error\\');\\n          self.reconnecting = false;\\n          self.reconnect();\\n          self.emitAll(\\'reconnect_error\\', err.data);\\n        } else {\\n          debug(\\'reconnect success\\');\\n          self.onreconnect();\\n        }\\n      });\\n    }, delay);\\n\\n    this.subs.push({\\n      destroy: function(){\\n        clearTimeout(timer);\\n      }\\n    });\\n  }\\n};\\n\\n/**\\n * Called upon successful reconnect.\\n *\\n * @api private\\n */\\n\\nManager.prototype.onreconnect = function(){\\n  var attempt = this.attempts;\\n  this.attempts = 0;\\n  this.reconnecting = false;\\n  this.emitAll(\\'reconnect\\', attempt);\\n};\\n\\n},{\\\"./on\\\":4,\\\"./socket\\\":5,\\\"./url\\\":6,\\\"component-bind\\\":7,\\\"component-emitter\\\":8,\\\"debug\\\":9,\\\"engine.io-client\\\":10,\\\"object-component\\\":37,\\\"socket.io-parser\\\":40}],4:[function(_dereq_,module,exports){\\n\\n/**\\n * Module exports.\\n */\\n\\nmodule.exports = on;\\n\\n/**\\n * Helper for subscriptions.\\n *\\n * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`\\n * @param {String} event name\\n * @param {Function} callback\\n * @api public\\n */\\n\\nfunction on(obj, ev, fn) {\\n  obj.on(ev, fn);\\n  return {\\n    destroy: function(){\\n      obj.removeListener(ev, fn);\\n    }\\n  };\\n}\\n\\n},{}],5:[function(_dereq_,module,exports){\\n\\n/**\\n * Module dependencies.\\n */\\n\\nvar parser = _dereq_(\\'socket.io-parser\\');\\nvar Emitter = _dereq_(\\'component-emitter\\');\\nvar toArray = _dereq_(\\'to-array\\');\\nvar on = _dereq_(\\'./on\\');\\nvar bind = _dereq_(\\'component-bind\\');\\nvar debug = _dereq_(\\'debug\\')(\\'socket.io-client:socket\\');\\nvar hasBin = _dereq_(\\'has-binary\\');\\nvar indexOf = _dereq_(\\'indexof\\');\\n\\n/**\\n * Module exports.\\n */\\n\\nmodule.exports = exports = Socket;\\n\\n/**\\n * Internal events (blacklisted).\\n * These events can\\'t be emitted by the user.\\n *\\n * @api private\\n */\\n\\nvar events = {\\n  connect: 1,\\n  connect_error: 1,\\n  connect_timeout: 1,\\n  disconnect: 1,\\n  error: 1,\\n  reconnect: 1,\\n  reconnect_attempt: 1,\\n  reconnect_failed: 1,\\n  reconnect_error: 1,\\n  reconnecting: 1\\n};\\n\\n/**\\n * Shortcut to `Emitter#emit`.\\n */\\n\\nvar emit = Emitter.prototype.emit;\\n\\n/**\\n * `Socket` constructor.\\n *\\n * @api public\\n */\\n\\nfunction Socket(io, nsp){\\n  this.io = io;\\n  this.nsp = nsp;\\n  this.json = this; // compat\\n  this.ids = 0;\\n  this.acks = {};\\n  if (this.io.autoConnect) this.open();\\n  this.receiveBuffer = [];\\n  this.sendBuffer = [];\\n  this.connected = false;\\n  this.disconnected = true;\\n  this.subEvents();\\n}\\n\\n/**\\n * Mix in `Emitter`.\\n */\\n\\nEmitter(Socket.prototype);\\n\\n/**\\n * Subscribe to open, close and packet events\\n *\\n * @api private\\n */\\n\\nSocket.prototype.subEvents = function() {\\n  var io = this.io;\\n  this.subs = [\\n    on(io, \\'open\\', bind(this, \\'onopen\\')),\\n    on(io, \\'packet\\', bind(this, \\'onpacket\\')),\\n    on(io, \\'close\\', bind(this, \\'onclose\\'))\\n  ];\\n};\\n\\n/**\\n * Called upon engine `open`.\\n *\\n * @api private\\n */\\n\\nSocket.prototype.open =\\nSocket.prototype.connect = function(){\\n  if (this.connected) return this;\\n\\n  this.io.open(); // ensure open\\n  if (\\'open\\' == this.io.readyState) this.onopen();\\n  return this;\\n};\\n\\n/**\\n * Sends a `message` event.\\n *\\n * @return {Socket} self\\n * @api public\\n */\\n\\nSocket.prototype.send = function(){\\n  var args = toArray(arguments);\\n  args.unshift(\\'message\\');\\n  this.emit.apply(this, args);\\n  return this;\\n};\\n\\n/**\\n * Override `emit`.\\n * If the event is in `events`, it\\'s emitted normally.\\n *\\n * @param {String} event name\\n * @return {Socket} self\\n * @api public\\n */\\n\\nSocket.prototype.emit = function(ev){\\n  if (events.hasOwnProperty(ev)) {\\n    emit.apply(this, arguments);\\n    return this;\\n  }\\n\\n  var args = toArray(arguments);\\n  var parserType = parser.EVENT; // default\\n  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary\\n  var packet = { type: parserType, data: args };\\n\\n  // event ack callback\\n  if (\\'function\\' == typeof args[args.length - 1]) {\\n    debug(\\'emitting packet with ack id %d\\', this.ids);\\n    this.acks[this.ids] = args.pop();\\n    packet.id = this.ids++;\\n  }\\n\\n  if (this.connected) {\\n    this.packet(packet);\\n  } else {\\n    this.sendBuffer.push(packet);\\n  }\\n\\n  return this;\\n};\\n\\n/**\\n * Sends a packet.\\n *\\n * @param {Object} packet\\n * @api private\\n */\\n\\nSocket.prototype.packet = function(packet){\\n  packet.nsp = this.nsp;\\n  this.io.packet(packet);\\n};\\n\\n/**\\n * \\\"Opens\\\" the socket.\\n *\\n * @api private\\n */\\n\\nSocket.prototype.onopen = function(){\\n  debug(\\'transport is open - connecting\\');\\n\\n  // write connect packet if necessary\\n  if (\\'/\\' != this.nsp) {\\n    this.packet({ type: parser.CONNECT });\\n  }\\n};\\n\\n/**\\n * Called upon engine `close`.\\n *\\n * @param {String} reason\\n * @api private\\n */\\n\\nSocket.prototype.onclose = function(reason){\\n  debug(\\'close (%s)\\', reason);\\n  this.connected = false;\\n  this.disconnected = true;\\n  this.emit(\\'disconnect\\', reason);\\n};\\n\\n/**\\n * Called with socket packet.\\n *\\n * @param {Object} packet\\n * @api private\\n */\\n\\nSocket.prototype.onpacket = function(packet){\\n  if (packet.nsp != this.nsp) return;\\n\\n  switch (packet.type) {\\n    case parser.CONNECT:\\n      this.onconnect();\\n      break;\\n\\n    case parser.EVENT:\\n      this.onevent(packet);\\n      break;\\n\\n    case parser.BINARY_EVENT:\\n      this.onevent(packet);\\n      break;\\n\\n    case parser.ACK:\\n      this.onack(packet);\\n      break;\\n\\n    case parser.BINARY_ACK:\\n      this.onack(packet);\\n      break;\\n\\n    case parser.DISCONNECT:\\n      this.ondisconnect();\\n      break;\\n\\n    case parser.ERROR:\\n      this.emit(\\'error\\', packet.data);\\n      break;\\n  }\\n};\\n\\n/**\\n * Called upon a server event.\\n *\\n * @param {Object} packet\\n * @api private\\n */\\n\\nSocket.prototype.onevent = function(packet){\\n  var args = packet.data || [];\\n  debug(\\'emitting event %j\\', args);\\n\\n  if (null != packet.id) {\\n    debug(\\'attaching ack callback to event\\');\\n    args.push(this.ack(packet.id));\\n  }\\n\\n  if (this.connected) {\\n    emit.apply(this, args);\\n  } else {\\n    this.receiveBuffer.push(args);\\n  }\\n};\\n\\n/**\\n * Produces an ack callback to emit with an event.\\n *\\n * @api private\\n */\\n\\nSocket.prototype.ack = function(id){\\n  var self = this;\\n  var sent = false;\\n  return function(){\\n    // prevent double callbacks\\n    if (sent) return;\\n    sent = true;\\n    var args = toArray(arguments);\\n    debug(\\'sending ack %j\\', args);\\n\\n    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;\\n    self.packet({\\n      type: type,\\n      id: id,\\n      data: args\\n    });\\n  };\\n};\\n\\n/**\\n * Called upon a server acknowlegement.\\n *\\n * @param {Object} packet\\n * @api private\\n */\\n\\nSocket.prototype.onack = function(packet){\\n  debug(\\'calling ack %s with %j\\', packet.id, packet.data);\\n  var fn = this.acks[packet.id];\\n  fn.apply(this, packet.data);\\n  delete this.acks[packet.id];\\n};\\n\\n/**\\n * Called upon server connect.\\n *\\n * @api private\\n */\\n\\nSocket.prototype.onconnect = function(){\\n  this.connected = true;\\n  this.disconnected = false;\\n  this.emit(\\'connect\\');\\n  this.emitBuffered();\\n};\\n\\n/**\\n * Emit buffered events (received and emitted).\\n *\\n * @api private\\n */\\n\\nSocket.prototype.emitBuffered = function(){\\n  var i;\\n  for (i = 0; i < this.receiveBuffer.length; i++) {\\n    emit.apply(this, this.receiveBuffer[i]);\\n  }\\n  this.receiveBuffer = [];\\n\\n  for (i = 0; i < this.sendBuffer.length; i++) {\\n    this.packet(this.sendBuffer[i]);\\n  }\\n  this.sendBuffer = [];\\n};\\n\\n/**\\n * Called upon server disconnect.\\n *\\n * @api private\\n */\\n\\nSocket.prototype.ondisconnect = function(){\\n  debug(\\'server disconnect (%s)\\', this.nsp);\\n  this.destroy();\\n  this.onclose(\\'io server disconnect\\');\\n};\\n\\n/**\\n * Called upon forced client/server side disconnections,\\n * this method ensures the manager stops tracking us and\\n * that reconnections don\\'t get triggered for this.\\n *\\n * @api private.\\n */\\n\\nSocket.prototype.destroy = function(){\\n  // clean subscriptions to avoid reconnections\\n  for (var i = 0; i < this.subs.length; i++) {\\n    this.subs[i].destroy();\\n  }\\n\\n  this.io.destroy(this);\\n};\\n\\n/**\\n * Disconnects the socket manually.\\n *\\n * @return {Socket} self\\n * @api public\\n */\\n\\nSocket.prototype.close =\\nSocket.prototype.disconnect = function(){\\n  if (!this.connected) return this;\\n\\n  debug(\\'performing disconnect (%s)\\', this.nsp);\\n  this.packet({ type: parser.DISCONNECT });\\n\\n  // remove socket from pool\\n  this.destroy();\\n\\n  // fire events\\n  this.onclose(\\'io client disconnect\\');\\n  return this;\\n};\\n\\n},{\\\"./on\\\":4,\\\"component-bind\\\":7,\\\"component-emitter\\\":8,\\\"debug\\\":9,\\\"has-binary\\\":32,\\\"indexof\\\":36,\\\"socket.io-parser\\\":40,\\\"to-array\\\":44}],6:[function(_dereq_,module,exports){\\n(function (global){\\n\\n/**\\n * Module dependencies.\\n */\\n\\nvar parseuri = _dereq_(\\'parseuri\\');\\nvar debug = _dereq_(\\'debug\\')(\\'socket.io-client:url\\');\\n\\n/**\\n * Module exports.\\n */\\n\\nmodule.exports = url;\\n\\n/**\\n * URL parser.\\n *\\n * @param {String} url\\n * @param {Object} An object meant to mimic window.location.\\n *                 Defaults to window.location.\\n * @api public\\n */\\n\\nfunction url(uri, loc){\\n  var obj = uri;\\n\\n  // default to window.location\\n  var loc = loc || global.location;\\n  if (null == uri) uri = loc.protocol + \\'//\\' + loc.hostname;\\n\\n  // relative path support\\n  if (\\'string\\' == typeof uri) {\\n    if (\\'/\\' == uri.charAt(0)) {\\n      if (\\'undefined\\' != typeof loc) {\\n        uri = loc.hostname + uri;\\n      }\\n    }\\n\\n    if (!/^(https?|wss?):\\\\/\\\\//.test(uri)) {\\n      debug(\\'protocol-less url %s\\', uri);\\n      if (\\'undefined\\' != typeof loc) {\\n        uri = loc.protocol + \\'//\\' + uri;\\n      } else {\\n        uri = \\'https://\\' + uri;\\n      }\\n    }\\n\\n    // parse\\n    debug(\\'parse %s\\', uri);\\n    obj = parseuri(uri);\\n  }\\n\\n  // make sure we treat `localhost:80` and `localhost` equally\\n  if (!obj.port) {\\n    if (/^(http|ws)$/.test(obj.protocol)) {\\n      obj.port = \\'80\\';\\n    }\\n    else if (/^(http|ws)s$/.test(obj.protocol)) {\\n      obj.port = \\'443\\';\\n    }\\n  }\\n\\n  obj.path = obj.path || \\'/\\';\\n\\n  // define unique id\\n  obj.id = obj.protocol + \\'://\\' + obj.host + \\':\\' + obj.port;\\n  // define href\\n  obj.href = obj.protocol + \\'://\\' + obj.host + (loc && loc.port == obj.port ? \\'\\' : (\\':\\' + obj.port));\\n\\n  return obj;\\n}\\n\\n}).call(this,typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"debug\\\":9,\\\"parseuri\\\":38}],7:[function(_dereq_,module,exports){\\n/**\\n * Slice reference.\\n */\\n\\nvar slice = [].slice;\\n\\n/**\\n * Bind `obj` to `fn`.\\n *\\n * @param {Object} obj\\n * @param {Function|String} fn or string\\n * @return {Function}\\n * @api public\\n */\\n\\nmodule.exports = function(obj, fn){\\n  if (\\'string\\' == typeof fn) fn = obj[fn];\\n  if (\\'function\\' != typeof fn) throw new Error(\\'bind() requires a function\\');\\n  var args = slice.call(arguments, 2);\\n  return function(){\\n    return fn.apply(obj, args.concat(slice.call(arguments)));\\n  }\\n};\\n\\n},{}],8:[function(_dereq_,module,exports){\\n\\n/**\\n * Expose `Emitter`.\\n */\\n\\nmodule.exports = Emitter;\\n\\n/**\\n * Initialize a new `Emitter`.\\n *\\n * @api public\\n */\\n\\nfunction Emitter(obj) {\\n  if (obj) return mixin(obj);\\n};\\n\\n/**\\n * Mixin the emitter properties.\\n *\\n * @param {Object} obj\\n * @return {Object}\\n * @api private\\n */\\n\\nfunction mixin(obj) {\\n  for (var key in Emitter.prototype) {\\n    obj[key] = Emitter.prototype[key];\\n  }\\n  return obj;\\n}\\n\\n/**\\n * Listen on the given `event` with `fn`.\\n *\\n * @param {String} event\\n * @param {Function} fn\\n * @return {Emitter}\\n * @api public\\n */\\n\\nEmitter.prototype.on =\\nEmitter.prototype.addEventListener = function(event, fn){\\n  this._callbacks = this._callbacks || {};\\n  (this._callbacks[event] = this._callbacks[event] || [])\\n    .push(fn);\\n  return this;\\n};\\n\\n/**\\n * Adds an `event` listener that will be invoked a single\\n * time then automatically removed.\\n *\\n * @param {String} event\\n * @param {Function} fn\\n * @return {Emitter}\\n * @api public\\n */\\n\\nEmitter.prototype.once = function(event, fn){\\n  var self = this;\\n  this._callbacks = this._callbacks || {};\\n\\n  function on() {\\n    self.off(event, on);\\n    fn.apply(this, arguments);\\n  }\\n\\n  on.fn = fn;\\n  this.on(event, on);\\n  return this;\\n};\\n\\n/**\\n * Remove the given callback for `event` or all\\n * registered callbacks.\\n *\\n * @param {String} event\\n * @param {Function} fn\\n * @return {Emitter}\\n * @api public\\n */\\n\\nEmitter.prototype.off =\\nEmitter.prototype.removeListener =\\nEmitter.prototype.removeAllListeners =\\nEmitter.prototype.removeEventListener = function(event, fn){\\n  this._callbacks = this._callbacks || {};\\n\\n  // all\\n  if (0 == arguments.length) {\\n    this._callbacks = {};\\n    return this;\\n  }\\n\\n  // specific event\\n  var callbacks = this._callbacks[event];\\n  if (!callbacks) return this;\\n\\n  // remove all handlers\\n  if (1 == arguments.length) {\\n    delete this._callbacks[event];\\n    return this;\\n  }\\n\\n  // remove specific handler\\n  var cb;\\n  for (var i = 0; i < callbacks.length; i++) {\\n    cb = callbacks[i];\\n    if (cb === fn || cb.fn === fn) {\\n      callbacks.splice(i, 1);\\n      break;\\n    }\\n  }\\n  return this;\\n};\\n\\n/**\\n * Emit `event` with the given args.\\n *\\n * @param {String} event\\n * @param {Mixed} ...\\n * @return {Emitter}\\n */\\n\\nEmitter.prototype.emit = function(event){\\n  this._callbacks = this._callbacks || {};\\n  var args = [].slice.call(arguments, 1)\\n    , callbacks = this._callbacks[event];\\n\\n  if (callbacks) {\\n    callbacks = callbacks.slice(0);\\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\\n      callbacks[i].apply(this, args);\\n    }\\n  }\\n\\n  return this;\\n};\\n\\n/**\\n * Return array of callbacks for `event`.\\n *\\n * @param {String} event\\n * @return {Array}\\n * @api public\\n */\\n\\nEmitter.prototype.listeners = function(event){\\n  this._callbacks = this._callbacks || {};\\n  return this._callbacks[event] || [];\\n};\\n\\n/**\\n * Check if this emitter has `event` handlers.\\n *\\n * @param {String} event\\n * @return {Boolean}\\n * @api public\\n */\\n\\nEmitter.prototype.hasListeners = function(event){\\n  return !! this.listeners(event).length;\\n};\\n\\n},{}],9:[function(_dereq_,module,exports){\\n\\n/**\\n * Expose `debug()` as the module.\\n */\\n\\nmodule.exports = debug;\\n\\n/**\\n * Create a debugger with the given `name`.\\n *\\n * @param {String} name\\n * @return {Type}\\n * @api public\\n */\\n\\nfunction debug(name) {\\n  if (!debug.enabled(name)) return function(){};\\n\\n  return function(fmt){\\n    fmt = coerce(fmt);\\n\\n    var curr = new Date;\\n    var ms = curr - (debug[name] || curr);\\n    debug[name] = curr;\\n\\n    fmt = name\\n      + \\' \\'\\n      + fmt\\n      + \\' +\\' + debug.humanize(ms);\\n\\n    // This hackery is required for IE8\\n    // where `console.log` doesn\\'t have \\'apply\\'\\n    window.console\\n      && console.log\\n      && Function.prototype.apply.call(console.log, console, arguments);\\n  }\\n}\\n\\n/**\\n * The currently active debug mode names.\\n */\\n\\ndebug.names = [];\\ndebug.skips = [];\\n\\n/**\\n * Enables a debug mode by name. This can include modes\\n * separated by a colon and wildcards.\\n *\\n * @param {String} name\\n * @api public\\n */\\n\\ndebug.enable = function(name) {\\n  try {\\n    localStorage.debug = name;\\n  } catch(e){}\\n\\n  var split = (name || \\'\\').split(/[\\\\s,]+/)\\n    , len = split.length;\\n\\n  for (var i = 0; i < len; i++) {\\n    name = split[i].replace(\\'*\\', \\'.*?\\');\\n    if (name[0] === \\'-\\') {\\n      debug.skips.push(new RegExp(\\'^\\' + name.substr(1) + \\'$\\'));\\n    }\\n    else {\\n      debug.names.push(new RegExp(\\'^\\' + name + \\'$\\'));\\n    }\\n  }\\n};\\n\\n/**\\n * Disable debug output.\\n *\\n * @api public\\n */\\n\\ndebug.disable = function(){\\n  debug.enable(\\'\\');\\n};\\n\\n/**\\n * Humanize the given `ms`.\\n *\\n * @param {Number} m\\n * @return {String}\\n * @api private\\n */\\n\\ndebug.humanize = function(ms) {\\n  var sec = 1000\\n    , min = 60 * 1000\\n    , hour = 60 * min;\\n\\n  if (ms >= hour) return (ms / hour).toFixed(1) + \\'h\\';\\n  if (ms >= min) return (ms / min).toFixed(1) + \\'m\\';\\n  if (ms >= sec) return (ms / sec | 0) + \\'s\\';\\n  return ms + \\'ms\\';\\n};\\n\\n/**\\n * Returns true if the given mode name is enabled, false otherwise.\\n *\\n * @param {String} name\\n * @return {Boolean}\\n * @api public\\n */\\n\\ndebug.enabled = function(name) {\\n  for (var i = 0, len = debug.skips.length; i < len; i++) {\\n    if (debug.skips[i].test(name)) {\\n      return false;\\n    }\\n  }\\n  for (var i = 0, len = debug.names.length; i < len; i++) {\\n    if (debug.names[i].test(name)) {\\n      return true;\\n    }\\n  }\\n  return false;\\n};\\n\\n/**\\n * Coerce `val`.\\n */\\n\\nfunction coerce(val) {\\n  if (val instanceof Error) return val.stack || val.message;\\n  return val;\\n}\\n\\n// persist\\n\\ntry {\\n  if (window.localStorage) debug.enable(localStorage.debug);\\n} catch(e){}\\n\\n},{}],10:[function(_dereq_,module,exports){\\n\\nmodule.exports =  _dereq_(\\'./lib/\\');\\n\\n},{\\\"./lib/\\\":11}],11:[function(_dereq_,module,exports){\\n\\nmodule.exports = _dereq_(\\'./socket\\');\\n\\n/**\\n * Exports parser\\n *\\n * @api public\\n *\\n */\\nmodule.exports.parser = _dereq_(\\'engine.io-parser\\');\\n\\n},{\\\"./socket\\\":12,\\\"engine.io-parser\\\":21}],12:[function(_dereq_,module,exports){\\n(function (global){\\n/**\\n * Module dependencies.\\n */\\n\\nvar transports = _dereq_(\\'./transports\\');\\nvar Emitter = _dereq_(\\'component-emitter\\');\\nvar debug = _dereq_(\\'debug\\')(\\'engine.io-client:socket\\');\\nvar index = _dereq_(\\'indexof\\');\\nvar parser = _dereq_(\\'engine.io-parser\\');\\nvar parseuri = _dereq_(\\'parseuri\\');\\nvar parsejson = _dereq_(\\'parsejson\\');\\nvar parseqs = _dereq_(\\'parseqs\\');\\n\\n/**\\n * Module exports.\\n */\\n\\nmodule.exports = Socket;\\n\\n/**\\n * Noop function.\\n *\\n * @api private\\n */\\n\\nfunction noop(){}\\n\\n/**\\n * Socket constructor.\\n *\\n * @param {String|Object} uri or options\\n * @param {Object} options\\n * @api public\\n */\\n\\nfunction Socket(uri, opts){\\n  if (!(this instanceof Socket)) return new Socket(uri, opts);\\n\\n  opts = opts || {};\\n\\n  if (uri && \\'object\\' == typeof uri) {\\n    opts = uri;\\n    uri = null;\\n  }\\n\\n  if (uri) {\\n    uri = parseuri(uri);\\n    opts.host = uri.host;\\n    opts.secure = uri.protocol == \\'https\\' || uri.protocol == \\'wss\\';\\n    opts.port = uri.port;\\n    if (uri.query) opts.query = uri.query;\\n  }\\n\\n  this.secure = null != opts.secure ? opts.secure :\\n    (global.location && \\'https:\\' == location.protocol);\\n\\n  if (opts.host) {\\n    var pieces = opts.host.split(\\':\\');\\n    opts.hostname = pieces.shift();\\n    if (pieces.length) opts.port = pieces.pop();\\n  }\\n\\n  this.agent = opts.agent || false;\\n  this.hostname = opts.hostname ||\\n    (global.location ? location.hostname : \\'localhost\\');\\n  this.port = opts.port || (global.location && location.port ?\\n       location.port :\\n       (this.secure ? 443 : 80));\\n  this.query = opts.query || {};\\n  if (\\'string\\' == typeof this.query) this.query = parseqs.decode(this.query);\\n  this.upgrade = false !== opts.upgrade;\\n  this.path = (opts.path || \\'/engine.io\\').replace(/\\\\/$/, \\'\\') + \\'/\\';\\n  this.forceJSONP = !!opts.forceJSONP;\\n  this.jsonp = false !== opts.jsonp;\\n  this.forceBase64 = !!opts.forceBase64;\\n  this.enablesXDR = !!opts.enablesXDR;\\n  this.timestampParam = opts.timestampParam || \\'t\\';\\n  this.timestampRequests = opts.timestampRequests;\\n  this.transports = opts.transports || [\\'polling\\', \\'websocket\\'];\\n  this.readyState = \\'\\';\\n  this.writeBuffer = [];\\n  this.callbackBuffer = [];\\n  this.policyPort = opts.policyPort || 843;\\n  this.rememberUpgrade = opts.rememberUpgrade || false;\\n  this.open();\\n  this.binaryType = null;\\n  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;\\n}\\n\\nSocket.priorWebsocketSuccess = false;\\n\\n/**\\n * Mix in `Emitter`.\\n */\\n\\nEmitter(Socket.prototype);\\n\\n/**\\n * Protocol version.\\n *\\n * @api public\\n */\\n\\nSocket.protocol = parser.protocol; // this is an int\\n\\n/**\\n * Expose deps for legacy compatibility\\n * and standalone browser access.\\n */\\n\\nSocket.Socket = Socket;\\nSocket.Transport = _dereq_(\\'./transport\\');\\nSocket.transports = _dereq_(\\'./transports\\');\\nSocket.parser = _dereq_(\\'engine.io-parser\\');\\n\\n/**\\n * Creates transport of the given type.\\n *\\n * @param {String} transport name\\n * @return {Transport}\\n * @api private\\n */\\n\\nSocket.prototype.createTransport = function (name) {\\n  debug(\\'creating transport \\\"%s\\\"\\', name);\\n  var query = clone(this.query);\\n\\n  // append engine.io protocol identifier\\n  query.EIO = parser.protocol;\\n\\n  // transport name\\n  query.transport = name;\\n\\n  // session id if we already have one\\n  if (this.id) query.sid = this.id;\\n\\n  var transport = new transports[name]({\\n    agent: this.agent,\\n    hostname: this.hostname,\\n    port: this.port,\\n    secure: this.secure,\\n    path: this.path,\\n    query: query,\\n    forceJSONP: this.forceJSONP,\\n    jsonp: this.jsonp,\\n    forceBase64: this.forceBase64,\\n    enablesXDR: this.enablesXDR,\\n    timestampRequests: this.timestampRequests,\\n    timestampParam: this.timestampParam,\\n    policyPort: this.policyPort,\\n    socket: this\\n  });\\n\\n  return transport;\\n};\\n\\nfunction clone (obj) {\\n  var o = {};\\n  for (var i in obj) {\\n    if (obj.hasOwnProperty(i)) {\\n      o[i] = obj[i];\\n    }\\n  }\\n  return o;\\n}\\n\\n/**\\n * Initializes transport to use and starts probe.\\n *\\n * @api private\\n */\\nSocket.prototype.open = function () {\\n  var transport;\\n  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf(\\'websocket\\') != -1) {\\n    transport = \\'websocket\\';\\n  } else if (0 == this.transports.length) {\\n    // Emit error on next tick so it can be listened to\\n    var self = this;\\n    setTimeout(function() {\\n      self.emit(\\'error\\', \\'No transports available\\');\\n    }, 0);\\n    return;\\n  } else {\\n    transport = this.transports[0];\\n  }\\n  this.readyState = \\'opening\\';\\n\\n  // Retry with the next transport if the transport is disabled (jsonp: false)\\n  var transport;\\n  try {\\n    transport = this.createTransport(transport);\\n  } catch (e) {\\n    this.transports.shift();\\n    this.open();\\n    return;\\n  }\\n\\n  transport.open();\\n  this.setTransport(transport);\\n};\\n\\n/**\\n * Sets the current transport. Disables the existing one (if any).\\n *\\n * @api private\\n */\\n\\nSocket.prototype.setTransport = function(transport){\\n  debug(\\'setting transport %s\\', transport.name);\\n  var self = this;\\n\\n  if (this.transport) {\\n    debug(\\'clearing existing transport %s\\', this.transport.name);\\n    this.transport.removeAllListeners();\\n  }\\n\\n  // set up transport\\n  this.transport = transport;\\n\\n  // set up transport listeners\\n  transport\\n  .on(\\'drain\\', function(){\\n    self.onDrain();\\n  })\\n  .on(\\'packet\\', function(packet){\\n    self.onPacket(packet);\\n  })\\n  .on(\\'error\\', function(e){\\n    self.onError(e);\\n  })\\n  .on(\\'close\\', function(){\\n    self.onClose(\\'transport close\\');\\n  });\\n};\\n\\n/**\\n * Probes a transport.\\n *\\n * @param {String} transport name\\n * @api private\\n */\\n\\nSocket.prototype.probe = function (name) {\\n  debug(\\'probing transport \\\"%s\\\"\\', name);\\n  var transport = this.createTransport(name, { probe: 1 })\\n    , failed = false\\n    , self = this;\\n\\n  Socket.priorWebsocketSuccess = false;\\n\\n  function onTransportOpen(){\\n    if (self.onlyBinaryUpgrades) {\\n      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;\\n      failed = failed || upgradeLosesBinary;\\n    }\\n    if (failed) return;\\n\\n    debug(\\'probe transport \\\"%s\\\" opened\\', name);\\n    transport.send([{ type: \\'ping\\', data: \\'probe\\' }]);\\n    transport.once(\\'packet\\', function (msg) {\\n      if (failed) return;\\n      if (\\'pong\\' == msg.type && \\'probe\\' == msg.data) {\\n        debug(\\'probe transport \\\"%s\\\" pong\\', name);\\n        self.upgrading = true;\\n        self.emit(\\'upgrading\\', transport);\\n        Socket.priorWebsocketSuccess = \\'websocket\\' == transport.name;\\n\\n        debug(\\'pausing current transport \\\"%s\\\"\\', self.transport.name);\\n        self.transport.pause(function () {\\n          if (failed) return;\\n          if (\\'closed\\' == self.readyState || \\'closing\\' == self.readyState) {\\n            return;\\n          }\\n          debug(\\'changing transport and sending upgrade packet\\');\\n\\n          cleanup();\\n\\n          self.setTransport(transport);\\n          transport.send([{ type: \\'upgrade\\' }]);\\n          self.emit(\\'upgrade\\', transport);\\n          transport = null;\\n          self.upgrading = false;\\n          self.flush();\\n        });\\n      } else {\\n        debug(\\'probe transport \\\"%s\\\" failed\\', name);\\n        var err = new Error(\\'probe error\\');\\n        err.transport = transport.name;\\n        self.emit(\\'upgradeError\\', err);\\n      }\\n    });\\n  }\\n\\n  function freezeTransport() {\\n    if (failed) return;\\n\\n    // Any callback called by transport should be ignored since now\\n    failed = true;\\n\\n    cleanup();\\n\\n    transport.close();\\n    transport = null;\\n  }\\n\\n  //Handle any error that happens while probing\\n  function onerror(err) {\\n    var error = new Error(\\'probe error: \\' + err);\\n    error.transport = transport.name;\\n\\n    freezeTransport();\\n\\n    debug(\\'probe transport \\\"%s\\\" failed because of error: %s\\', name, err);\\n\\n    self.emit(\\'upgradeError\\', error);\\n  }\\n\\n  function onTransportClose(){\\n    onerror(\\\"transport closed\\\");\\n  }\\n\\n  //When the socket is closed while we\\'re probing\\n  function onclose(){\\n    onerror(\\\"socket closed\\\");\\n  }\\n\\n  //When the socket is upgraded while we\\'re probing\\n  function onupgrade(to){\\n    if (transport && to.name != transport.name) {\\n      debug(\\'\\\"%s\\\" works - aborting \\\"%s\\\"\\', to.name, transport.name);\\n      freezeTransport();\\n    }\\n  }\\n\\n  //Remove all listeners on the transport and on self\\n  function cleanup(){\\n    transport.removeListener(\\'open\\', onTransportOpen);\\n    transport.removeListener(\\'error\\', onerror);\\n    transport.removeListener(\\'close\\', onTransportClose);\\n    self.removeListener(\\'close\\', onclose);\\n    self.removeListener(\\'upgrading\\', onupgrade);\\n  }\\n\\n  transport.once(\\'open\\', onTransportOpen);\\n  transport.once(\\'error\\', onerror);\\n  transport.once(\\'close\\', onTransportClose);\\n\\n  this.once(\\'close\\', onclose);\\n  this.once(\\'upgrading\\', onupgrade);\\n\\n  transport.open();\\n\\n};\\n\\n/**\\n * Called when connection is deemed open.\\n *\\n * @api public\\n */\\n\\nSocket.prototype.onOpen = function () {\\n  debug(\\'socket open\\');\\n  this.readyState = \\'open\\';\\n  Socket.priorWebsocketSuccess = \\'websocket\\' == this.transport.name;\\n  this.emit(\\'open\\');\\n  this.flush();\\n\\n  // we check for `readyState` in case an `open`\\n  // listener already closed the socket\\n  if (\\'open\\' == this.readyState && this.upgrade && this.transport.pause) {\\n    debug(\\'starting upgrade probes\\');\\n    for (var i = 0, l = this.upgrades.length; i < l; i++) {\\n      this.probe(this.upgrades[i]);\\n    }\\n  }\\n};\\n\\n/**\\n * Handles a packet.\\n *\\n * @api private\\n */\\n\\nSocket.prototype.onPacket = function (packet) {\\n  if (\\'opening\\' == this.readyState || \\'open\\' == this.readyState) {\\n    debug(\\'socket receive: type \\\"%s\\\", data \\\"%s\\\"\\', packet.type, packet.data);\\n\\n    this.emit(\\'packet\\', packet);\\n\\n    // Socket is live - any packet counts\\n    this.emit(\\'heartbeat\\');\\n\\n    switch (packet.type) {\\n      case \\'open\\':\\n        this.onHandshake(parsejson(packet.data));\\n        break;\\n\\n      case \\'pong\\':\\n        this.setPing();\\n        break;\\n\\n      case \\'error\\':\\n        var err = new Error(\\'server error\\');\\n        err.code = packet.data;\\n        this.emit(\\'error\\', err);\\n        break;\\n\\n      case \\'message\\':\\n        this.emit(\\'data\\', packet.data);\\n        this.emit(\\'message\\', packet.data);\\n        break;\\n    }\\n  } else {\\n    debug(\\'packet received with socket readyState \\\"%s\\\"\\', this.readyState);\\n  }\\n};\\n\\n/**\\n * Called upon handshake completion.\\n *\\n * @param {Object} handshake obj\\n * @api private\\n */\\n\\nSocket.prototype.onHandshake = function (data) {\\n  this.emit(\\'handshake\\', data);\\n  this.id = data.sid;\\n  this.transport.query.sid = data.sid;\\n  this.upgrades = this.filterUpgrades(data.upgrades);\\n  this.pingInterval = data.pingInterval;\\n  this.pingTimeout = data.pingTimeout;\\n  this.onOpen();\\n  // In case open handler closes socket\\n  if  (\\'closed\\' == this.readyState) return;\\n  this.setPing();\\n\\n  // Prolong liveness of socket on heartbeat\\n  this.removeListener(\\'heartbeat\\', this.onHeartbeat);\\n  this.on(\\'heartbeat\\', this.onHeartbeat);\\n};\\n\\n/**\\n * Resets ping timeout.\\n *\\n * @api private\\n */\\n\\nSocket.prototype.onHeartbeat = function (timeout) {\\n  clearTimeout(this.pingTimeoutTimer);\\n  var self = this;\\n  self.pingTimeoutTimer = setTimeout(function () {\\n    if (\\'closed\\' == self.readyState) return;\\n    self.onClose(\\'ping timeout\\');\\n  }, timeout || (self.pingInterval + self.pingTimeout));\\n};\\n\\n/**\\n * Pings server every `this.pingInterval` and expects response\\n * within `this.pingTimeout` or closes connection.\\n *\\n * @api private\\n */\\n\\nSocket.prototype.setPing = function () {\\n  var self = this;\\n  clearTimeout(self.pingIntervalTimer);\\n  self.pingIntervalTimer = setTimeout(function () {\\n    debug(\\'writing ping packet - expecting pong within %sms\\', self.pingTimeout);\\n    self.ping();\\n    self.onHeartbeat(self.pingTimeout);\\n  }, self.pingInterval);\\n};\\n\\n/**\\n* Sends a ping packet.\\n*\\n* @api public\\n*/\\n\\nSocket.prototype.ping = function () {\\n  this.sendPacket(\\'ping\\');\\n};\\n\\n/**\\n * Called on `drain` event\\n *\\n * @api private\\n */\\n\\nSocket.prototype.onDrain = function() {\\n  for (var i = 0; i < this.prevBufferLen; i++) {\\n    if (this.callbackBuffer[i]) {\\n      this.callbackBuffer[i]();\\n    }\\n  }\\n\\n  this.writeBuffer.splice(0, this.prevBufferLen);\\n  this.callbackBuffer.splice(0, this.prevBufferLen);\\n\\n  // setting prevBufferLen = 0 is very important\\n  // for example, when upgrading, upgrade packet is sent over,\\n  // and a nonzero prevBufferLen could cause problems on `drain`\\n  this.prevBufferLen = 0;\\n\\n  if (this.writeBuffer.length == 0) {\\n    this.emit(\\'drain\\');\\n  } else {\\n    this.flush();\\n  }\\n};\\n\\n/**\\n * Flush write buffers.\\n *\\n * @api private\\n */\\n\\nSocket.prototype.flush = function () {\\n  if (\\'closed\\' != this.readyState && this.transport.writable &&\\n    !this.upgrading && this.writeBuffer.length) {\\n    debug(\\'flushing %d packets in socket\\', this.writeBuffer.length);\\n    this.transport.send(this.writeBuffer);\\n    // keep track of current length of writeBuffer\\n    // splice writeBuffer and callbackBuffer on `drain`\\n    this.prevBufferLen = this.writeBuffer.length;\\n    this.emit(\\'flush\\');\\n  }\\n};\\n\\n/**\\n * Sends a message.\\n *\\n * @param {String} message.\\n * @param {Function} callback function.\\n * @return {Socket} for chaining.\\n * @api public\\n */\\n\\nSocket.prototype.write =\\nSocket.prototype.send = function (msg, fn) {\\n  this.sendPacket(\\'message\\', msg, fn);\\n  return this;\\n};\\n\\n/**\\n * Sends a packet.\\n *\\n * @param {String} packet type.\\n * @param {String} data.\\n * @param {Function} callback function.\\n * @api private\\n */\\n\\nSocket.prototype.sendPacket = function (type, data, fn) {\\n  var packet = { type: type, data: data };\\n  this.emit(\\'packetCreate\\', packet);\\n  this.writeBuffer.push(packet);\\n  this.callbackBuffer.push(fn);\\n  this.flush();\\n};\\n\\n/**\\n * Closes the connection.\\n *\\n * @api private\\n */\\n\\nSocket.prototype.close = function () {\\n  if (\\'opening\\' == this.readyState || \\'open\\' == this.readyState) {\\n    this.onClose(\\'forced close\\');\\n    debug(\\'socket closing - telling transport to close\\');\\n    this.transport.close();\\n  }\\n\\n  return this;\\n};\\n\\n/**\\n * Called upon transport error\\n *\\n * @api private\\n */\\n\\nSocket.prototype.onError = function (err) {\\n  debug(\\'socket error %j\\', err);\\n  Socket.priorWebsocketSuccess = false;\\n  this.emit(\\'error\\', err);\\n  this.onClose(\\'transport error\\', err);\\n};\\n\\n/**\\n * Called upon transport close.\\n *\\n * @api private\\n */\\n\\nSocket.prototype.onClose = function (reason, desc) {\\n  if (\\'opening\\' == this.readyState || \\'open\\' == this.readyState) {\\n    debug(\\'socket close with reason: \\\"%s\\\"\\', reason);\\n    var self = this;\\n\\n    // clear timers\\n    clearTimeout(this.pingIntervalTimer);\\n    clearTimeout(this.pingTimeoutTimer);\\n\\n    // clean buffers in next tick, so developers can still\\n    // grab the buffers on `close` event\\n    setTimeout(function() {\\n      self.writeBuffer = [];\\n      self.callbackBuffer = [];\\n      self.prevBufferLen = 0;\\n    }, 0);\\n\\n    // stop event from firing again for transport\\n    this.transport.removeAllListeners(\\'close\\');\\n\\n    // ensure transport won\\'t stay open\\n    this.transport.close();\\n\\n    // ignore further transport communication\\n    this.transport.removeAllListeners();\\n\\n    // set ready state\\n    this.readyState = \\'closed\\';\\n\\n    // clear session id\\n    this.id = null;\\n\\n    // emit close event\\n    this.emit(\\'close\\', reason, desc);\\n  }\\n};\\n\\n/**\\n * Filters upgrades, returning only those matching client transports.\\n *\\n * @param {Array} server upgrades\\n * @api private\\n *\\n */\\n\\nSocket.prototype.filterUpgrades = function (upgrades) {\\n  var filteredUpgrades = [];\\n  for (var i = 0, j = upgrades.length; i<j; i++) {\\n    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);\\n  }\\n  return filteredUpgrades;\\n};\\n\\n}).call(this,typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./transport\\\":13,\\\"./transports\\\":14,\\\"component-emitter\\\":8,\\\"debug\\\":9,\\\"engine.io-parser\\\":21,\\\"indexof\\\":36,\\\"parsejson\\\":28,\\\"parseqs\\\":29,\\\"parseuri\\\":30}],13:[function(_dereq_,module,exports){\\n/**\\n * Module dependencies.\\n */\\n\\nvar parser = _dereq_(\\'engine.io-parser\\');\\nvar Emitter = _dereq_(\\'component-emitter\\');\\n\\n/**\\n * Module exports.\\n */\\n\\nmodule.exports = Transport;\\n\\n/**\\n * Transport abstract constructor.\\n *\\n * @param {Object} options.\\n * @api private\\n */\\n\\nfunction Transport (opts) {\\n  this.path = opts.path;\\n  this.hostname = opts.hostname;\\n  this.port = opts.port;\\n  this.secure = opts.secure;\\n  this.query = opts.query;\\n  this.timestampParam = opts.timestampParam;\\n  this.timestampRequests = opts.timestampRequests;\\n  this.readyState = \\'\\';\\n  this.agent = opts.agent || false;\\n  this.socket = opts.socket;\\n  this.enablesXDR = opts.enablesXDR;\\n}\\n\\n/**\\n * Mix in `Emitter`.\\n */\\n\\nEmitter(Transport.prototype);\\n\\n/**\\n * A counter used to prevent collisions in the timestamps used\\n * for cache busting.\\n */\\n\\nTransport.timestamps = 0;\\n\\n/**\\n * Emits an error.\\n *\\n * @param {String} str\\n * @return {Transport} for chaining\\n * @api public\\n */\\n\\nTransport.prototype.onError = function (msg, desc) {\\n  var err = new Error(msg);\\n  err.type = \\'TransportError\\';\\n  err.description = desc;\\n  this.emit(\\'error\\', err);\\n  return this;\\n};\\n\\n/**\\n * Opens the transport.\\n *\\n * @api public\\n */\\n\\nTransport.prototype.open = function () {\\n  if (\\'closed\\' == this.readyState || \\'\\' == this.readyState) {\\n    this.readyState = \\'opening\\';\\n    this.doOpen();\\n  }\\n\\n  return this;\\n};\\n\\n/**\\n * Closes the transport.\\n *\\n * @api private\\n */\\n\\nTransport.prototype.close = function () {\\n  if (\\'opening\\' == this.readyState || \\'open\\' == this.readyState) {\\n    this.doClose();\\n    this.onClose();\\n  }\\n\\n  return this;\\n};\\n\\n/**\\n * Sends multiple packets.\\n *\\n * @param {Array} packets\\n * @api private\\n */\\n\\nTransport.prototype.send = function(packets){\\n  if (\\'open\\' == this.readyState) {\\n    this.write(packets);\\n  } else {\\n    throw new Error(\\'Transport not open\\');\\n  }\\n};\\n\\n/**\\n * Called upon open\\n *\\n * @api private\\n */\\n\\nTransport.prototype.onOpen = function () {\\n  this.readyState = \\'open\\';\\n  this.writable = true;\\n  this.emit(\\'open\\');\\n};\\n\\n/**\\n * Called with data.\\n *\\n * @param {String} data\\n * @api private\\n */\\n\\nTransport.prototype.onData = function(data){\\n  var packet = parser.decodePacket(data, this.socket.binaryType);\\n  this.onPacket(packet);\\n};\\n\\n/**\\n * Called with a decoded packet.\\n */\\n\\nTransport.prototype.onPacket = function (packet) {\\n  this.emit(\\'packet\\', packet);\\n};\\n\\n/**\\n * Called upon close.\\n *\\n * @api private\\n */\\n\\nTransport.prototype.onClose = function () {\\n  this.readyState = \\'closed\\';\\n  this.emit(\\'close\\');\\n};\\n\\n},{\\\"component-emitter\\\":8,\\\"engine.io-parser\\\":21}],14:[function(_dereq_,module,exports){\\n(function (global){\\n/**\\n * Module dependencies\\n */\\n\\nvar XMLHttpRequest = _dereq_(\\'xmlhttprequest\\');\\nvar XHR = _dereq_(\\'./polling-xhr\\');\\nvar JSONP = _dereq_(\\'./polling-jsonp\\');\\nvar websocket = _dereq_(\\'./websocket\\');\\n\\n/**\\n * Export transports.\\n */\\n\\nexports.polling = polling;\\nexports.websocket = websocket;\\n\\n/**\\n * Polling transport polymorphic constructor.\\n * Decides on xhr vs jsonp based on feature detection.\\n *\\n * @api private\\n */\\n\\nfunction polling(opts){\\n  var xhr;\\n  var xd = false;\\n  var xs = false;\\n  var jsonp = false !== opts.jsonp;\\n\\n  if (global.location) {\\n    var isSSL = \\'https:\\' == location.protocol;\\n    var port = location.port;\\n\\n    // some user agents have empty `location.port`\\n    if (!port) {\\n      port = isSSL ? 443 : 80;\\n    }\\n\\n    xd = opts.hostname != location.hostname || port != opts.port;\\n    xs = opts.secure != isSSL;\\n  }\\n\\n  opts.xdomain = xd;\\n  opts.xscheme = xs;\\n  xhr = new XMLHttpRequest(opts);\\n\\n  if (\\'open\\' in xhr && !opts.forceJSONP) {\\n    return new XHR(opts);\\n  } else {\\n    if (!jsonp) throw new Error(\\'JSONP disabled\\');\\n    return new JSONP(opts);\\n  }\\n}\\n\\n}).call(this,typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./polling-jsonp\\\":15,\\\"./polling-xhr\\\":16,\\\"./websocket\\\":18,\\\"xmlhttprequest\\\":19}],15:[function(_dereq_,module,exports){\\n(function (global){\\n\\n/**\\n * Module requirements.\\n */\\n\\nvar Polling = _dereq_(\\'./polling\\');\\nvar inherit = _dereq_(\\'component-inherit\\');\\n\\n/**\\n * Module exports.\\n */\\n\\nmodule.exports = JSONPPolling;\\n\\n/**\\n * Cached regular expressions.\\n */\\n\\nvar rNewline = /\\\\n/g;\\nvar rEscapedNewline = /\\\\\\\\n/g;\\n\\n/**\\n * Global JSONP callbacks.\\n */\\n\\nvar callbacks;\\n\\n/**\\n * Callbacks count.\\n */\\n\\nvar index = 0;\\n\\n/**\\n * Noop.\\n */\\n\\nfunction empty () { }\\n\\n/**\\n * JSONP Polling constructor.\\n *\\n * @param {Object} opts.\\n * @api public\\n */\\n\\nfunction JSONPPolling (opts) {\\n  Polling.call(this, opts);\\n\\n  this.query = this.query || {};\\n\\n  // define global callbacks array if not present\\n  // we do this here (lazily) to avoid unneeded global pollution\\n  if (!callbacks) {\\n    // we need to consider multiple engines in the same page\\n    if (!global.___eio) global.___eio = [];\\n    callbacks = global.___eio;\\n  }\\n\\n  // callback identifier\\n  this.index = callbacks.length;\\n\\n  // add callback to jsonp global\\n  var self = this;\\n  callbacks.push(function (msg) {\\n    self.onData(msg);\\n  });\\n\\n  // append to query string\\n  this.query.j = this.index;\\n\\n  // prevent spurious errors from being emitted when the window is unloaded\\n  if (global.document && global.addEventListener) {\\n    global.addEventListener(\\'beforeunload\\', function () {\\n      if (self.script) self.script.onerror = empty;\\n    });\\n  }\\n}\\n\\n/**\\n * Inherits from Polling.\\n */\\n\\ninherit(JSONPPolling, Polling);\\n\\n/*\\n * JSONP only supports binary as base64 encoded strings\\n */\\n\\nJSONPPolling.prototype.supportsBinary = false;\\n\\n/**\\n * Closes the socket.\\n *\\n * @api private\\n */\\n\\nJSONPPolling.prototype.doClose = function () {\\n  if (this.script) {\\n    this.script.parentNode.removeChild(this.script);\\n    this.script = null;\\n  }\\n\\n  if (this.form) {\\n    this.form.parentNode.removeChild(this.form);\\n    this.form = null;\\n  }\\n\\n  Polling.prototype.doClose.call(this);\\n};\\n\\n/**\\n * Starts a poll cycle.\\n *\\n * @api private\\n */\\n\\nJSONPPolling.prototype.doPoll = function () {\\n  var self = this;\\n  var script = document.createElement(\\'script\\');\\n\\n  if (this.script) {\\n    this.script.parentNode.removeChild(this.script);\\n    this.script = null;\\n  }\\n\\n  script.async = true;\\n  script.src = this.uri();\\n  script.onerror = function(e){\\n    self.onError(\\'jsonp poll error\\',e);\\n  };\\n\\n  var insertAt = document.getElementsByTagName(\\'script\\')[0];\\n  insertAt.parentNode.insertBefore(script, insertAt);\\n  this.script = script;\\n\\n  var isUAgecko = \\'undefined\\' != typeof navigator && /gecko/i.test(navigator.userAgent);\\n\\n  if (isUAgecko) {\\n    setTimeout(function () {\\n      var iframe = document.createElement(\\'iframe\\');\\n      document.body.appendChild(iframe);\\n      document.body.removeChild(iframe);\\n    }, 100);\\n  }\\n};\\n\\n/**\\n * Writes with a hidden iframe.\\n *\\n * @param {String} data to send\\n * @param {Function} called upon flush.\\n * @api private\\n */\\n\\nJSONPPolling.prototype.doWrite = function (data, fn) {\\n  var self = this;\\n\\n  if (!this.form) {\\n    var form = document.createElement(\\'form\\');\\n    var area = document.createElement(\\'textarea\\');\\n    var id = this.iframeId = \\'eio_iframe_\\' + this.index;\\n    var iframe;\\n\\n    form.className = \\'socketio\\';\\n    form.style.position = \\'absolute\\';\\n    form.style.top = \\'-1000px\\';\\n    form.style.left = \\'-1000px\\';\\n    form.target = id;\\n    form.method = \\'POST\\';\\n    form.setAttribute(\\'accept-charset\\', \\'utf-8\\');\\n    area.name = \\'d\\';\\n    form.appendChild(area);\\n    document.body.appendChild(form);\\n\\n    this.form = form;\\n    this.area = area;\\n  }\\n\\n  this.form.action = this.uri();\\n\\n  function complete () {\\n    initIframe();\\n    fn();\\n  }\\n\\n  function initIframe () {\\n    if (self.iframe) {\\n      try {\\n        self.form.removeChild(self.iframe);\\n      } catch (e) {\\n        self.onError(\\'jsonp polling iframe removal error\\', e);\\n      }\\n    }\\n\\n    try {\\n      // ie6 dynamic iframes with target=\\\"\\\" support (thanks Chris Lambacher)\\n      var html = \\'<iframe src=\\\"javascript:0\\\" name=\\\"\\'+ self.iframeId +\\'\\\">\\';\\n      iframe = document.createElement(html);\\n    } catch (e) {\\n      iframe = document.createElement(\\'iframe\\');\\n      iframe.name = self.iframeId;\\n      iframe.src = \\'javascript:0\\';\\n    }\\n\\n    iframe.id = self.iframeId;\\n\\n    self.form.appendChild(iframe);\\n    self.iframe = iframe;\\n  }\\n\\n  initIframe();\\n\\n  // escape \\\\n to prevent it from being converted into \\\\r\\\\n by some UAs\\n  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side\\n  data = data.replace(rEscapedNewline, \\'\\\\\\\\\\\\n\\');\\n  this.area.value = data.replace(rNewline, \\'\\\\\\\\n\\');\\n\\n  try {\\n    this.form.submit();\\n  } catch(e) {}\\n\\n  if (this.iframe.attachEvent) {\\n    this.iframe.onreadystatechange = function(){\\n      if (self.iframe.readyState == \\'complete\\') {\\n        complete();\\n      }\\n    };\\n  } else {\\n    this.iframe.onload = complete;\\n  }\\n};\\n\\n}).call(this,typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./polling\\\":17,\\\"component-inherit\\\":20}],16:[function(_dereq_,module,exports){\\n(function (global){\\n/**\\n * Module requirements.\\n */\\n\\nvar XMLHttpRequest = _dereq_(\\'xmlhttprequest\\');\\nvar Polling = _dereq_(\\'./polling\\');\\nvar Emitter = _dereq_(\\'component-emitter\\');\\nvar inherit = _dereq_(\\'component-inherit\\');\\nvar debug = _dereq_(\\'debug\\')(\\'engine.io-client:polling-xhr\\');\\n\\n/**\\n * Module exports.\\n */\\n\\nmodule.exports = XHR;\\nmodule.exports.Request = Request;\\n\\n/**\\n * Empty function\\n */\\n\\nfunction empty(){}\\n\\n/**\\n * XHR Polling constructor.\\n *\\n * @param {Object} opts\\n * @api public\\n */\\n\\nfunction XHR(opts){\\n  Polling.call(this, opts);\\n\\n  if (global.location) {\\n    var isSSL = \\'https:\\' == location.protocol;\\n    var port = location.port;\\n\\n    // some user agents have empty `location.port`\\n    if (!port) {\\n      port = isSSL ? 443 : 80;\\n    }\\n\\n    this.xd = opts.hostname != global.location.hostname ||\\n      port != opts.port;\\n    this.xs = opts.secure != isSSL;\\n  }\\n}\\n\\n/**\\n * Inherits from Polling.\\n */\\n\\ninherit(XHR, Polling);\\n\\n/**\\n * XHR supports binary\\n */\\n\\nXHR.prototype.supportsBinary = true;\\n\\n/**\\n * Creates a request.\\n *\\n * @param {String} method\\n * @api private\\n */\\n\\nXHR.prototype.request = function(opts){\\n  opts = opts || {};\\n  opts.uri = this.uri();\\n  opts.xd = this.xd;\\n  opts.xs = this.xs;\\n  opts.agent = this.agent || false;\\n  opts.supportsBinary = this.supportsBinary;\\n  opts.enablesXDR = this.enablesXDR;\\n  return new Request(opts);\\n};\\n\\n/**\\n * Sends data.\\n *\\n * @param {String} data to send.\\n * @param {Function} called upon flush.\\n * @api private\\n */\\n\\nXHR.prototype.doWrite = function(data, fn){\\n  var isBinary = typeof data !== \\'string\\' && data !== undefined;\\n  var req = this.request({ method: \\'POST\\', data: data, isBinary: isBinary });\\n  var self = this;\\n  req.on(\\'success\\', fn);\\n  req.on(\\'error\\', function(err){\\n    self.onError(\\'xhr post error\\', err);\\n  });\\n  this.sendXhr = req;\\n};\\n\\n/**\\n * Starts a poll cycle.\\n *\\n * @api private\\n */\\n\\nXHR.prototype.doPoll = function(){\\n  debug(\\'xhr poll\\');\\n  var req = this.request();\\n  var self = this;\\n  req.on(\\'data\\', function(data){\\n    self.onData(data);\\n  });\\n  req.on(\\'error\\', function(err){\\n    self.onError(\\'xhr poll error\\', err);\\n  });\\n  this.pollXhr = req;\\n};\\n\\n/**\\n * Request constructor\\n *\\n * @param {Object} options\\n * @api public\\n */\\n\\nfunction Request(opts){\\n  this.method = opts.method || \\'GET\\';\\n  this.uri = opts.uri;\\n  this.xd = !!opts.xd;\\n  this.xs = !!opts.xs;\\n  this.async = false !== opts.async;\\n  this.data = undefined != opts.data ? opts.data : null;\\n  this.agent = opts.agent;\\n  this.isBinary = opts.isBinary;\\n  this.supportsBinary = opts.supportsBinary;\\n  this.enablesXDR = opts.enablesXDR;\\n  this.create();\\n}\\n\\n/**\\n * Mix in `Emitter`.\\n */\\n\\nEmitter(Request.prototype);\\n\\n/**\\n * Creates the XHR object and sends the request.\\n *\\n * @api private\\n */\\n\\nRequest.prototype.create = function(){\\n  var xhr = this.xhr = new XMLHttpRequest({ agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR });\\n  var self = this;\\n\\n  try {\\n    debug(\\'xhr open %s: %s\\', this.method, this.uri);\\n    xhr.open(this.method, this.uri, this.async);\\n    if (this.supportsBinary) {\\n      // This has to be done after open because Firefox is stupid\\n      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension\\n      xhr.responseType = \\'arraybuffer\\';\\n    }\\n\\n    if (\\'POST\\' == this.method) {\\n      try {\\n        if (this.isBinary) {\\n          xhr.setRequestHeader(\\'Content-type\\', \\'application/octet-stream\\');\\n        } else {\\n          xhr.setRequestHeader(\\'Content-type\\', \\'text/plain;charset=UTF-8\\');\\n        }\\n      } catch (e) {}\\n    }\\n\\n    // ie6 check\\n    if (\\'withCredentials\\' in xhr) {\\n      xhr.withCredentials = true;\\n    }\\n\\n    if (this.hasXDR()) {\\n      xhr.onload = function(){\\n        self.onLoad();\\n      };\\n      xhr.onerror = function(){\\n        self.onError(xhr.responseText);\\n      };\\n    } else {\\n      xhr.onreadystatechange = function(){\\n        if (4 != xhr.readyState) return;\\n        if (200 == xhr.status || 1223 == xhr.status) {\\n          self.onLoad();\\n        } else {\\n          // make sure the `error` event handler that\\'s user-set\\n          // does not throw in the same tick and gets caught here\\n          setTimeout(function(){\\n            self.onError(xhr.status);\\n          }, 0);\\n        }\\n      };\\n    }\\n\\n    debug(\\'xhr data %s\\', this.data);\\n    xhr.send(this.data);\\n  } catch (e) {\\n    // Need to defer since .create() is called directly fhrom the constructor\\n    // and thus the \\'error\\' event can only be only bound *after* this exception\\n    // occurs.  Therefore, also, we cannot throw here at all.\\n    setTimeout(function() {\\n      self.onError(e);\\n    }, 0);\\n    return;\\n  }\\n\\n  if (global.document) {\\n    this.index = Request.requestsCount++;\\n    Request.requests[this.index] = this;\\n  }\\n};\\n\\n/**\\n * Called upon successful response.\\n *\\n * @api private\\n */\\n\\nRequest.prototype.onSuccess = function(){\\n  this.emit(\\'success\\');\\n  this.cleanup();\\n};\\n\\n/**\\n * Called if we have data.\\n *\\n * @api private\\n */\\n\\nRequest.prototype.onData = function(data){\\n  this.emit(\\'data\\', data);\\n  this.onSuccess();\\n};\\n\\n/**\\n * Called upon error.\\n *\\n * @api private\\n */\\n\\nRequest.prototype.onError = function(err){\\n  this.emit(\\'error\\', err);\\n  this.cleanup();\\n};\\n\\n/**\\n * Cleans up house.\\n *\\n * @api private\\n */\\n\\nRequest.prototype.cleanup = function(){\\n  if (\\'undefined\\' == typeof this.xhr || null === this.xhr) {\\n    return;\\n  }\\n  // xmlhttprequest\\n  if (this.hasXDR()) {\\n    this.xhr.onload = this.xhr.onerror = empty;\\n  } else {\\n    this.xhr.onreadystatechange = empty;\\n  }\\n\\n  try {\\n    this.xhr.abort();\\n  } catch(e) {}\\n\\n  if (global.document) {\\n    delete Request.requests[this.index];\\n  }\\n\\n  this.xhr = null;\\n};\\n\\n/**\\n * Called upon load.\\n *\\n * @api private\\n */\\n\\nRequest.prototype.onLoad = function(){\\n  var data;\\n  try {\\n    var contentType;\\n    try {\\n      contentType = this.xhr.getResponseHeader(\\'Content-Type\\');\\n    } catch (e) {}\\n    if (contentType === \\'application/octet-stream\\') {\\n      data = this.xhr.response;\\n    } else {\\n      if (!this.supportsBinary) {\\n        data = this.xhr.responseText;\\n      } else {\\n        data = \\'ok\\';\\n      }\\n    }\\n  } catch (e) {\\n    this.onError(e);\\n  }\\n  if (null != data) {\\n    this.onData(data);\\n  }\\n};\\n\\n/**\\n * Check if it has XDomainRequest.\\n *\\n * @api private\\n */\\n\\nRequest.prototype.hasXDR = function(){\\n  return \\'undefined\\' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;\\n};\\n\\n/**\\n * Aborts the request.\\n *\\n * @api public\\n */\\n\\nRequest.prototype.abort = function(){\\n  this.cleanup();\\n};\\n\\n/**\\n * Aborts pending requests when unloading the window. This is needed to prevent\\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\\n * emitted.\\n */\\n\\nif (global.document) {\\n  Request.requestsCount = 0;\\n  Request.requests = {};\\n  if (global.attachEvent) {\\n    global.attachEvent(\\'onunload\\', unloadHandler);\\n  } else if (global.addEventListener) {\\n    global.addEventListener(\\'beforeunload\\', unloadHandler);\\n  }\\n}\\n\\nfunction unloadHandler() {\\n  for (var i in Request.requests) {\\n    if (Request.requests.hasOwnProperty(i)) {\\n      Request.requests[i].abort();\\n    }\\n  }\\n}\\n\\n}).call(this,typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./polling\\\":17,\\\"component-emitter\\\":8,\\\"component-inherit\\\":20,\\\"debug\\\":9,\\\"xmlhttprequest\\\":19}],17:[function(_dereq_,module,exports){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Transport = _dereq_(\\'../transport\\');\\nvar parseqs = _dereq_(\\'parseqs\\');\\nvar parser = _dereq_(\\'engine.io-parser\\');\\nvar inherit = _dereq_(\\'component-inherit\\');\\nvar debug = _dereq_(\\'debug\\')(\\'engine.io-client:polling\\');\\n\\n/**\\n * Module exports.\\n */\\n\\nmodule.exports = Polling;\\n\\n/**\\n * Is XHR2 supported?\\n */\\n\\nvar hasXHR2 = (function() {\\n  var XMLHttpRequest = _dereq_(\\'xmlhttprequest\\');\\n  var xhr = new XMLHttpRequest({ agent: this.agent, xdomain: false });\\n  return null != xhr.responseType;\\n})();\\n\\n/**\\n * Polling interface.\\n *\\n * @param {Object} opts\\n * @api private\\n */\\n\\nfunction Polling(opts){\\n  var forceBase64 = (opts && opts.forceBase64);\\n  if (!hasXHR2 || forceBase64) {\\n    this.supportsBinary = false;\\n  }\\n  Transport.call(this, opts);\\n}\\n\\n/**\\n * Inherits from Transport.\\n */\\n\\ninherit(Polling, Transport);\\n\\n/**\\n * Transport name.\\n */\\n\\nPolling.prototype.name = \\'polling\\';\\n\\n/**\\n * Opens the socket (triggers polling). We write a PING message to determine\\n * when the transport is open.\\n *\\n * @api private\\n */\\n\\nPolling.prototype.doOpen = function(){\\n  this.poll();\\n};\\n\\n/**\\n * Pauses polling.\\n *\\n * @param {Function} callback upon buffers are flushed and transport is paused\\n * @api private\\n */\\n\\nPolling.prototype.pause = function(onPause){\\n  var pending = 0;\\n  var self = this;\\n\\n  this.readyState = \\'pausing\\';\\n\\n  function pause(){\\n    debug(\\'paused\\');\\n    self.readyState = \\'paused\\';\\n    onPause();\\n  }\\n\\n  if (this.polling || !this.writable) {\\n    var total = 0;\\n\\n    if (this.polling) {\\n      debug(\\'we are currently polling - waiting to pause\\');\\n      total++;\\n      this.once(\\'pollComplete\\', function(){\\n        debug(\\'pre-pause polling complete\\');\\n        --total || pause();\\n      });\\n    }\\n\\n    if (!this.writable) {\\n      debug(\\'we are currently writing - waiting to pause\\');\\n      total++;\\n      this.once(\\'drain\\', function(){\\n        debug(\\'pre-pause writing complete\\');\\n        --total || pause();\\n      });\\n    }\\n  } else {\\n    pause();\\n  }\\n};\\n\\n/**\\n * Starts polling cycle.\\n *\\n * @api public\\n */\\n\\nPolling.prototype.poll = function(){\\n  debug(\\'polling\\');\\n  this.polling = true;\\n  this.doPoll();\\n  this.emit(\\'poll\\');\\n};\\n\\n/**\\n * Overloads onData to detect payloads.\\n *\\n * @api private\\n */\\n\\nPolling.prototype.onData = function(data){\\n  var self = this;\\n  debug(\\'polling got data %s\\', data);\\n  var callback = function(packet, index, total) {\\n    // if its the first message we consider the transport open\\n    if (\\'opening\\' == self.readyState) {\\n      self.onOpen();\\n    }\\n\\n    // if its a close packet, we close the ongoing requests\\n    if (\\'close\\' == packet.type) {\\n      self.onClose();\\n      return false;\\n    }\\n\\n    // otherwise bypass onData and handle the message\\n    self.onPacket(packet);\\n  };\\n\\n  // decode payload\\n  parser.decodePayload(data, this.socket.binaryType, callback);\\n\\n  // if an event did not trigger closing\\n  if (\\'closed\\' != this.readyState) {\\n    // if we got data we\\'re not polling\\n    this.polling = false;\\n    this.emit(\\'pollComplete\\');\\n\\n    if (\\'open\\' == this.readyState) {\\n      this.poll();\\n    } else {\\n      debug(\\'ignoring poll - transport state \\\"%s\\\"\\', this.readyState);\\n    }\\n  }\\n};\\n\\n/**\\n * For polling, send a close packet.\\n *\\n * @api private\\n */\\n\\nPolling.prototype.doClose = function(){\\n  var self = this;\\n\\n  function close(){\\n    debug(\\'writing close packet\\');\\n    self.write([{ type: \\'close\\' }]);\\n  }\\n\\n  if (\\'open\\' == this.readyState) {\\n    debug(\\'transport open - closing\\');\\n    close();\\n  } else {\\n    // in case we\\'re trying to close while\\n    // handshaking is in progress (GH-164)\\n    debug(\\'transport not open - deferring close\\');\\n    this.once(\\'open\\', close);\\n  }\\n};\\n\\n/**\\n * Writes a packets payload.\\n *\\n * @param {Array} data packets\\n * @param {Function} drain callback\\n * @api private\\n */\\n\\nPolling.prototype.write = function(packets){\\n  var self = this;\\n  this.writable = false;\\n  var callbackfn = function() {\\n    self.writable = true;\\n    self.emit(\\'drain\\');\\n  };\\n\\n  var self = this;\\n  parser.encodePayload(packets, this.supportsBinary, function(data) {\\n    self.doWrite(data, callbackfn);\\n  });\\n};\\n\\n/**\\n * Generates uri for connection.\\n *\\n * @api private\\n */\\n\\nPolling.prototype.uri = function(){\\n  var query = this.query || {};\\n  var schema = this.secure ? \\'https\\' : \\'http\\';\\n  var port = \\'\\';\\n\\n  // cache busting is forced\\n  if (false !== this.timestampRequests) {\\n    query[this.timestampParam] = +new Date + \\'-\\' + Transport.timestamps++;\\n  }\\n\\n  if (!this.supportsBinary && !query.sid) {\\n    query.b64 = 1;\\n  }\\n\\n  query = parseqs.encode(query);\\n\\n  // avoid port if default for schema\\n  if (this.port && ((\\'https\\' == schema && this.port != 443) ||\\n     (\\'http\\' == schema && this.port != 80))) {\\n    port = \\':\\' + this.port;\\n  }\\n\\n  // prepend ? to query\\n  if (query.length) {\\n    query = \\'?\\' + query;\\n  }\\n\\n  return schema + \\'://\\' + this.hostname + port + this.path + query;\\n};\\n\\n},{\\\"../transport\\\":13,\\\"component-inherit\\\":20,\\\"debug\\\":9,\\\"engine.io-parser\\\":21,\\\"parseqs\\\":29,\\\"xmlhttprequest\\\":19}],18:[function(_dereq_,module,exports){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Transport = _dereq_(\\'../transport\\');\\nvar parser = _dereq_(\\'engine.io-parser\\');\\nvar parseqs = _dereq_(\\'parseqs\\');\\nvar inherit = _dereq_(\\'component-inherit\\');\\nvar debug = _dereq_(\\'debug\\')(\\'engine.io-client:websocket\\');\\n\\n/**\\n * `ws` exposes a WebSocket-compatible interface in\\n * Node, or the `WebSocket` or `MozWebSocket` globals\\n * in the browser.\\n */\\n\\nvar WebSocket = _dereq_(\\'ws\\');\\n\\n/**\\n * Module exports.\\n */\\n\\nmodule.exports = WS;\\n\\n/**\\n * WebSocket transport constructor.\\n *\\n * @api {Object} connection options\\n * @api public\\n */\\n\\nfunction WS(opts){\\n  var forceBase64 = (opts && opts.forceBase64);\\n  if (forceBase64) {\\n    this.supportsBinary = false;\\n  }\\n  Transport.call(this, opts);\\n}\\n\\n/**\\n * Inherits from Transport.\\n */\\n\\ninherit(WS, Transport);\\n\\n/**\\n * Transport name.\\n *\\n * @api public\\n */\\n\\nWS.prototype.name = \\'websocket\\';\\n\\n/*\\n * WebSockets support binary\\n */\\n\\nWS.prototype.supportsBinary = true;\\n\\n/**\\n * Opens socket.\\n *\\n * @api private\\n */\\n\\nWS.prototype.doOpen = function(){\\n  if (!this.check()) {\\n    // let probe timeout\\n    return;\\n  }\\n\\n  var self = this;\\n  var uri = this.uri();\\n  var protocols = void(0);\\n  var opts = { agent: this.agent };\\n\\n  this.ws = new WebSocket(uri, protocols, opts);\\n\\n  if (this.ws.binaryType === undefined) {\\n    this.supportsBinary = false;\\n  }\\n\\n  this.ws.binaryType = \\'arraybuffer\\';\\n  this.addEventListeners();\\n};\\n\\n/**\\n * Adds event listeners to the socket\\n *\\n * @api private\\n */\\n\\nWS.prototype.addEventListeners = function(){\\n  var self = this;\\n\\n  this.ws.onopen = function(){\\n    self.onOpen();\\n  };\\n  this.ws.onclose = function(){\\n    self.onClose();\\n  };\\n  this.ws.onmessage = function(ev){\\n    self.onData(ev.data);\\n  };\\n  this.ws.onerror = function(e){\\n    self.onError(\\'websocket error\\', e);\\n  };\\n};\\n\\n/**\\n * Override `onData` to use a timer on iOS.\\n * See: https://gist.github.com/mloughran/2052006\\n *\\n * @api private\\n */\\n\\nif (\\'undefined\\' != typeof navigator\\n  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {\\n  WS.prototype.onData = function(data){\\n    var self = this;\\n    setTimeout(function(){\\n      Transport.prototype.onData.call(self, data);\\n    }, 0);\\n  };\\n}\\n\\n/**\\n * Writes data to socket.\\n *\\n * @param {Array} array of packets.\\n * @api private\\n */\\n\\nWS.prototype.write = function(packets){\\n  var self = this;\\n  this.writable = false;\\n  // encodePacket efficient as it uses WS framing\\n  // no need for encodePayload\\n  for (var i = 0, l = packets.length; i < l; i++) {\\n    parser.encodePacket(packets[i], this.supportsBinary, function(data) {\\n      //Sometimes the websocket has already been closed but the browser didn\\'t\\n      //have a chance of informing us about it yet, in that case send will\\n      //throw an error\\n      try {\\n        self.ws.send(data);\\n      } catch (e){\\n        debug(\\'websocket closed before onclose event\\');\\n      }\\n    });\\n  }\\n\\n  function ondrain() {\\n    self.writable = true;\\n    self.emit(\\'drain\\');\\n  }\\n  // fake drain\\n  // defer to next tick to allow Socket to clear writeBuffer\\n  setTimeout(ondrain, 0);\\n};\\n\\n/**\\n * Called upon close\\n *\\n * @api private\\n */\\n\\nWS.prototype.onClose = function(){\\n  Transport.prototype.onClose.call(this);\\n};\\n\\n/**\\n * Closes socket.\\n *\\n * @api private\\n */\\n\\nWS.prototype.doClose = function(){\\n  if (typeof this.ws !== \\'undefined\\') {\\n    this.ws.close();\\n  }\\n};\\n\\n/**\\n * Generates uri for connection.\\n *\\n * @api private\\n */\\n\\nWS.prototype.uri = function(){\\n  var query = this.query || {};\\n  var schema = this.secure ? \\'wss\\' : \\'ws\\';\\n  var port = \\'\\';\\n\\n  // avoid port if default for schema\\n  if (this.port && ((\\'wss\\' == schema && this.port != 443)\\n    || (\\'ws\\' == schema && this.port != 80))) {\\n    port = \\':\\' + this.port;\\n  }\\n\\n  // append timestamp to URI\\n  if (this.timestampRequests) {\\n    query[this.timestampParam] = +new Date;\\n  }\\n\\n  // communicate binary support capabilities\\n  if (!this.supportsBinary) {\\n    query.b64 = 1;\\n  }\\n\\n  query = parseqs.encode(query);\\n\\n  // prepend ? to query\\n  if (query.length) {\\n    query = \\'?\\' + query;\\n  }\\n\\n  return schema + \\'://\\' + this.hostname + port + this.path + query;\\n};\\n\\n/**\\n * Feature detection for WebSocket.\\n *\\n * @return {Boolean} whether this transport is available.\\n * @api public\\n */\\n\\nWS.prototype.check = function(){\\n  return !!WebSocket && !(\\'__initialize\\' in WebSocket && this.name === WS.prototype.name);\\n};\\n\\n},{\\\"../transport\\\":13,\\\"component-inherit\\\":20,\\\"debug\\\":9,\\\"engine.io-parser\\\":21,\\\"parseqs\\\":29,\\\"ws\\\":31}],19:[function(_dereq_,module,exports){\\n// browser shim for xmlhttprequest module\\nvar hasCORS = _dereq_(\\'has-cors\\');\\n\\nmodule.exports = function(opts) {\\n  var xdomain = opts.xdomain;\\n\\n  // scheme must be same when usign XDomainRequest\\n  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx\\n  var xscheme = opts.xscheme;\\n\\n  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.\\n  // https://github.com/Automattic/engine.io-client/pull/217\\n  var enablesXDR = opts.enablesXDR;\\n\\n  // Use XDomainRequest for IE8 if enablesXDR is true\\n  // because loading bar keeps flashing when using jsonp-polling\\n  // https://github.com/yujiosaka/socke.io-ie8-loading-example\\n  try {\\n    if (\\'undefined\\' != typeof XDomainRequest && !xscheme && enablesXDR) {\\n      return new XDomainRequest();\\n    }\\n  } catch (e) { }\\n\\n  // XMLHttpRequest can be disabled on IE\\n  try {\\n    if (\\'undefined\\' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {\\n      return new XMLHttpRequest();\\n    }\\n  } catch (e) { }\\n\\n  if (!xdomain) {\\n    try {\\n      return new ActiveXObject(\\'Microsoft.XMLHTTP\\');\\n    } catch(e) { }\\n  }\\n}\\n\\n},{\\\"has-cors\\\":34}],20:[function(_dereq_,module,exports){\\n\\nmodule.exports = function(a, b){\\n  var fn = function(){};\\n  fn.prototype = b.prototype;\\n  a.prototype = new fn;\\n  a.prototype.constructor = a;\\n};\\n},{}],21:[function(_dereq_,module,exports){\\n(function (global){\\n/**\\n * Module dependencies.\\n */\\n\\nvar keys = _dereq_(\\'./keys\\');\\nvar sliceBuffer = _dereq_(\\'arraybuffer.slice\\');\\nvar base64encoder = _dereq_(\\'base64-arraybuffer\\');\\nvar after = _dereq_(\\'after\\');\\nvar utf8 = _dereq_(\\'utf8\\');\\n\\n/**\\n * Check if we are running an android browser. That requires us to use\\n * ArrayBuffer with polling transports...\\n *\\n * http://ghinda.net/jpeg-blob-ajax-android/\\n */\\n\\nvar isAndroid = navigator.userAgent.match(/Android/i);\\n\\n/**\\n * Current protocol version.\\n */\\n\\nexports.protocol = 3;\\n\\n/**\\n * Packet types.\\n */\\n\\nvar packets = exports.packets = {\\n    open:     0    // non-ws\\n  , close:    1    // non-ws\\n  , ping:     2\\n  , pong:     3\\n  , message:  4\\n  , upgrade:  5\\n  , noop:     6\\n};\\n\\nvar packetslist = keys(packets);\\n\\n/**\\n * Premade error packet.\\n */\\n\\nvar err = { type: \\'error\\', data: \\'parser error\\' };\\n\\n/**\\n * Create a blob api even for blob builder when vendor prefixes exist\\n */\\n\\nvar Blob = _dereq_(\\'blob\\');\\n\\n/**\\n * Encodes a packet.\\n *\\n *     <packet type id> [ <data> ]\\n *\\n * Example:\\n *\\n *     5hello world\\n *     3\\n *     4\\n *\\n * Binary is encoded in an identical principle\\n *\\n * @api private\\n */\\n\\nexports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {\\n  if (\\'function\\' == typeof supportsBinary) {\\n    callback = supportsBinary;\\n    supportsBinary = false;\\n  }\\n\\n  if (\\'function\\' == typeof utf8encode) {\\n    callback = utf8encode;\\n    utf8encode = null;\\n  }\\n\\n  var data = (packet.data === undefined)\\n    ? undefined\\n    : packet.data.buffer || packet.data;\\n\\n  if (global.ArrayBuffer && data instanceof ArrayBuffer) {\\n    return encodeArrayBuffer(packet, supportsBinary, callback);\\n  } else if (Blob && data instanceof global.Blob) {\\n    return encodeBlob(packet, supportsBinary, callback);\\n  }\\n\\n  // Sending data as a utf-8 string\\n  var encoded = packets[packet.type];\\n\\n  // data fragment is optional\\n  if (undefined !== packet.data) {\\n    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);\\n  }\\n\\n  return callback(\\'\\' + encoded);\\n\\n};\\n\\n/**\\n * Encode packet helpers for binary types\\n */\\n\\nfunction encodeArrayBuffer(packet, supportsBinary, callback) {\\n  if (!supportsBinary) {\\n    return exports.encodeBase64Packet(packet, callback);\\n  }\\n\\n  var data = packet.data;\\n  var contentArray = new Uint8Array(data);\\n  var resultBuffer = new Uint8Array(1 + data.byteLength);\\n\\n  resultBuffer[0] = packets[packet.type];\\n  for (var i = 0; i < contentArray.length; i++) {\\n    resultBuffer[i+1] = contentArray[i];\\n  }\\n\\n  return callback(resultBuffer.buffer);\\n}\\n\\nfunction encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {\\n  if (!supportsBinary) {\\n    return exports.encodeBase64Packet(packet, callback);\\n  }\\n\\n  var fr = new FileReader();\\n  fr.onload = function() {\\n    packet.data = fr.result;\\n    exports.encodePacket(packet, supportsBinary, true, callback);\\n  };\\n  return fr.readAsArrayBuffer(packet.data);\\n}\\n\\nfunction encodeBlob(packet, supportsBinary, callback) {\\n  if (!supportsBinary) {\\n    return exports.encodeBase64Packet(packet, callback);\\n  }\\n\\n  if (isAndroid) {\\n    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);\\n  }\\n\\n  var length = new Uint8Array(1);\\n  length[0] = packets[packet.type];\\n  var blob = new Blob([length.buffer, packet.data]);\\n\\n  return callback(blob);\\n}\\n\\n/**\\n * Encodes a packet with binary data in a base64 string\\n *\\n * @param {Object} packet, has `type` and `data`\\n * @return {String} base64 encoded message\\n */\\n\\nexports.encodeBase64Packet = function(packet, callback) {\\n  var message = \\'b\\' + exports.packets[packet.type];\\n  if (Blob && packet.data instanceof Blob) {\\n    var fr = new FileReader();\\n    fr.onload = function() {\\n      var b64 = fr.result.split(\\',\\')[1];\\n      callback(message + b64);\\n    };\\n    return fr.readAsDataURL(packet.data);\\n  }\\n\\n  var b64data;\\n  try {\\n    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));\\n  } catch (e) {\\n    // iPhone Safari doesn\\'t let you apply with typed arrays\\n    var typed = new Uint8Array(packet.data);\\n    var basic = new Array(typed.length);\\n    for (var i = 0; i < typed.length; i++) {\\n      basic[i] = typed[i];\\n    }\\n    b64data = String.fromCharCode.apply(null, basic);\\n  }\\n  message += global.btoa(b64data);\\n  return callback(message);\\n};\\n\\n/**\\n * Decodes a packet. Changes format to Blob if requested.\\n *\\n * @return {Object} with `type` and `data` (if any)\\n * @api private\\n */\\n\\nexports.decodePacket = function (data, binaryType, utf8decode) {\\n  // String data\\n  if (typeof data == \\'string\\' || data === undefined) {\\n    if (data.charAt(0) == \\'b\\') {\\n      return exports.decodeBase64Packet(data.substr(1), binaryType);\\n    }\\n\\n    if (utf8decode) {\\n      try {\\n        data = utf8.decode(data);\\n      } catch (e) {\\n        return err;\\n      }\\n    }\\n    var type = data.charAt(0);\\n\\n    if (Number(type) != type || !packetslist[type]) {\\n      return err;\\n    }\\n\\n    if (data.length > 1) {\\n      return { type: packetslist[type], data: data.substring(1) };\\n    } else {\\n      return { type: packetslist[type] };\\n    }\\n  }\\n\\n  var asArray = new Uint8Array(data);\\n  var type = asArray[0];\\n  var rest = sliceBuffer(data, 1);\\n  if (Blob && binaryType === \\'blob\\') {\\n    rest = new Blob([rest]);\\n  }\\n  return { type: packetslist[type], data: rest };\\n};\\n\\n/**\\n * Decodes a packet encoded in a base64 string\\n *\\n * @param {String} base64 encoded message\\n * @return {Object} with `type` and `data` (if any)\\n */\\n\\nexports.decodeBase64Packet = function(msg, binaryType) {\\n  var type = packetslist[msg.charAt(0)];\\n  if (!global.ArrayBuffer) {\\n    return { type: type, data: { base64: true, data: msg.substr(1) } };\\n  }\\n\\n  var data = base64encoder.decode(msg.substr(1));\\n\\n  if (binaryType === \\'blob\\' && Blob) {\\n    data = new Blob([data]);\\n  }\\n\\n  return { type: type, data: data };\\n};\\n\\n/**\\n * Encodes multiple messages (payload).\\n *\\n *     <length>:data\\n *\\n * Example:\\n *\\n *     11:hello world2:hi\\n *\\n * If any contents are binary, they will be encoded as base64 strings. Base64\\n * encoded strings are marked with a b before the length specifier\\n *\\n * @param {Array} packets\\n * @api private\\n */\\n\\nexports.encodePayload = function (packets, supportsBinary, callback) {\\n  if (typeof supportsBinary == \\'function\\') {\\n    callback = supportsBinary;\\n    supportsBinary = null;\\n  }\\n\\n  if (supportsBinary) {\\n    if (Blob && !isAndroid) {\\n      return exports.encodePayloadAsBlob(packets, callback);\\n    }\\n\\n    return exports.encodePayloadAsArrayBuffer(packets, callback);\\n  }\\n\\n  if (!packets.length) {\\n    return callback(\\'0:\\');\\n  }\\n\\n  function setLengthHeader(message) {\\n    return message.length + \\':\\' + message;\\n  }\\n\\n  function encodeOne(packet, doneCallback) {\\n    exports.encodePacket(packet, supportsBinary, true, function(message) {\\n      doneCallback(null, setLengthHeader(message));\\n    });\\n  }\\n\\n  map(packets, encodeOne, function(err, results) {\\n    return callback(results.join(\\'\\'));\\n  });\\n};\\n\\n/**\\n * Async array map using after\\n */\\n\\nfunction map(ary, each, done) {\\n  var result = new Array(ary.length);\\n  var next = after(ary.length, done);\\n\\n  var eachWithIndex = function(i, el, cb) {\\n    each(el, function(error, msg) {\\n      result[i] = msg;\\n      cb(error, result);\\n    });\\n  };\\n\\n  for (var i = 0; i < ary.length; i++) {\\n    eachWithIndex(i, ary[i], next);\\n  }\\n}\\n\\n/*\\n * Decodes data when a payload is maybe expected. Possible binary contents are\\n * decoded from their base64 representation\\n *\\n * @param {String} data, callback method\\n * @api public\\n */\\n\\nexports.decodePayload = function (data, binaryType, callback) {\\n  if (typeof data != \\'string\\') {\\n    return exports.decodePayloadAsBinary(data, binaryType, callback);\\n  }\\n\\n  if (typeof binaryType === \\'function\\') {\\n    callback = binaryType;\\n    binaryType = null;\\n  }\\n\\n  var packet;\\n  if (data == \\'\\') {\\n    // parser error - ignoring payload\\n    return callback(err, 0, 1);\\n  }\\n\\n  var length = \\'\\'\\n    , n, msg;\\n\\n  for (var i = 0, l = data.length; i < l; i++) {\\n    var chr = data.charAt(i);\\n\\n    if (\\':\\' != chr) {\\n      length += chr;\\n    } else {\\n      if (\\'\\' == length || (length != (n = Number(length)))) {\\n        // parser error - ignoring payload\\n        return callback(err, 0, 1);\\n      }\\n\\n      msg = data.substr(i + 1, n);\\n\\n      if (length != msg.length) {\\n        // parser error - ignoring payload\\n        return callback(err, 0, 1);\\n      }\\n\\n      if (msg.length) {\\n        packet = exports.decodePacket(msg, binaryType, true);\\n\\n        if (err.type == packet.type && err.data == packet.data) {\\n          // parser error in individual packet - ignoring payload\\n          return callback(err, 0, 1);\\n        }\\n\\n        var ret = callback(packet, i + n, l);\\n        if (false === ret) return;\\n      }\\n\\n      // advance cursor\\n      i += n;\\n      length = \\'\\';\\n    }\\n  }\\n\\n  if (length != \\'\\') {\\n    // parser error - ignoring payload\\n    return callback(err, 0, 1);\\n  }\\n\\n};\\n\\n/**\\n * Encodes multiple messages (payload) as binary.\\n *\\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\\n * 255><data>\\n *\\n * Example:\\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\\n *\\n * @param {Array} packets\\n * @return {ArrayBuffer} encoded payload\\n * @api private\\n */\\n\\nexports.encodePayloadAsArrayBuffer = function(packets, callback) {\\n  if (!packets.length) {\\n    return callback(new ArrayBuffer(0));\\n  }\\n\\n  function encodeOne(packet, doneCallback) {\\n    exports.encodePacket(packet, true, true, function(data) {\\n      return doneCallback(null, data);\\n    });\\n  }\\n\\n  map(packets, encodeOne, function(err, encodedPackets) {\\n    var totalLength = encodedPackets.reduce(function(acc, p) {\\n      var len;\\n      if (typeof p === \\'string\\'){\\n        len = p.length;\\n      } else {\\n        len = p.byteLength;\\n      }\\n      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2\\n    }, 0);\\n\\n    var resultArray = new Uint8Array(totalLength);\\n\\n    var bufferIndex = 0;\\n    encodedPackets.forEach(function(p) {\\n      var isString = typeof p === \\'string\\';\\n      var ab = p;\\n      if (isString) {\\n        var view = new Uint8Array(p.length);\\n        for (var i = 0; i < p.length; i++) {\\n          view[i] = p.charCodeAt(i);\\n        }\\n        ab = view.buffer;\\n      }\\n\\n      if (isString) { // not true binary\\n        resultArray[bufferIndex++] = 0;\\n      } else { // true binary\\n        resultArray[bufferIndex++] = 1;\\n      }\\n\\n      var lenStr = ab.byteLength.toString();\\n      for (var i = 0; i < lenStr.length; i++) {\\n        resultArray[bufferIndex++] = parseInt(lenStr[i]);\\n      }\\n      resultArray[bufferIndex++] = 255;\\n\\n      var view = new Uint8Array(ab);\\n      for (var i = 0; i < view.length; i++) {\\n        resultArray[bufferIndex++] = view[i];\\n      }\\n    });\\n\\n    return callback(resultArray.buffer);\\n  });\\n};\\n\\n/**\\n * Encode as Blob\\n */\\n\\nexports.encodePayloadAsBlob = function(packets, callback) {\\n  function encodeOne(packet, doneCallback) {\\n    exports.encodePacket(packet, true, true, function(encoded) {\\n      var binaryIdentifier = new Uint8Array(1);\\n      binaryIdentifier[0] = 1;\\n      if (typeof encoded === \\'string\\') {\\n        var view = new Uint8Array(encoded.length);\\n        for (var i = 0; i < encoded.length; i++) {\\n          view[i] = encoded.charCodeAt(i);\\n        }\\n        encoded = view.buffer;\\n        binaryIdentifier[0] = 0;\\n      }\\n\\n      var len = (encoded instanceof ArrayBuffer)\\n        ? encoded.byteLength\\n        : encoded.size;\\n\\n      var lenStr = len.toString();\\n      var lengthAry = new Uint8Array(lenStr.length + 1);\\n      for (var i = 0; i < lenStr.length; i++) {\\n        lengthAry[i] = parseInt(lenStr[i]);\\n      }\\n      lengthAry[lenStr.length] = 255;\\n\\n      if (Blob) {\\n        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);\\n        doneCallback(null, blob);\\n      }\\n    });\\n  }\\n\\n  map(packets, encodeOne, function(err, results) {\\n    return callback(new Blob(results));\\n  });\\n};\\n\\n/*\\n * Decodes data when a payload is maybe expected. Strings are decoded by\\n * interpreting each byte as a key code for entries marked to start with 0. See\\n * description of encodePayloadAsBinary\\n *\\n * @param {ArrayBuffer} data, callback method\\n * @api public\\n */\\n\\nexports.decodePayloadAsBinary = function (data, binaryType, callback) {\\n  if (typeof binaryType === \\'function\\') {\\n    callback = binaryType;\\n    binaryType = null;\\n  }\\n\\n  var bufferTail = data;\\n  var buffers = [];\\n\\n  var numberTooLong = false;\\n  while (bufferTail.byteLength > 0) {\\n    var tailArray = new Uint8Array(bufferTail);\\n    var isString = tailArray[0] === 0;\\n    var msgLength = \\'\\';\\n\\n    for (var i = 1; ; i++) {\\n      if (tailArray[i] == 255) break;\\n\\n      if (msgLength.length > 310) {\\n        numberTooLong = true;\\n        break;\\n      }\\n\\n      msgLength += tailArray[i];\\n    }\\n\\n    if(numberTooLong) return callback(err, 0, 1);\\n\\n    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);\\n    msgLength = parseInt(msgLength);\\n\\n    var msg = sliceBuffer(bufferTail, 0, msgLength);\\n    if (isString) {\\n      try {\\n        msg = String.fromCharCode.apply(null, new Uint8Array(msg));\\n      } catch (e) {\\n        // iPhone Safari doesn\\'t let you apply to typed arrays\\n        var typed = new Uint8Array(msg);\\n        msg = \\'\\';\\n        for (var i = 0; i < typed.length; i++) {\\n          msg += String.fromCharCode(typed[i]);\\n        }\\n      }\\n    }\\n\\n    buffers.push(msg);\\n    bufferTail = sliceBuffer(bufferTail, msgLength);\\n  }\\n\\n  var total = buffers.length;\\n  buffers.forEach(function(buffer, i) {\\n    callback(exports.decodePacket(buffer, binaryType, true), i, total);\\n  });\\n};\\n\\n}).call(this,typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./keys\\\":22,\\\"after\\\":23,\\\"arraybuffer.slice\\\":24,\\\"base64-arraybuffer\\\":25,\\\"blob\\\":26,\\\"utf8\\\":27}],22:[function(_dereq_,module,exports){\\n\\n/**\\n * Gets the keys for an object.\\n *\\n * @return {Array} keys\\n * @api private\\n */\\n\\nmodule.exports = Object.keys || function keys (obj){\\n  var arr = [];\\n  var has = Object.prototype.hasOwnProperty;\\n\\n  for (var i in obj) {\\n    if (has.call(obj, i)) {\\n      arr.push(i);\\n    }\\n  }\\n  return arr;\\n};\\n\\n},{}],23:[function(_dereq_,module,exports){\\nmodule.exports = after\\n\\nfunction after(count, callback, err_cb) {\\n    var bail = false\\n    err_cb = err_cb || noop\\n    proxy.count = count\\n\\n    return (count === 0) ? callback() : proxy\\n\\n    function proxy(err, result) {\\n        if (proxy.count <= 0) {\\n            throw new Error(\\'after called too many times\\')\\n        }\\n        --proxy.count\\n\\n        // after first error, rest are passed to err_cb\\n        if (err) {\\n            bail = true\\n            callback(err)\\n            // future error callbacks will go to error handler\\n            callback = err_cb\\n        } else if (proxy.count === 0 && !bail) {\\n            callback(null, result)\\n        }\\n    }\\n}\\n\\nfunction noop() {}\\n\\n},{}],24:[function(_dereq_,module,exports){\\n/**\\n * An abstraction for slicing an arraybuffer even when\\n * ArrayBuffer.prototype.slice is not supported\\n *\\n * @api public\\n */\\n\\nmodule.exports = function(arraybuffer, start, end) {\\n  var bytes = arraybuffer.byteLength;\\n  start = start || 0;\\n  end = end || bytes;\\n\\n  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }\\n\\n  if (start < 0) { start += bytes; }\\n  if (end < 0) { end += bytes; }\\n  if (end > bytes) { end = bytes; }\\n\\n  if (start >= bytes || start >= end || bytes === 0) {\\n    return new ArrayBuffer(0);\\n  }\\n\\n  var abv = new Uint8Array(arraybuffer);\\n  var result = new Uint8Array(end - start);\\n  for (var i = start, ii = 0; i < end; i++, ii++) {\\n    result[ii] = abv[i];\\n  }\\n  return result.buffer;\\n};\\n\\n},{}],25:[function(_dereq_,module,exports){\\n/*\\n * base64-arraybuffer\\n * https://github.com/niklasvh/base64-arraybuffer\\n *\\n * Copyright (c) 2012 Niklas von Hertzen\\n * Licensed under the MIT license.\\n */\\n(function(chars){\\n  \\\"use strict\\\";\\n\\n  exports.encode = function(arraybuffer) {\\n    var bytes = new Uint8Array(arraybuffer),\\n    i, len = bytes.length, base64 = \\\"\\\";\\n\\n    for (i = 0; i < len; i+=3) {\\n      base64 += chars[bytes[i] >> 2];\\n      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\\n      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\\n      base64 += chars[bytes[i + 2] & 63];\\n    }\\n\\n    if ((len % 3) === 2) {\\n      base64 = base64.substring(0, base64.length - 1) + \\\"=\\\";\\n    } else if (len % 3 === 1) {\\n      base64 = base64.substring(0, base64.length - 2) + \\\"==\\\";\\n    }\\n\\n    return base64;\\n  };\\n\\n  exports.decode =  function(base64) {\\n    var bufferLength = base64.length * 0.75,\\n    len = base64.length, i, p = 0,\\n    encoded1, encoded2, encoded3, encoded4;\\n\\n    if (base64[base64.length - 1] === \\\"=\\\") {\\n      bufferLength--;\\n      if (base64[base64.length - 2] === \\\"=\\\") {\\n        bufferLength--;\\n      }\\n    }\\n\\n    var arraybuffer = new ArrayBuffer(bufferLength),\\n    bytes = new Uint8Array(arraybuffer);\\n\\n    for (i = 0; i < len; i+=4) {\\n      encoded1 = chars.indexOf(base64[i]);\\n      encoded2 = chars.indexOf(base64[i+1]);\\n      encoded3 = chars.indexOf(base64[i+2]);\\n      encoded4 = chars.indexOf(base64[i+3]);\\n\\n      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\\n      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\\n      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\\n    }\\n\\n    return arraybuffer;\\n  };\\n})(\\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\");\\n\\n},{}],26:[function(_dereq_,module,exports){\\n(function (global){\\n/**\\n * Create a blob builder even when vendor prefixes exist\\n */\\n\\nvar BlobBuilder = global.BlobBuilder\\n  || global.WebKitBlobBuilder\\n  || global.MSBlobBuilder\\n  || global.MozBlobBuilder;\\n\\n/**\\n * Check if Blob constructor is supported\\n */\\n\\nvar blobSupported = (function() {\\n  try {\\n    var b = new Blob([\\'hi\\']);\\n    return b.size == 2;\\n  } catch(e) {\\n    return false;\\n  }\\n})();\\n\\n/**\\n * Check if BlobBuilder is supported\\n */\\n\\nvar blobBuilderSupported = BlobBuilder\\n  && BlobBuilder.prototype.append\\n  && BlobBuilder.prototype.getBlob;\\n\\nfunction BlobBuilderConstructor(ary, options) {\\n  options = options || {};\\n\\n  var bb = new BlobBuilder();\\n  for (var i = 0; i < ary.length; i++) {\\n    bb.append(ary[i]);\\n  }\\n  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();\\n};\\n\\nmodule.exports = (function() {\\n  if (blobSupported) {\\n    return global.Blob;\\n  } else if (blobBuilderSupported) {\\n    return BlobBuilderConstructor;\\n  } else {\\n    return undefined;\\n  }\\n})();\\n\\n}).call(this,typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{}],27:[function(_dereq_,module,exports){\\n(function (global){\\n/*! http://mths.be/utf8js v2.0.0 by @mathias */\\n;(function(root) {\\n\\n    // Detect free variables `exports`\\n    var freeExports = typeof exports == \\'object\\' && exports;\\n\\n    // Detect free variable `module`\\n    var freeModule = typeof module == \\'object\\' && module &&\\n        module.exports == freeExports && module;\\n\\n    // Detect free variable `global`, from Node.js or Browserified code,\\n    // and use it as `root`\\n    var freeGlobal = typeof global == \\'object\\' && global;\\n    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\\n        root = freeGlobal;\\n    }\\n\\n    /*--------------------------------------------------------------------------*/\\n\\n    var stringFromCharCode = String.fromCharCode;\\n\\n    // Taken from http://mths.be/punycode\\n    function ucs2decode(string) {\\n        var output = [];\\n        var counter = 0;\\n        var length = string.length;\\n        var value;\\n        var extra;\\n        while (counter < length) {\\n            value = string.charCodeAt(counter++);\\n            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\\n                // high surrogate, and there is a next character\\n                extra = string.charCodeAt(counter++);\\n                if ((extra & 0xFC00) == 0xDC00) { // low surrogate\\n                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\\n                } else {\\n                    // unmatched surrogate; only append this code unit, in case the next\\n                    // code unit is the high surrogate of a surrogate pair\\n                    output.push(value);\\n                    counter--;\\n                }\\n            } else {\\n                output.push(value);\\n            }\\n        }\\n        return output;\\n    }\\n\\n    // Taken from http://mths.be/punycode\\n    function ucs2encode(array) {\\n        var length = array.length;\\n        var index = -1;\\n        var value;\\n        var output = \\'\\';\\n        while (++index < length) {\\n            value = array[index];\\n            if (value > 0xFFFF) {\\n                value -= 0x10000;\\n                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\\n                value = 0xDC00 | value & 0x3FF;\\n            }\\n            output += stringFromCharCode(value);\\n        }\\n        return output;\\n    }\\n\\n    /*--------------------------------------------------------------------------*/\\n\\n    function createByte(codePoint, shift) {\\n        return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);\\n    }\\n\\n    function encodeCodePoint(codePoint) {\\n        if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence\\n            return stringFromCharCode(codePoint);\\n        }\\n        var symbol = \\'\\';\\n        if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence\\n            symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);\\n        }\\n        else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence\\n            symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);\\n            symbol += createByte(codePoint, 6);\\n        }\\n        else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence\\n            symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);\\n            symbol += createByte(codePoint, 12);\\n            symbol += createByte(codePoint, 6);\\n        }\\n        symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);\\n        return symbol;\\n    }\\n\\n    function utf8encode(string) {\\n        var codePoints = ucs2decode(string);\\n\\n        // console.log(JSON.stringify(codePoints.map(function(x) {\\n        //     return \\'U+\\' + x.toString(16).toUpperCase();\\n        // })));\\n\\n        var length = codePoints.length;\\n        var index = -1;\\n        var codePoint;\\n        var byteString = \\'\\';\\n        while (++index < length) {\\n            codePoint = codePoints[index];\\n            byteString += encodeCodePoint(codePoint);\\n        }\\n        return byteString;\\n    }\\n\\n    /*--------------------------------------------------------------------------*/\\n\\n    function readContinuationByte() {\\n        if (byteIndex >= byteCount) {\\n            throw Error(\\'Invalid byte index\\');\\n        }\\n\\n        var continuationByte = byteArray[byteIndex] & 0xFF;\\n        byteIndex++;\\n\\n        if ((continuationByte & 0xC0) == 0x80) {\\n            return continuationByte & 0x3F;\\n        }\\n\\n        // If we end up here, its not a continuation byte\\n        throw Error(\\'Invalid continuation byte\\');\\n    }\\n\\n    function decodeSymbol() {\\n        var byte1;\\n        var byte2;\\n        var byte3;\\n        var byte4;\\n        var codePoint;\\n\\n        if (byteIndex > byteCount) {\\n            throw Error(\\'Invalid byte index\\');\\n        }\\n\\n        if (byteIndex == byteCount) {\\n            return false;\\n        }\\n\\n        // Read first byte\\n        byte1 = byteArray[byteIndex] & 0xFF;\\n        byteIndex++;\\n\\n        // 1-byte sequence (no continuation bytes)\\n        if ((byte1 & 0x80) == 0) {\\n            return byte1;\\n        }\\n\\n        // 2-byte sequence\\n        if ((byte1 & 0xE0) == 0xC0) {\\n            var byte2 = readContinuationByte();\\n            codePoint = ((byte1 & 0x1F) << 6) | byte2;\\n            if (codePoint >= 0x80) {\\n                return codePoint;\\n            } else {\\n                throw Error(\\'Invalid continuation byte\\');\\n            }\\n        }\\n\\n        // 3-byte sequence (may include unpaired surrogates)\\n        if ((byte1 & 0xF0) == 0xE0) {\\n            byte2 = readContinuationByte();\\n            byte3 = readContinuationByte();\\n            codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;\\n            if (codePoint >= 0x0800) {\\n                return codePoint;\\n            } else {\\n                throw Error(\\'Invalid continuation byte\\');\\n            }\\n        }\\n\\n        // 4-byte sequence\\n        if ((byte1 & 0xF8) == 0xF0) {\\n            byte2 = readContinuationByte();\\n            byte3 = readContinuationByte();\\n            byte4 = readContinuationByte();\\n            codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |\\n                (byte3 << 0x06) | byte4;\\n            if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\\n                return codePoint;\\n            }\\n        }\\n\\n        throw Error(\\'Invalid UTF-8 detected\\');\\n    }\\n\\n    var byteArray;\\n    var byteCount;\\n    var byteIndex;\\n    function utf8decode(byteString) {\\n        byteArray = ucs2decode(byteString);\\n        byteCount = byteArray.length;\\n        byteIndex = 0;\\n        var codePoints = [];\\n        var tmp;\\n        while ((tmp = decodeSymbol()) !== false) {\\n            codePoints.push(tmp);\\n        }\\n        return ucs2encode(codePoints);\\n    }\\n\\n    /*--------------------------------------------------------------------------*/\\n\\n    var utf8 = {\\n        \\'version\\': \\'2.0.0\\',\\n        \\'encode\\': utf8encode,\\n        \\'decode\\': utf8decode\\n    };\\n\\n    // Some AMD build optimizers, like r.js, check for specific condition patterns\\n    // like the following:\\n    if (\\n        typeof define == \\'function\\' &&\\n        typeof define.amd == \\'object\\' &&\\n        define.amd\\n    ) {\\n        define(function() {\\n            return utf8;\\n        });\\n    }    else if (freeExports && !freeExports.nodeType) {\\n        if (freeModule) { // in Node.js or RingoJS v0.8.0+\\n            freeModule.exports = utf8;\\n        } else { // in Narwhal or RingoJS v0.7.0-\\n            var object = {};\\n            var hasOwnProperty = object.hasOwnProperty;\\n            for (var key in utf8) {\\n                hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);\\n            }\\n        }\\n    } else { // in Rhino or a web browser\\n        root.utf8 = utf8;\\n    }\\n\\n}(this));\\n\\n}).call(this,typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{}],28:[function(_dereq_,module,exports){\\n(function (global){\\n/**\\n * JSON parse.\\n *\\n * @see Based on jQuery#parseJSON (MIT) and JSON2\\n * @api private\\n */\\n\\nvar rvalidchars = /^[\\\\],:{}\\\\s]*$/;\\nvar rvalidescape = /\\\\\\\\(?:[\\\"\\\\\\\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;\\nvar rvalidtokens = /\\\"[^\\\"\\\\\\\\\\\\n\\\\r]*\\\"|true|false|null|-?\\\\d+(?:\\\\.\\\\d*)?(?:[eE][+\\\\-]?\\\\d+)?/g;\\nvar rvalidbraces = /(?:^|:|,)(?:\\\\s*\\\\[)+/g;\\nvar rtrimLeft = /^\\\\s+/;\\nvar rtrimRight = /\\\\s+$/;\\n\\nmodule.exports = function parsejson(data) {\\n  if (\\'string\\' != typeof data || !data) {\\n    return null;\\n  }\\n\\n  data = data.replace(rtrimLeft, \\'\\').replace(rtrimRight, \\'\\');\\n\\n  // Attempt to parse using the native JSON parser first\\n  if (global.JSON && JSON.parse) {\\n    return JSON.parse(data);\\n  }\\n\\n  if (rvalidchars.test(data.replace(rvalidescape, \\'@\\')\\n      .replace(rvalidtokens, \\']\\')\\n      .replace(rvalidbraces, \\'\\'))) {\\n    return (new Function(\\'return \\' + data))();\\n  }\\n};\\n}).call(this,typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{}],29:[function(_dereq_,module,exports){\\n/**\\n * Compiles a querystring\\n * Returns string representation of the object\\n *\\n * @param {Object}\\n * @api private\\n */\\n\\nexports.encode = function (obj) {\\n  var str = \\'\\';\\n\\n  for (var i in obj) {\\n    if (obj.hasOwnProperty(i)) {\\n      if (str.length) str += \\'&\\';\\n      str += encodeURIComponent(i) + \\'=\\' + encodeURIComponent(obj[i]);\\n    }\\n  }\\n\\n  return str;\\n};\\n\\n/**\\n * Parses a simple querystring into an object\\n *\\n * @param {String} qs\\n * @api private\\n */\\n\\nexports.decode = function(qs){\\n  var qry = {};\\n  var pairs = qs.split(\\'&\\');\\n  for (var i = 0, l = pairs.length; i < l; i++) {\\n    var pair = pairs[i].split(\\'=\\');\\n    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\\n  }\\n  return qry;\\n};\\n\\n},{}],30:[function(_dereq_,module,exports){\\n/**\\n * Parses an URI\\n *\\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\\n * @api private\\n */\\n\\nvar re = /^(?:(?![^:@]+:[^:@\\\\/]*@)(http|https|ws|wss):\\\\/\\\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\\\/?#]*)(?::(\\\\d*))?)(((\\\\/(?:[^?#](?![^?#\\\\/]*\\\\.[^?#\\\\/.]+(?:[?#]|$)))*\\\\/?)?([^?#\\\\/]*))(?:\\\\?([^#]*))?(?:#(.*))?)/;\\n\\nvar parts = [\\n    \\'source\\', \\'protocol\\', \\'authority\\', \\'userInfo\\', \\'user\\', \\'password\\', \\'host\\', \\'port\\', \\'relative\\', \\'path\\', \\'directory\\', \\'file\\', \\'query\\', \\'anchor\\'\\n];\\n\\nmodule.exports = function parseuri(str) {\\n    var src = str,\\n        b = str.indexOf(\\'[\\'),\\n        e = str.indexOf(\\']\\');\\n\\n    if (b != -1 && e != -1) {\\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, \\';\\') + str.substring(e, str.length);\\n    }\\n\\n    var m = re.exec(str || \\'\\'),\\n        uri = {},\\n        i = 14;\\n\\n    while (i--) {\\n        uri[parts[i]] = m[i] || \\'\\';\\n    }\\n\\n    if (b != -1 && e != -1) {\\n        uri.source = src;\\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, \\':\\');\\n        uri.authority = uri.authority.replace(\\'[\\', \\'\\').replace(\\']\\', \\'\\').replace(/;/g, \\':\\');\\n        uri.ipv6uri = true;\\n    }\\n\\n    return uri;\\n};\\n\\n},{}],31:[function(_dereq_,module,exports){\\n\\n/**\\n * Module dependencies.\\n */\\n\\nvar global = (function() { return this; })();\\n\\n/**\\n * WebSocket constructor.\\n */\\n\\nvar WebSocket = global.WebSocket || global.MozWebSocket;\\n\\n/**\\n * Module exports.\\n */\\n\\nmodule.exports = WebSocket ? ws : null;\\n\\n/**\\n * WebSocket constructor.\\n *\\n * The third `opts` options object gets ignored in web browsers, since it\\'s\\n * non-standard, and throws a TypeError if passed to the constructor.\\n * See: https://github.com/einaros/ws/issues/227\\n *\\n * @param {String} uri\\n * @param {Array} protocols (optional)\\n * @param {Object) opts (optional)\\n * @api public\\n */\\n\\nfunction ws(uri, protocols, opts) {\\n  var instance;\\n  if (protocols) {\\n    instance = new WebSocket(uri, protocols);\\n  } else {\\n    instance = new WebSocket(uri);\\n  }\\n  return instance;\\n}\\n\\nif (WebSocket) ws.prototype = WebSocket.prototype;\\n\\n},{}],32:[function(_dereq_,module,exports){\\n(function (global){\\n\\n/*\\n * Module requirements.\\n */\\n\\nvar isArray = _dereq_(\\'isarray\\');\\n\\n/**\\n * Module exports.\\n */\\n\\nmodule.exports = hasBinary;\\n\\n/**\\n * Checks for binary data.\\n *\\n * Right now only Buffer and ArrayBuffer are supported..\\n *\\n * @param {Object} anything\\n * @api public\\n */\\n\\nfunction hasBinary(data) {\\n\\n  function _hasBinary(obj) {\\n    if (!obj) return false;\\n\\n    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||\\n         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||\\n         (global.Blob && obj instanceof Blob) ||\\n         (global.File && obj instanceof File)\\n        ) {\\n      return true;\\n    }\\n\\n    if (isArray(obj)) {\\n      for (var i = 0; i < obj.length; i++) {\\n          if (_hasBinary(obj[i])) {\\n              return true;\\n          }\\n      }\\n    } else if (obj && \\'object\\' == typeof obj) {\\n      if (obj.toJSON) {\\n        obj = obj.toJSON();\\n      }\\n\\n      for (var key in obj) {\\n        if (obj.hasOwnProperty(key) && _hasBinary(obj[key])) {\\n          return true;\\n        }\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  return _hasBinary(data);\\n}\\n\\n}).call(this,typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"isarray\\\":33}],33:[function(_dereq_,module,exports){\\nmodule.exports = Array.isArray || function (arr) {\\n  return Object.prototype.toString.call(arr) == \\'[object Array]\\';\\n};\\n\\n},{}],34:[function(_dereq_,module,exports){\\n\\n/**\\n * Module dependencies.\\n */\\n\\nvar global = _dereq_(\\'global\\');\\n\\n/**\\n * Module exports.\\n *\\n * Logic borrowed from Modernizr:\\n *\\n *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js\\n */\\n\\ntry {\\n  module.exports = \\'XMLHttpRequest\\' in global &&\\n    \\'withCredentials\\' in new global.XMLHttpRequest();\\n} catch (err) {\\n  // if XMLHttp support is disabled in IE then it will throw\\n  // when trying to create\\n  module.exports = false;\\n}\\n\\n},{\\\"global\\\":35}],35:[function(_dereq_,module,exports){\\n\\n/**\\n * Returns `this`. Execute this without a \\\"context\\\" (i.e. without it being\\n * attached to an object of the left-hand side), and `this` points to the\\n * \\\"global\\\" scope of the current JS execution.\\n */\\n\\nmodule.exports = (function () { return this; })();\\n\\n},{}],36:[function(_dereq_,module,exports){\\n\\nvar indexOf = [].indexOf;\\n\\nmodule.exports = function(arr, obj){\\n  if (indexOf) return arr.indexOf(obj);\\n  for (var i = 0; i < arr.length; ++i) {\\n    if (arr[i] === obj) return i;\\n  }\\n  return -1;\\n};\\n},{}],37:[function(_dereq_,module,exports){\\n\\n/**\\n * HOP ref.\\n */\\n\\nvar has = Object.prototype.hasOwnProperty;\\n\\n/**\\n * Return own keys in `obj`.\\n *\\n * @param {Object} obj\\n * @return {Array}\\n * @api public\\n */\\n\\nexports.keys = Object.keys || function(obj){\\n  var keys = [];\\n  for (var key in obj) {\\n    if (has.call(obj, key)) {\\n      keys.push(key);\\n    }\\n  }\\n  return keys;\\n};\\n\\n/**\\n * Return own values in `obj`.\\n *\\n * @param {Object} obj\\n * @return {Array}\\n * @api public\\n */\\n\\nexports.values = function(obj){\\n  var vals = [];\\n  for (var key in obj) {\\n    if (has.call(obj, key)) {\\n      vals.push(obj[key]);\\n    }\\n  }\\n  return vals;\\n};\\n\\n/**\\n * Merge `b` into `a`.\\n *\\n * @param {Object} a\\n * @param {Object} b\\n * @return {Object} a\\n * @api public\\n */\\n\\nexports.merge = function(a, b){\\n  for (var key in b) {\\n    if (has.call(b, key)) {\\n      a[key] = b[key];\\n    }\\n  }\\n  return a;\\n};\\n\\n/**\\n * Return length of `obj`.\\n *\\n * @param {Object} obj\\n * @return {Number}\\n * @api public\\n */\\n\\nexports.length = function(obj){\\n  return exports.keys(obj).length;\\n};\\n\\n/**\\n * Check if `obj` is empty.\\n *\\n * @param {Object} obj\\n * @return {Boolean}\\n * @api public\\n */\\n\\nexports.isEmpty = function(obj){\\n  return 0 == exports.length(obj);\\n};\\n},{}],38:[function(_dereq_,module,exports){\\n/**\\n * Parses an URI\\n *\\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\\n * @api private\\n */\\n\\nvar re = /^(?:(?![^:@]+:[^:@\\\\/]*@)(http|https|ws|wss):\\\\/\\\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\\\/?#]*)(?::(\\\\d*))?)(((\\\\/(?:[^?#](?![^?#\\\\/]*\\\\.[^?#\\\\/.]+(?:[?#]|$)))*\\\\/?)?([^?#\\\\/]*))(?:\\\\?([^#]*))?(?:#(.*))?)/;\\n\\nvar parts = [\\n    \\'source\\', \\'protocol\\', \\'authority\\', \\'userInfo\\', \\'user\\', \\'password\\', \\'host\\'\\n  , \\'port\\', \\'relative\\', \\'path\\', \\'directory\\', \\'file\\', \\'query\\', \\'anchor\\'\\n];\\n\\nmodule.exports = function parseuri(str) {\\n  var m = re.exec(str || \\'\\')\\n    , uri = {}\\n    , i = 14;\\n\\n  while (i--) {\\n    uri[parts[i]] = m[i] || \\'\\';\\n  }\\n\\n  return uri;\\n};\\n\\n},{}],39:[function(_dereq_,module,exports){\\n(function (global){\\n/*global Blob,File*/\\n\\n/**\\n * Module requirements\\n */\\n\\nvar isArray = _dereq_(\\'isarray\\');\\nvar isBuf = _dereq_(\\'./is-buffer\\');\\n\\n/**\\n * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.\\n * Anything with blobs or files should be fed through removeBlobs before coming\\n * here.\\n *\\n * @param {Object} packet - socket.io event packet\\n * @return {Object} with deconstructed packet and list of buffers\\n * @api public\\n */\\n\\nexports.deconstructPacket = function(packet){\\n  var buffers = [];\\n  var packetData = packet.data;\\n\\n  function _deconstructPacket(data) {\\n    if (!data) return data;\\n\\n    if (isBuf(data)) {\\n      var placeholder = { _placeholder: true, num: buffers.length };\\n      buffers.push(data);\\n      return placeholder;\\n    } else if (isArray(data)) {\\n      var newData = new Array(data.length);\\n      for (var i = 0; i < data.length; i++) {\\n        newData[i] = _deconstructPacket(data[i]);\\n      }\\n      return newData;\\n    } else if (\\'object\\' == typeof data && !(data instanceof Date)) {\\n      var newData = {};\\n      for (var key in data) {\\n        newData[key] = _deconstructPacket(data[key]);\\n      }\\n      return newData;\\n    }\\n    return data;\\n  }\\n\\n  var pack = packet;\\n  pack.data = _deconstructPacket(packetData);\\n  pack.attachments = buffers.length; // number of binary \\'attachments\\'\\n  return {packet: pack, buffers: buffers};\\n};\\n\\n/**\\n * Reconstructs a binary packet from its placeholder packet and buffers\\n *\\n * @param {Object} packet - event packet with placeholders\\n * @param {Array} buffers - binary buffers to put in placeholder positions\\n * @return {Object} reconstructed packet\\n * @api public\\n */\\n\\nexports.reconstructPacket = function(packet, buffers) {\\n  var curPlaceHolder = 0;\\n\\n  function _reconstructPacket(data) {\\n    if (data && data._placeholder) {\\n      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)\\n      return buf;\\n    } else if (isArray(data)) {\\n      for (var i = 0; i < data.length; i++) {\\n        data[i] = _reconstructPacket(data[i]);\\n      }\\n      return data;\\n    } else if (data && \\'object\\' == typeof data) {\\n      for (var key in data) {\\n        data[key] = _reconstructPacket(data[key]);\\n      }\\n      return data;\\n    }\\n    return data;\\n  }\\n\\n  packet.data = _reconstructPacket(packet.data);\\n  packet.attachments = undefined; // no longer useful\\n  return packet;\\n};\\n\\n/**\\n * Asynchronously removes Blobs or Files from data via\\n * FileReader\\'s readAsArrayBuffer method. Used before encoding\\n * data as msgpack. Calls callback with the blobless data.\\n *\\n * @param {Object} data\\n * @param {Function} callback\\n * @api private\\n */\\n\\nexports.removeBlobs = function(data, callback) {\\n  function _removeBlobs(obj, curKey, containingObject) {\\n    if (!obj) return obj;\\n\\n    // convert any blob\\n    if ((global.Blob && obj instanceof Blob) ||\\n        (global.File && obj instanceof File)) {\\n      pendingBlobs++;\\n\\n      // async filereader\\n      var fileReader = new FileReader();\\n      fileReader.onload = function() { // this.result == arraybuffer\\n        if (containingObject) {\\n          containingObject[curKey] = this.result;\\n        }\\n        else {\\n          bloblessData = this.result;\\n        }\\n\\n        // if nothing pending its callback time\\n        if(! --pendingBlobs) {\\n          callback(bloblessData);\\n        }\\n      };\\n\\n      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer\\n    } else if (isArray(obj)) { // handle array\\n      for (var i = 0; i < obj.length; i++) {\\n        _removeBlobs(obj[i], i, obj);\\n      }\\n    } else if (obj && \\'object\\' == typeof obj && !isBuf(obj)) { // and object\\n      for (var key in obj) {\\n        _removeBlobs(obj[key], key, obj);\\n      }\\n    }\\n  }\\n\\n  var pendingBlobs = 0;\\n  var bloblessData = data;\\n  _removeBlobs(bloblessData);\\n  if (!pendingBlobs) {\\n    callback(bloblessData);\\n  }\\n};\\n\\n}).call(this,typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./is-buffer\\\":41,\\\"isarray\\\":42}],40:[function(_dereq_,module,exports){\\n\\n/**\\n * Module dependencies.\\n */\\n\\nvar debug = _dereq_(\\'debug\\')(\\'socket.io-parser\\');\\nvar json = _dereq_(\\'json3\\');\\nvar isArray = _dereq_(\\'isarray\\');\\nvar Emitter = _dereq_(\\'component-emitter\\');\\nvar binary = _dereq_(\\'./binary\\');\\nvar isBuf = _dereq_(\\'./is-buffer\\');\\n\\n/**\\n * Protocol version.\\n *\\n * @api public\\n */\\n\\nexports.protocol = 4;\\n\\n/**\\n * Packet types.\\n *\\n * @api public\\n */\\n\\nexports.types = [\\n  \\'CONNECT\\',\\n  \\'DISCONNECT\\',\\n  \\'EVENT\\',\\n  \\'BINARY_EVENT\\',\\n  \\'ACK\\',\\n  \\'BINARY_ACK\\',\\n  \\'ERROR\\'\\n];\\n\\n/**\\n * Packet type `connect`.\\n *\\n * @api public\\n */\\n\\nexports.CONNECT = 0;\\n\\n/**\\n * Packet type `disconnect`.\\n *\\n * @api public\\n */\\n\\nexports.DISCONNECT = 1;\\n\\n/**\\n * Packet type `event`.\\n *\\n * @api public\\n */\\n\\nexports.EVENT = 2;\\n\\n/**\\n * Packet type `ack`.\\n *\\n * @api public\\n */\\n\\nexports.ACK = 3;\\n\\n/**\\n * Packet type `error`.\\n *\\n * @api public\\n */\\n\\nexports.ERROR = 4;\\n\\n/**\\n * Packet type \\'binary event\\'\\n *\\n * @api public\\n */\\n\\nexports.BINARY_EVENT = 5;\\n\\n/**\\n * Packet type `binary ack`. For acks with binary arguments.\\n *\\n * @api public\\n */\\n\\nexports.BINARY_ACK = 6;\\n\\n/**\\n * Encoder constructor.\\n *\\n * @api public\\n */\\n\\nexports.Encoder = Encoder;\\n\\n/**\\n * Decoder constructor.\\n *\\n * @api public\\n */\\n\\nexports.Decoder = Decoder;\\n\\n/**\\n * A socket.io Encoder instance\\n *\\n * @api public\\n */\\n\\nfunction Encoder() {}\\n\\n/**\\n * Encode a packet as a single string if non-binary, or as a\\n * buffer sequence, depending on packet type.\\n *\\n * @param {Object} obj - packet object\\n * @param {Function} callback - function to handle encodings (likely engine.write)\\n * @return Calls callback with Array of encodings\\n * @api public\\n */\\n\\nEncoder.prototype.encode = function(obj, callback){\\n  debug(\\'encoding packet %j\\', obj);\\n\\n  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {\\n    encodeAsBinary(obj, callback);\\n  }\\n  else {\\n    var encoding = encodeAsString(obj);\\n    callback([encoding]);\\n  }\\n};\\n\\n/**\\n * Encode packet as string.\\n *\\n * @param {Object} packet\\n * @return {String} encoded\\n * @api private\\n */\\n\\nfunction encodeAsString(obj) {\\n  var str = \\'\\';\\n  var nsp = false;\\n\\n  // first is type\\n  str += obj.type;\\n\\n  // attachments if we have them\\n  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {\\n    str += obj.attachments;\\n    str += \\'-\\';\\n  }\\n\\n  // if we have a namespace other than `/`\\n  // we append it followed by a comma `,`\\n  if (obj.nsp && \\'/\\' != obj.nsp) {\\n    nsp = true;\\n    str += obj.nsp;\\n  }\\n\\n  // immediately followed by the id\\n  if (null != obj.id) {\\n    if (nsp) {\\n      str += \\',\\';\\n      nsp = false;\\n    }\\n    str += obj.id;\\n  }\\n\\n  // json data\\n  if (null != obj.data) {\\n    if (nsp) str += \\',\\';\\n    str += json.stringify(obj.data);\\n  }\\n\\n  debug(\\'encoded %j as %s\\', obj, str);\\n  return str;\\n}\\n\\n/**\\n * Encode packet as \\'buffer sequence\\' by removing blobs, and\\n * deconstructing packet into object with placeholders and\\n * a list of buffers.\\n *\\n * @param {Object} packet\\n * @return {Buffer} encoded\\n * @api private\\n */\\n\\nfunction encodeAsBinary(obj, callback) {\\n\\n  function writeEncoding(bloblessData) {\\n    var deconstruction = binary.deconstructPacket(bloblessData);\\n    var pack = encodeAsString(deconstruction.packet);\\n    var buffers = deconstruction.buffers;\\n\\n    buffers.unshift(pack); // add packet info to beginning of data list\\n    callback(buffers); // write all the buffers\\n  }\\n\\n  binary.removeBlobs(obj, writeEncoding);\\n}\\n\\n/**\\n * A socket.io Decoder instance\\n *\\n * @return {Object} decoder\\n * @api public\\n */\\n\\nfunction Decoder() {\\n  this.reconstructor = null;\\n}\\n\\n/**\\n * Mix in `Emitter` with Decoder.\\n */\\n\\nEmitter(Decoder.prototype);\\n\\n/**\\n * Decodes an ecoded packet string into packet JSON.\\n *\\n * @param {String} obj - encoded packet\\n * @return {Object} packet\\n * @api public\\n */\\n\\nDecoder.prototype.add = function(obj) {\\n  var packet;\\n  if (\\'string\\' == typeof obj) {\\n    packet = decodeString(obj);\\n    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet\\'s json\\n      this.reconstructor = new BinaryReconstructor(packet);\\n\\n      // no attachments, labeled binary but no binary data to follow\\n      if (this.reconstructor.reconPack.attachments == 0) {\\n        this.emit(\\'decoded\\', packet);\\n      }\\n    } else { // non-binary full packet\\n      this.emit(\\'decoded\\', packet);\\n    }\\n  }\\n  else if (isBuf(obj) || obj.base64) { // raw binary data\\n    if (!this.reconstructor) {\\n      throw new Error(\\'got binary data when not reconstructing a packet\\');\\n    } else {\\n      packet = this.reconstructor.takeBinaryData(obj);\\n      if (packet) { // received final buffer\\n        this.reconstructor = null;\\n        this.emit(\\'decoded\\', packet);\\n      }\\n    }\\n  }\\n  else {\\n    throw new Error(\\'Unknown type: \\' + obj);\\n  }\\n};\\n\\n/**\\n * Decode a packet String (JSON data)\\n *\\n * @param {String} str\\n * @return {Object} packet\\n * @api private\\n */\\n\\nfunction decodeString(str) {\\n  var p = {};\\n  var i = 0;\\n\\n  // look up type\\n  p.type = Number(str.charAt(0));\\n  if (null == exports.types[p.type]) return error();\\n\\n  // look up attachments if type binary\\n  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {\\n    p.attachments = \\'\\';\\n    while (str.charAt(++i) != \\'-\\') {\\n      p.attachments += str.charAt(i);\\n    }\\n    p.attachments = Number(p.attachments);\\n  }\\n\\n  // look up namespace (if any)\\n  if (\\'/\\' == str.charAt(i + 1)) {\\n    p.nsp = \\'\\';\\n    while (++i) {\\n      var c = str.charAt(i);\\n      if (\\',\\' == c) break;\\n      p.nsp += c;\\n      if (i + 1 == str.length) break;\\n    }\\n  } else {\\n    p.nsp = \\'/\\';\\n  }\\n\\n  // look up id\\n  var next = str.charAt(i + 1);\\n  if (\\'\\' != next && Number(next) == next) {\\n    p.id = \\'\\';\\n    while (++i) {\\n      var c = str.charAt(i);\\n      if (null == c || Number(c) != c) {\\n        --i;\\n        break;\\n      }\\n      p.id += str.charAt(i);\\n      if (i + 1 == str.length) break;\\n    }\\n    p.id = Number(p.id);\\n  }\\n\\n  // look up json data\\n  if (str.charAt(++i)) {\\n    try {\\n      p.data = json.parse(str.substr(i));\\n    } catch(e){\\n      return error();\\n    }\\n  }\\n\\n  debug(\\'decoded %s as %j\\', str, p);\\n  return p;\\n}\\n\\n/**\\n * Deallocates a parser\\'s resources\\n *\\n * @api public\\n */\\n\\nDecoder.prototype.destroy = function() {\\n  if (this.reconstructor) {\\n    this.reconstructor.finishedReconstruction();\\n  }\\n};\\n\\n/**\\n * A manager of a binary event\\'s \\'buffer sequence\\'. Should\\n * be constructed whenever a packet of type BINARY_EVENT is\\n * decoded.\\n *\\n * @param {Object} packet\\n * @return {BinaryReconstructor} initialized reconstructor\\n * @api private\\n */\\n\\nfunction BinaryReconstructor(packet) {\\n  this.reconPack = packet;\\n  this.buffers = [];\\n}\\n\\n/**\\n * Method to be called when binary data received from connection\\n * after a BINARY_EVENT packet.\\n *\\n * @param {Buffer | ArrayBuffer} binData - the raw binary data received\\n * @return {null | Object} returns null if more binary data is expected or\\n *   a reconstructed packet object if all buffers have been received.\\n * @api private\\n */\\n\\nBinaryReconstructor.prototype.takeBinaryData = function(binData) {\\n  this.buffers.push(binData);\\n  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list\\n    var packet = binary.reconstructPacket(this.reconPack, this.buffers);\\n    this.finishedReconstruction();\\n    return packet;\\n  }\\n  return null;\\n};\\n\\n/**\\n * Cleans up binary packet reconstruction variables.\\n *\\n * @api private\\n */\\n\\nBinaryReconstructor.prototype.finishedReconstruction = function() {\\n  this.reconPack = null;\\n  this.buffers = [];\\n};\\n\\nfunction error(data){\\n  return {\\n    type: exports.ERROR,\\n    data: \\'parser error\\'\\n  };\\n}\\n\\n},{\\\"./binary\\\":39,\\\"./is-buffer\\\":41,\\\"component-emitter\\\":8,\\\"debug\\\":9,\\\"isarray\\\":42,\\\"json3\\\":43}],41:[function(_dereq_,module,exports){\\n(function (global){\\n\\nmodule.exports = isBuf;\\n\\n/**\\n * Returns true if obj is a buffer or an arraybuffer.\\n *\\n * @api private\\n */\\n\\nfunction isBuf(obj) {\\n  return (global.Buffer && global.Buffer.isBuffer(obj)) ||\\n         (global.ArrayBuffer && obj instanceof ArrayBuffer);\\n}\\n\\n}).call(this,typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{}],42:[function(_dereq_,module,exports){\\nmodule.exports=_dereq_(33)\\n},{}],43:[function(_dereq_,module,exports){\\n/*! JSON v3.2.6 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */\\n;(function (window) {\\n  // Convenience aliases.\\n  var getClass = {}.toString, isProperty, forEach, undef;\\n\\n  // Detect the `define` function exposed by asynchronous module loaders. The\\n  // strict `define` check is necessary for compatibility with `r.js`.\\n  var isLoader = typeof define === \\\"function\\\" && define.amd;\\n\\n  // Detect native implementations.\\n  var nativeJSON = typeof JSON == \\\"object\\\" && JSON;\\n\\n  // Set up the JSON 3 namespace, preferring the CommonJS `exports` object if\\n  // available.\\n  var JSON3 = typeof exports == \\\"object\\\" && exports && !exports.nodeType && exports;\\n\\n  if (JSON3 && nativeJSON) {\\n    // Explicitly delegate to the native `stringify` and `parse`\\n    // implementations in CommonJS environments.\\n    JSON3.stringify = nativeJSON.stringify;\\n    JSON3.parse = nativeJSON.parse;\\n  } else {\\n    // Export for web browsers, JavaScript engines, and asynchronous module\\n    // loaders, using the global `JSON` object if available.\\n    JSON3 = window.JSON = nativeJSON || {};\\n  }\\n\\n  // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\\n  var isExtended = new Date(-3509827334573292);\\n  try {\\n    // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\\n    // results for certain dates in Opera >= 10.53.\\n    isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&\\n      // Safari < 2.0.2 stores the internal millisecond time value correctly,\\n      // but clips the values returned by the date methods to the range of\\n      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\\n      isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\\n  } catch (exception) {}\\n\\n  // Internal: Determines whether the native `JSON.stringify` and `parse`\\n  // implementations are spec-compliant. Based on work by Ken Snyder.\\n  function has(name) {\\n    if (has[name] !== undef) {\\n      // Return cached feature test result.\\n      return has[name];\\n    }\\n\\n    var isSupported;\\n    if (name == \\\"bug-string-char-index\\\") {\\n      // IE <= 7 doesn\\'t support accessing string characters using square\\n      // bracket notation. IE 8 only supports this for primitives.\\n      isSupported = \\\"a\\\"[0] != \\\"a\\\";\\n    } else if (name == \\\"json\\\") {\\n      // Indicates whether both `JSON.stringify` and `JSON.parse` are\\n      // supported.\\n      isSupported = has(\\\"json-stringify\\\") && has(\\\"json-parse\\\");\\n    } else {\\n      var value, serialized = \\'{\\\"a\\\":[1,true,false,null,\\\"\\\\\\\\u0000\\\\\\\\b\\\\\\\\n\\\\\\\\f\\\\\\\\r\\\\\\\\t\\\"]}\\';\\n      // Test `JSON.stringify`.\\n      if (name == \\\"json-stringify\\\") {\\n        var stringify = JSON3.stringify, stringifySupported = typeof stringify == \\\"function\\\" && isExtended;\\n        if (stringifySupported) {\\n          // A test function object with a custom `toJSON` method.\\n          (value = function () {\\n            return 1;\\n          }).toJSON = value;\\n          try {\\n            stringifySupported =\\n              // Firefox 3.1b1 and b2 serialize string, number, and boolean\\n              // primitives as object literals.\\n              stringify(0) === \\\"0\\\" &&\\n              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\\n              // literals.\\n              stringify(new Number()) === \\\"0\\\" &&\\n              stringify(new String()) == \\'\\\"\\\"\\' &&\\n              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\\n              // does not define a canonical JSON representation (this applies to\\n              // objects with `toJSON` properties as well, *unless* they are nested\\n              // within an object or array).\\n              stringify(getClass) === undef &&\\n              // IE 8 serializes `undefined` as `\\\"undefined\\\"`. Safari <= 5.1.7 and\\n              // FF 3.1b3 pass this test.\\n              stringify(undef) === undef &&\\n              // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\\n              // respectively, if the value is omitted entirely.\\n              stringify() === undef &&\\n              // FF 3.1b1, 2 throw an error if the given value is not a number,\\n              // string, array, object, Boolean, or `null` literal. This applies to\\n              // objects with custom `toJSON` methods as well, unless they are nested\\n              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\\n              // methods entirely.\\n              stringify(value) === \\\"1\\\" &&\\n              stringify([value]) == \\\"[1]\\\" &&\\n              // Prototype <= 1.6.1 serializes `[undefined]` as `\\\"[]\\\"` instead of\\n              // `\\\"[null]\\\"`.\\n              stringify([undef]) == \\\"[null]\\\" &&\\n              // YUI 3.0.0b1 fails to serialize `null` literals.\\n              stringify(null) == \\\"null\\\" &&\\n              // FF 3.1b1, 2 halts serialization if an array contains a function:\\n              // `[1, true, getClass, 1]` serializes as \\\"[1,true,],\\\". FF 3.1b3\\n              // elides non-JSON values from objects and arrays, unless they\\n              // define custom `toJSON` methods.\\n              stringify([undef, getClass, null]) == \\\"[null,null,null]\\\" &&\\n              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\\n              // where character escape codes are expected (e.g., `\\\\b` => `\\\\u0008`).\\n              stringify({ \\\"a\\\": [value, true, false, null, \\\"\\\\x00\\\\b\\\\n\\\\f\\\\r\\\\t\\\"] }) == serialized &&\\n              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\\n              stringify(null, value) === \\\"1\\\" &&\\n              stringify([1, 2], null, 1) == \\\"[\\\\n 1,\\\\n 2\\\\n]\\\" &&\\n              // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\\n              // serialize extended years.\\n              stringify(new Date(-8.64e15)) == \\'\\\"-271821-04-20T00:00:00.000Z\\\"\\' &&\\n              // The milliseconds are optional in ES 5, but required in 5.1.\\n              stringify(new Date(8.64e15)) == \\'\\\"+275760-09-13T00:00:00.000Z\\\"\\' &&\\n              // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\\n              // four-digit years instead of six-digit years. Credits: @Yaffle.\\n              stringify(new Date(-621987552e5)) == \\'\\\"-000001-01-01T00:00:00.000Z\\\"\\' &&\\n              // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\\n              // values less than 1000. Credits: @Yaffle.\\n              stringify(new Date(-1)) == \\'\\\"1969-12-31T23:59:59.999Z\\\"\\';\\n          } catch (exception) {\\n            stringifySupported = false;\\n          }\\n        }\\n        isSupported = stringifySupported;\\n      }\\n      // Test `JSON.parse`.\\n      if (name == \\\"json-parse\\\") {\\n        var parse = JSON3.parse;\\n        if (typeof parse == \\\"function\\\") {\\n          try {\\n            // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\\n            // Conforming implementations should also coerce the initial argument to\\n            // a string prior to parsing.\\n            if (parse(\\\"0\\\") === 0 && !parse(false)) {\\n              // Simple parsing test.\\n              value = parse(serialized);\\n              var parseSupported = value[\\\"a\\\"].length == 5 && value[\\\"a\\\"][0] === 1;\\n              if (parseSupported) {\\n                try {\\n                  // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\\n                  parseSupported = !parse(\\'\\\"\\\\t\\\"\\');\\n                } catch (exception) {}\\n                if (parseSupported) {\\n                  try {\\n                    // FF 4.0 and 4.0.1 allow leading `+` signs and leading\\n                    // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow\\n                    // certain octal literals.\\n                    parseSupported = parse(\\\"01\\\") !== 1;\\n                  } catch (exception) {}\\n                }\\n                if (parseSupported) {\\n                  try {\\n                    // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal\\n                    // points. These environments, along with FF 3.1b1 and 2,\\n                    // also allow trailing commas in JSON objects and arrays.\\n                    parseSupported = parse(\\\"1.\\\") !== 1;\\n                  } catch (exception) {}\\n                }\\n              }\\n            }\\n          } catch (exception) {\\n            parseSupported = false;\\n          }\\n        }\\n        isSupported = parseSupported;\\n      }\\n    }\\n    return has[name] = !!isSupported;\\n  }\\n\\n  if (!has(\\\"json\\\")) {\\n    // Common `[[Class]]` name aliases.\\n    var functionClass = \\\"[object Function]\\\";\\n    var dateClass = \\\"[object Date]\\\";\\n    var numberClass = \\\"[object Number]\\\";\\n    var stringClass = \\\"[object String]\\\";\\n    var arrayClass = \\\"[object Array]\\\";\\n    var booleanClass = \\\"[object Boolean]\\\";\\n\\n    // Detect incomplete support for accessing string characters by index.\\n    var charIndexBuggy = has(\\\"bug-string-char-index\\\");\\n\\n    // Define additional utility methods if the `Date` methods are buggy.\\n    if (!isExtended) {\\n      var floor = Math.floor;\\n      // A mapping between the months of the year and the number of days between\\n      // January 1st and the first of the respective month.\\n      var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\\n      // Internal: Calculates the number of days between the Unix epoch and the\\n      // first day of the given month.\\n      var getDay = function (year, month) {\\n        return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\\n      };\\n    }\\n\\n    // Internal: Determines if a property is a direct property of the given\\n    // object. Delegates to the native `Object#hasOwnProperty` method.\\n    if (!(isProperty = {}.hasOwnProperty)) {\\n      isProperty = function (property) {\\n        var members = {}, constructor;\\n        if ((members.__proto__ = null, members.__proto__ = {\\n          // The *proto* property cannot be set multiple times in recent\\n          // versions of Firefox and SeaMonkey.\\n          \\\"toString\\\": 1\\n        }, members).toString != getClass) {\\n          // Safari <= 2.0.3 doesn\\'t implement `Object#hasOwnProperty`, but\\n          // supports the mutable *proto* property.\\n          isProperty = function (property) {\\n            // Capture and break the object\\'s prototype chain (see section 8.6.2\\n            // of the ES 5.1 spec). The parenthesized expression prevents an\\n            // unsafe transformation by the Closure Compiler.\\n            var original = this.__proto__, result = property in (this.__proto__ = null, this);\\n            // Restore the original prototype chain.\\n            this.__proto__ = original;\\n            return result;\\n          };\\n        } else {\\n          // Capture a reference to the top-level `Object` constructor.\\n          constructor = members.constructor;\\n          // Use the `constructor` property to simulate `Object#hasOwnProperty` in\\n          // other environments.\\n          isProperty = function (property) {\\n            var parent = (this.constructor || constructor).prototype;\\n            return property in this && !(property in parent && this[property] === parent[property]);\\n          };\\n        }\\n        members = null;\\n        return isProperty.call(this, property);\\n      };\\n    }\\n\\n    // Internal: A set of primitive types used by `isHostType`.\\n    var PrimitiveTypes = {\\n      \\'boolean\\': 1,\\n      \\'number\\': 1,\\n      \\'string\\': 1,\\n      \\'undefined\\': 1\\n    };\\n\\n    // Internal: Determines if the given object `property` value is a\\n    // non-primitive.\\n    var isHostType = function (object, property) {\\n      var type = typeof object[property];\\n      return type == \\'object\\' ? !!object[property] : !PrimitiveTypes[type];\\n    };\\n\\n    // Internal: Normalizes the `for...in` iteration algorithm across\\n    // environments. Each enumerated key is yielded to a `callback` function.\\n    forEach = function (object, callback) {\\n      var size = 0, Properties, members, property;\\n\\n      // Tests for bugs in the current environment\\'s `for...in` algorithm. The\\n      // `valueOf` property inherits the non-enumerable flag from\\n      // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\\n      (Properties = function () {\\n        this.valueOf = 0;\\n      }).prototype.valueOf = 0;\\n\\n      // Iterate over a new instance of the `Properties` class.\\n      members = new Properties();\\n      for (property in members) {\\n        // Ignore all properties inherited from `Object.prototype`.\\n        if (isProperty.call(members, property)) {\\n          size++;\\n        }\\n      }\\n      Properties = members = null;\\n\\n      // Normalize the iteration algorithm.\\n      if (!size) {\\n        // A list of non-enumerable properties inherited from `Object.prototype`.\\n        members = [\\\"valueOf\\\", \\\"toString\\\", \\\"toLocaleString\\\", \\\"propertyIsEnumerable\\\", \\\"isPrototypeOf\\\", \\\"hasOwnProperty\\\", \\\"constructor\\\"];\\n        // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\\n        // properties.\\n        forEach = function (object, callback) {\\n          var isFunction = getClass.call(object) == functionClass, property, length;\\n          var hasProperty = !isFunction && typeof object.constructor != \\'function\\' && isHostType(object, \\'hasOwnProperty\\') ? object.hasOwnProperty : isProperty;\\n          for (property in object) {\\n            // Gecko <= 1.0 enumerates the `prototype` property of functions under\\n            // certain conditions; IE does not.\\n            if (!(isFunction && property == \\\"prototype\\\") && hasProperty.call(object, property)) {\\n              callback(property);\\n            }\\n          }\\n          // Manually invoke the callback for each non-enumerable property.\\n          for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));\\n        };\\n      } else if (size == 2) {\\n        // Safari <= 2.0.4 enumerates shadowed properties twice.\\n        forEach = function (object, callback) {\\n          // Create a set of iterated properties.\\n          var members = {}, isFunction = getClass.call(object) == functionClass, property;\\n          for (property in object) {\\n            // Store each property name to prevent double enumeration. The\\n            // `prototype` property of functions is not enumerated due to cross-\\n            // environment inconsistencies.\\n            if (!(isFunction && property == \\\"prototype\\\") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {\\n              callback(property);\\n            }\\n          }\\n        };\\n      } else {\\n        // No bugs detected; use the standard `for...in` algorithm.\\n        forEach = function (object, callback) {\\n          var isFunction = getClass.call(object) == functionClass, property, isConstructor;\\n          for (property in object) {\\n            if (!(isFunction && property == \\\"prototype\\\") && isProperty.call(object, property) && !(isConstructor = property === \\\"constructor\\\")) {\\n              callback(property);\\n            }\\n          }\\n          // Manually invoke the callback for the `constructor` property due to\\n          // cross-environment inconsistencies.\\n          if (isConstructor || isProperty.call(object, (property = \\\"constructor\\\"))) {\\n            callback(property);\\n          }\\n        };\\n      }\\n      return forEach(object, callback);\\n    };\\n\\n    // Public: Serializes a JavaScript `value` as a JSON string. The optional\\n    // `filter` argument may specify either a function that alters how object and\\n    // array members are serialized, or an array of strings and numbers that\\n    // indicates which properties should be serialized. The optional `width`\\n    // argument may be either a string or number that specifies the indentation\\n    // level of the output.\\n    if (!has(\\\"json-stringify\\\")) {\\n      // Internal: A map of control characters and their escaped equivalents.\\n      var Escapes = {\\n        92: \\\"\\\\\\\\\\\\\\\\\\\",\\n        34: \\'\\\\\\\\\\\"\\',\\n        8: \\\"\\\\\\\\b\\\",\\n        12: \\\"\\\\\\\\f\\\",\\n        10: \\\"\\\\\\\\n\\\",\\n        13: \\\"\\\\\\\\r\\\",\\n        9: \\\"\\\\\\\\t\\\"\\n      };\\n\\n      // Internal: Converts `value` into a zero-padded string such that its\\n      // length is at least equal to `width`. The `width` must be <= 6.\\n      var leadingZeroes = \\\"000000\\\";\\n      var toPaddedString = function (width, value) {\\n        // The `|| 0` expression is necessary to work around a bug in\\n        // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== \\\"0\\\"`.\\n        return (leadingZeroes + (value || 0)).slice(-width);\\n      };\\n\\n      // Internal: Double-quotes a string `value`, replacing all ASCII control\\n      // characters (characters with code unit values between 0 and 31) with\\n      // their escaped equivalents. This is an implementation of the\\n      // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\\n      var unicodePrefix = \\\"\\\\\\\\u00\\\";\\n      var quote = function (value) {\\n        var result = \\'\\\"\\', index = 0, length = value.length, isLarge = length > 10 && charIndexBuggy, symbols;\\n        if (isLarge) {\\n          symbols = value.split(\\\"\\\");\\n        }\\n        for (; index < length; index++) {\\n          var charCode = value.charCodeAt(index);\\n          // If the character is a control character, append its Unicode or\\n          // shorthand escape sequence; otherwise, append the character as-is.\\n          switch (charCode) {\\n            case 8: case 9: case 10: case 12: case 13: case 34: case 92:\\n              result += Escapes[charCode];\\n              break;\\n            default:\\n              if (charCode < 32) {\\n                result += unicodePrefix + toPaddedString(2, charCode.toString(16));\\n                break;\\n              }\\n              result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];\\n          }\\n        }\\n        return result + \\'\\\"\\';\\n      };\\n\\n      // Internal: Recursively serializes an object. Implements the\\n      // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\\n      var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {\\n        var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\\n        try {\\n          // Necessary for host object support.\\n          value = object[property];\\n        } catch (exception) {}\\n        if (typeof value == \\\"object\\\" && value) {\\n          className = getClass.call(value);\\n          if (className == dateClass && !isProperty.call(value, \\\"toJSON\\\")) {\\n            if (value > -1 / 0 && value < 1 / 0) {\\n              // Dates are serialized according to the `Date#toJSON` method\\n              // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\\n              // for the ISO 8601 date time string format.\\n              if (getDay) {\\n                // Manually compute the year, month, date, hours, minutes,\\n                // seconds, and milliseconds if the `getUTC*` methods are\\n                // buggy. Adapted from @Yaffle\\'s `date-shim` project.\\n                date = floor(value / 864e5);\\n                for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);\\n                for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);\\n                date = 1 + date - getDay(year, month);\\n                // The `time` value specifies the time within the day (see ES\\n                // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\\n                // to compute `A modulo B`, as the `%` operator does not\\n                // correspond to the `modulo` operation for negative numbers.\\n                time = (value % 864e5 + 864e5) % 864e5;\\n                // The hours, minutes, seconds, and milliseconds are obtained by\\n                // decomposing the time within the day. See section 15.9.1.10.\\n                hours = floor(time / 36e5) % 24;\\n                minutes = floor(time / 6e4) % 60;\\n                seconds = floor(time / 1e3) % 60;\\n                milliseconds = time % 1e3;\\n              } else {\\n                year = value.getUTCFullYear();\\n                month = value.getUTCMonth();\\n                date = value.getUTCDate();\\n                hours = value.getUTCHours();\\n                minutes = value.getUTCMinutes();\\n                seconds = value.getUTCSeconds();\\n                milliseconds = value.getUTCMilliseconds();\\n              }\\n              // Serialize extended years correctly.\\n              value = (year <= 0 || year >= 1e4 ? (year < 0 ? \\\"-\\\" : \\\"+\\\") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +\\n                \\\"-\\\" + toPaddedString(2, month + 1) + \\\"-\\\" + toPaddedString(2, date) +\\n                // Months, dates, hours, minutes, and seconds should have two\\n                // digits; milliseconds should have three.\\n                \\\"T\\\" + toPaddedString(2, hours) + \\\":\\\" + toPaddedString(2, minutes) + \\\":\\\" + toPaddedString(2, seconds) +\\n                // Milliseconds are optional in ES 5.0, but required in 5.1.\\n                \\\".\\\" + toPaddedString(3, milliseconds) + \\\"Z\\\";\\n            } else {\\n              value = null;\\n            }\\n          } else if (typeof value.toJSON == \\\"function\\\" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, \\\"toJSON\\\"))) {\\n            // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\\n            // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\\n            // ignores all `toJSON` methods on these objects unless they are\\n            // defined directly on an instance.\\n            value = value.toJSON(property);\\n          }\\n        }\\n        if (callback) {\\n          // If a replacement function was provided, call it to obtain the value\\n          // for serialization.\\n          value = callback.call(object, property, value);\\n        }\\n        if (value === null) {\\n          return \\\"null\\\";\\n        }\\n        className = getClass.call(value);\\n        if (className == booleanClass) {\\n          // Booleans are represented literally.\\n          return \\\"\\\" + value;\\n        } else if (className == numberClass) {\\n          // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\\n          // `\\\"null\\\"`.\\n          return value > -1 / 0 && value < 1 / 0 ? \\\"\\\" + value : \\\"null\\\";\\n        } else if (className == stringClass) {\\n          // Strings are double-quoted and escaped.\\n          return quote(\\\"\\\" + value);\\n        }\\n        // Recursively serialize objects and arrays.\\n        if (typeof value == \\\"object\\\") {\\n          // Check for cyclic structures. This is a linear search; performance\\n          // is inversely proportional to the number of unique nested objects.\\n          for (length = stack.length; length--;) {\\n            if (stack[length] === value) {\\n              // Cyclic structures cannot be serialized by `JSON.stringify`.\\n              throw TypeError();\\n            }\\n          }\\n          // Add the object to the stack of traversed objects.\\n          stack.push(value);\\n          results = [];\\n          // Save the current indentation level and indent one additional level.\\n          prefix = indentation;\\n          indentation += whitespace;\\n          if (className == arrayClass) {\\n            // Recursively serialize array elements.\\n            for (index = 0, length = value.length; index < length; index++) {\\n              element = serialize(index, value, callback, properties, whitespace, indentation, stack);\\n              results.push(element === undef ? \\\"null\\\" : element);\\n            }\\n            result = results.length ? (whitespace ? \\\"[\\\\n\\\" + indentation + results.join(\\\",\\\\n\\\" + indentation) + \\\"\\\\n\\\" + prefix + \\\"]\\\" : (\\\"[\\\" + results.join(\\\",\\\") + \\\"]\\\")) : \\\"[]\\\";\\n          } else {\\n            // Recursively serialize object members. Members are selected from\\n            // either a user-specified list of property names, or the object\\n            // itself.\\n            forEach(properties || value, function (property) {\\n              var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\\n              if (element !== undef) {\\n                // According to ES 5.1 section 15.12.3: \\\"If `gap` {whitespace}\\n                // is not the empty string, let `member` {quote(property) + \\\":\\\"}\\n                // be the concatenation of `member` and the `space` character.\\\"\\n                // The \\\"`space` character\\\" refers to the literal space\\n                // character, not the `space` {width} argument provided to\\n                // `JSON.stringify`.\\n                results.push(quote(property) + \\\":\\\" + (whitespace ? \\\" \\\" : \\\"\\\") + element);\\n              }\\n            });\\n            result = results.length ? (whitespace ? \\\"{\\\\n\\\" + indentation + results.join(\\\",\\\\n\\\" + indentation) + \\\"\\\\n\\\" + prefix + \\\"}\\\" : (\\\"{\\\" + results.join(\\\",\\\") + \\\"}\\\")) : \\\"{}\\\";\\n          }\\n          // Remove the object from the traversed object stack.\\n          stack.pop();\\n          return result;\\n        }\\n      };\\n\\n      // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\\n      JSON3.stringify = function (source, filter, width) {\\n        var whitespace, callback, properties, className;\\n        if (typeof filter == \\\"function\\\" || typeof filter == \\\"object\\\" && filter) {\\n          if ((className = getClass.call(filter)) == functionClass) {\\n            callback = filter;\\n          } else if (className == arrayClass) {\\n            // Convert the property names array into a makeshift set.\\n            properties = {};\\n            for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));\\n          }\\n        }\\n        if (width) {\\n          if ((className = getClass.call(width)) == numberClass) {\\n            // Convert the `width` to an integer and create a string containing\\n            // `width` number of space characters.\\n            if ((width -= width % 1) > 0) {\\n              for (whitespace = \\\"\\\", width > 10 && (width = 10); whitespace.length < width; whitespace += \\\" \\\");\\n            }\\n          } else if (className == stringClass) {\\n            whitespace = width.length <= 10 ? width : width.slice(0, 10);\\n          }\\n        }\\n        // Opera <= 7.54u2 discards the values associated with empty string keys\\n        // (`\\\"\\\"`) only if they are used directly within an object member list\\n        // (e.g., `!(\\\"\\\" in { \\\"\\\": 1})`).\\n        return serialize(\\\"\\\", (value = {}, value[\\\"\\\"] = source, value), callback, properties, whitespace, \\\"\\\", []);\\n      };\\n    }\\n\\n    // Public: Parses a JSON source string.\\n    if (!has(\\\"json-parse\\\")) {\\n      var fromCharCode = String.fromCharCode;\\n\\n      // Internal: A map of escaped control characters and their unescaped\\n      // equivalents.\\n      var Unescapes = {\\n        92: \\\"\\\\\\\\\\\",\\n        34: \\'\\\"\\',\\n        47: \\\"/\\\",\\n        98: \\\"\\\\b\\\",\\n        116: \\\"\\\\t\\\",\\n        110: \\\"\\\\n\\\",\\n        102: \\\"\\\\f\\\",\\n        114: \\\"\\\\r\\\"\\n      };\\n\\n      // Internal: Stores the parser state.\\n      var Index, Source;\\n\\n      // Internal: Resets the parser state and throws a `SyntaxError`.\\n      var abort = function() {\\n        Index = Source = null;\\n        throw SyntaxError();\\n      };\\n\\n      // Internal: Returns the next token, or `\\\"$\\\"` if the parser has reached\\n      // the end of the source string. A token may be a string, number, `null`\\n      // literal, or Boolean literal.\\n      var lex = function () {\\n        var source = Source, length = source.length, value, begin, position, isSigned, charCode;\\n        while (Index < length) {\\n          charCode = source.charCodeAt(Index);\\n          switch (charCode) {\\n            case 9: case 10: case 13: case 32:\\n              // Skip whitespace tokens, including tabs, carriage returns, line\\n              // feeds, and space characters.\\n              Index++;\\n              break;\\n            case 123: case 125: case 91: case 93: case 58: case 44:\\n              // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at\\n              // the current position.\\n              value = charIndexBuggy ? source.charAt(Index) : source[Index];\\n              Index++;\\n              return value;\\n            case 34:\\n              // `\\\"` delimits a JSON string; advance to the next character and\\n              // begin parsing the string. String tokens are prefixed with the\\n              // sentinel `@` character to distinguish them from punctuators and\\n              // end-of-string tokens.\\n              for (value = \\\"@\\\", Index++; Index < length;) {\\n                charCode = source.charCodeAt(Index);\\n                if (charCode < 32) {\\n                  // Unescaped ASCII control characters (those with a code unit\\n                  // less than the space character) are not permitted.\\n                  abort();\\n                } else if (charCode == 92) {\\n                  // A reverse solidus (`\\\\`) marks the beginning of an escaped\\n                  // control character (including `\\\"`, `\\\\`, and `/`) or Unicode\\n                  // escape sequence.\\n                  charCode = source.charCodeAt(++Index);\\n                  switch (charCode) {\\n                    case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:\\n                      // Revive escaped control characters.\\n                      value += Unescapes[charCode];\\n                      Index++;\\n                      break;\\n                    case 117:\\n                      // `\\\\u` marks the beginning of a Unicode escape sequence.\\n                      // Advance to the first character and validate the\\n                      // four-digit code point.\\n                      begin = ++Index;\\n                      for (position = Index + 4; Index < position; Index++) {\\n                        charCode = source.charCodeAt(Index);\\n                        // A valid sequence comprises four hexdigits (case-\\n                        // insensitive) that form a single hexadecimal value.\\n                        if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\\n                          // Invalid Unicode escape sequence.\\n                          abort();\\n                        }\\n                      }\\n                      // Revive the escaped character.\\n                      value += fromCharCode(\\\"0x\\\" + source.slice(begin, Index));\\n                      break;\\n                    default:\\n                      // Invalid escape sequence.\\n                      abort();\\n                  }\\n                } else {\\n                  if (charCode == 34) {\\n                    // An unescaped double-quote character marks the end of the\\n                    // string.\\n                    break;\\n                  }\\n                  charCode = source.charCodeAt(Index);\\n                  begin = Index;\\n                  // Optimize for the common case where a string is valid.\\n                  while (charCode >= 32 && charCode != 92 && charCode != 34) {\\n                    charCode = source.charCodeAt(++Index);\\n                  }\\n                  // Append the string as-is.\\n                  value += source.slice(begin, Index);\\n                }\\n              }\\n              if (source.charCodeAt(Index) == 34) {\\n                // Advance to the next character and return the revived string.\\n                Index++;\\n                return value;\\n              }\\n              // Unterminated string.\\n              abort();\\n            default:\\n              // Parse numbers and literals.\\n              begin = Index;\\n              // Advance past the negative sign, if one is specified.\\n              if (charCode == 45) {\\n                isSigned = true;\\n                charCode = source.charCodeAt(++Index);\\n              }\\n              // Parse an integer or floating-point value.\\n              if (charCode >= 48 && charCode <= 57) {\\n                // Leading zeroes are interpreted as octal literals.\\n                if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {\\n                  // Illegal octal literal.\\n                  abort();\\n                }\\n                isSigned = false;\\n                // Parse the integer component.\\n                for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);\\n                // Floats cannot contain a leading decimal point; however, this\\n                // case is already accounted for by the parser.\\n                if (source.charCodeAt(Index) == 46) {\\n                  position = ++Index;\\n                  // Parse the decimal component.\\n                  for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\\n                  if (position == Index) {\\n                    // Illegal trailing decimal.\\n                    abort();\\n                  }\\n                  Index = position;\\n                }\\n                // Parse exponents. The `e` denoting the exponent is\\n                // case-insensitive.\\n                charCode = source.charCodeAt(Index);\\n                if (charCode == 101 || charCode == 69) {\\n                  charCode = source.charCodeAt(++Index);\\n                  // Skip past the sign following the exponent, if one is\\n                  // specified.\\n                  if (charCode == 43 || charCode == 45) {\\n                    Index++;\\n                  }\\n                  // Parse the exponential component.\\n                  for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\\n                  if (position == Index) {\\n                    // Illegal empty exponent.\\n                    abort();\\n                  }\\n                  Index = position;\\n                }\\n                // Coerce the parsed value to a JavaScript number.\\n                return +source.slice(begin, Index);\\n              }\\n              // A negative sign may only precede numbers.\\n              if (isSigned) {\\n                abort();\\n              }\\n              // `true`, `false`, and `null` literals.\\n              if (source.slice(Index, Index + 4) == \\\"true\\\") {\\n                Index += 4;\\n                return true;\\n              } else if (source.slice(Index, Index + 5) == \\\"false\\\") {\\n                Index += 5;\\n                return false;\\n              } else if (source.slice(Index, Index + 4) == \\\"null\\\") {\\n                Index += 4;\\n                return null;\\n              }\\n              // Unrecognized token.\\n              abort();\\n          }\\n        }\\n        // Return the sentinel `$` character if the parser has reached the end\\n        // of the source string.\\n        return \\\"$\\\";\\n      };\\n\\n      // Internal: Parses a JSON `value` token.\\n      var get = function (value) {\\n        var results, hasMembers;\\n        if (value == \\\"$\\\") {\\n          // Unexpected end of input.\\n          abort();\\n        }\\n        if (typeof value == \\\"string\\\") {\\n          if ((charIndexBuggy ? value.charAt(0) : value[0]) == \\\"@\\\") {\\n            // Remove the sentinel `@` character.\\n            return value.slice(1);\\n          }\\n          // Parse object and array literals.\\n          if (value == \\\"[\\\") {\\n            // Parses a JSON array, returning a new JavaScript array.\\n            results = [];\\n            for (;; hasMembers || (hasMembers = true)) {\\n              value = lex();\\n              // A closing square bracket marks the end of the array literal.\\n              if (value == \\\"]\\\") {\\n                break;\\n              }\\n              // If the array literal contains elements, the current token\\n              // should be a comma separating the previous element from the\\n              // next.\\n              if (hasMembers) {\\n                if (value == \\\",\\\") {\\n                  value = lex();\\n                  if (value == \\\"]\\\") {\\n                    // Unexpected trailing `,` in array literal.\\n                    abort();\\n                  }\\n                } else {\\n                  // A `,` must separate each array element.\\n                  abort();\\n                }\\n              }\\n              // Elisions and leading commas are not permitted.\\n              if (value == \\\",\\\") {\\n                abort();\\n              }\\n              results.push(get(value));\\n            }\\n            return results;\\n          } else if (value == \\\"{\\\") {\\n            // Parses a JSON object, returning a new JavaScript object.\\n            results = {};\\n            for (;; hasMembers || (hasMembers = true)) {\\n              value = lex();\\n              // A closing curly brace marks the end of the object literal.\\n              if (value == \\\"}\\\") {\\n                break;\\n              }\\n              // If the object literal contains members, the current token\\n              // should be a comma separator.\\n              if (hasMembers) {\\n                if (value == \\\",\\\") {\\n                  value = lex();\\n                  if (value == \\\"}\\\") {\\n                    // Unexpected trailing `,` in object literal.\\n                    abort();\\n                  }\\n                } else {\\n                  // A `,` must separate each object member.\\n                  abort();\\n                }\\n              }\\n              // Leading commas are not permitted, object property names must be\\n              // double-quoted strings, and a `:` must separate each property\\n              // name and value.\\n              if (value == \\\",\\\" || typeof value != \\\"string\\\" || (charIndexBuggy ? value.charAt(0) : value[0]) != \\\"@\\\" || lex() != \\\":\\\") {\\n                abort();\\n              }\\n              results[value.slice(1)] = get(lex());\\n            }\\n            return results;\\n          }\\n          // Unexpected token encountered.\\n          abort();\\n        }\\n        return value;\\n      };\\n\\n      // Internal: Updates a traversed object member.\\n      var update = function(source, property, callback) {\\n        var element = walk(source, property, callback);\\n        if (element === undef) {\\n          delete source[property];\\n        } else {\\n          source[property] = element;\\n        }\\n      };\\n\\n      // Internal: Recursively traverses a parsed JSON object, invoking the\\n      // `callback` function for each value. This is an implementation of the\\n      // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\\n      var walk = function (source, property, callback) {\\n        var value = source[property], length;\\n        if (typeof value == \\\"object\\\" && value) {\\n          // `forEach` can\\'t be used to traverse an array in Opera <= 8.54\\n          // because its `Object#hasOwnProperty` implementation returns `false`\\n          // for array indices (e.g., `![1, 2, 3].hasOwnProperty(\\\"0\\\")`).\\n          if (getClass.call(value) == arrayClass) {\\n            for (length = value.length; length--;) {\\n              update(value, length, callback);\\n            }\\n          } else {\\n            forEach(value, function (property) {\\n              update(value, property, callback);\\n            });\\n          }\\n        }\\n        return callback.call(source, property, value);\\n      };\\n\\n      // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\\n      JSON3.parse = function (source, callback) {\\n        var result, value;\\n        Index = 0;\\n        Source = \\\"\\\" + source;\\n        result = get(lex());\\n        // If a JSON string contains multiple tokens, it is invalid.\\n        if (lex() != \\\"$\\\") {\\n          abort();\\n        }\\n        // Reset the parser state.\\n        Index = Source = null;\\n        return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[\\\"\\\"] = result, value), \\\"\\\", callback) : result;\\n      };\\n    }\\n  }\\n\\n  // Export for asynchronous module loaders.\\n  if (isLoader) {\\n    define(function () {\\n      return JSON3;\\n    });\\n  }\\n}(this));\\n\\n},{}],44:[function(_dereq_,module,exports){\\nmodule.exports = toArray\\n\\nfunction toArray(list, index) {\\n    var array = []\\n\\n    index = index || 0\\n\\n    for (var i = index || 0; i < list.length; i++) {\\n        array[i - index] = list[i]\\n    }\\n\\n    return array\\n}\\n\\n},{}]},{},[1])\\n(1)\\n});\\n\\n//# sourceURL=/thirdparty/socket.io.js\");\n\n","eval(\"define(\\'lib/file-system\\',[\\'require\\',\\'exports\\',\\'module\\',\\'./open-dialog\\',\\'./save-dialog\\',\\'../thirdparty/socket.io\\'],function (require, exports) {\\n    \\\"use strict\\\";\\n\\n    var FileSystemStats     = brackets.getModule(\\\"filesystem/FileSystemStats\\\"),\\n        FileSystemError     = brackets.getModule(\\\"filesystem/FileSystemError\\\"),\\n        OpenDialog          = require(\\\"./open-dialog\\\"),\\n        SaveDialog          = require(\\\"./save-dialog\\\"),\\n        io                  = require(\\\"../thirdparty/socket.io\\\");\\n\\n    /**\\n     * Callback to notify FileSystem of watcher changes\\n     * @type {?function(string, FileSystemStats=)}\\n     */\\n    var _changeCallback;\\n\\n    /**\\n     * Callback to notify FileSystem if watchers stop working entirely\\n     * @type {?function()}\\n     */\\n    var _offlineCallback;\\n\\n    function _mapError(err) {\\n        if (!err) {\\n            return null;\\n        }\\n        switch (err.code) {\\n            case \\\"ERR_INVALID_PARAMS\\\":\\n                return FileSystemError.INVALID_PARAMS;\\n            case \\\"ENOENT\\\":\\n                return FileSystemError.NOT_FOUND;\\n            case \\\"ERR_CANT_READ\\\":\\n                return FileSystemError.NOT_READABLE;\\n            case \\\"ERR_CANT_WRITE\\\":\\n                return FileSystemError.NOT_WRITABLE;\\n            case \\\"ERR_UNSUPPORTED_ENCODING\\\":\\n                return FileSystemError.UNSUPPORTED_ENCODING;\\n            case \\\"ENOSPC\\\":\\n                return FileSystemError.OUT_OF_SPACE;\\n            case \\\"EEXIST\\\":\\n                return FileSystemError.ALREADY_EXISTS;\\n        }\\n        return FileSystemError.UNKNOWN;\\n    }\\n\\n    var socket;\\n\\n    function init(url) {\\n        socket = io.connect(url);\\n\\n        socket.on(\\\"greeting\\\", function (data) {\\n            if (data === \\\"hi\\\") {\\n                console.log(\\\"Socket.io connected!\\\");\\n            }\\n        });\\n    }\\n\\n    /**\\n     * Display an open-files dialog to the user and call back asynchronously with\\n     * either a FileSystmError string or an array of path strings, which indicate\\n     * the entry or entries selected.\\n     *\\n     * @param {boolean} allowMultipleSelection\\n     * @param {boolean} chooseDirectories\\n     * @param {string} title\\n     * @param {string} initialPath\\n     * @param {Array.<string>=} fileTypes\\n     * @param {function(?string, Array.<string>=)} callback\\n     */\\n    function showOpenDialog(allowMultipleSelection, chooseDirectories, title, initialPath, fileTypes, callback) {\\n        OpenDialog.show(allowMultipleSelection, chooseDirectories, title, initialPath, fileTypes, callback);\\n    }\\n\\n    /**\\n     * Display a save-file dialog and call back asynchronously with either a\\n     * FileSystemError string or the path to which the user has chosen to save\\n     * the file. If the dialog is cancelled, the path string will be empty.\\n     *\\n     * @param {string} title\\n     * @param {string} initialPath\\n     * @param {string} proposedNewFilename\\n     * @param {function(?string, string=)} callback\\n     */\\n    function showSaveDialog(title, initialPath, proposedNewFilename, callback) {\\n        SaveDialog.show(title, initialPath, proposedNewFilename, callback);\\n    }\\n\\n    /**\\n     * Stat the file or directory at the given path, calling back\\n     * asynchronously with either a FileSystemError string or the entry\\'s\\n     * associated FileSystemStats object.\\n     *\\n     * @param {string} path\\n     * @param {function(?string, FileSystemStats=)} callback\\n     */\\n    function stat(path, callback) {\\n        socket.emit(\\\"stat\\\", path, function (res) {\\n            if (res.err) {\\n                callback(_mapError(res.err));\\n            } else {\\n                res.stats.mtime = new Date(res.stats.mtime);\\n                callback(null, new FileSystemStats(res.stats));\\n            }\\n        });\\n    }\\n\\n    /**\\n     * Determine whether a file or directory exists at the given path by calling\\n     * back asynchronously with either a FileSystemError string or a boolean,\\n     * which is true if the file exists and false otherwise. The error will never\\n     * be FileSystemError.NOT_FOUND; in that case, there will be no error and the\\n     * boolean parameter will be false.\\n     *\\n     * @param {string} path\\n     * @param {function(?string, boolean)} callback\\n     */\\n    function exists(path, callback) {\\n        stat(path, function (err) {\\n            if (err) {\\n                if (err === FileSystemError.NOT_FOUND) {\\n                    callback(null, false);\\n                } else {\\n                    callback(err);\\n                }\\n                return;\\n            }\\n\\n            callback(null, true);\\n        });\\n    }\\n\\n    /**\\n     * Read the contents of the directory at the given path, calling back\\n     * asynchronously either with a FileSystemError string or an array of\\n     * FileSystemEntry objects along with another consistent array, each index\\n     * of which either contains a FileSystemStats object for the corresponding\\n     * FileSystemEntry object in the second parameter or a FileSystemError\\n     * string describing a stat error.\\n     *\\n     * @param {string} path\\n     * @param {function(?string, Array.<FileSystemEntry>=, Array.<string|FileSystemStats>=)} callback\\n     */\\n    function readdir(path, callback) {\\n        socket.emit(\\\"readdir\\\", path, function (res) {\\n            if (res.err) {\\n                return callback(_mapError(res.err));\\n            }\\n\\n            var count = res.contents.length;\\n            if (!count) {\\n                return callback(null, [], []);\\n            }\\n\\n            var stats = [];\\n            res.contents.forEach(function (val, idx) {\\n                stat(path + \\\"/\\\" + val, function (err, stat) {\\n                    stats[idx] = err || stat;\\n                    count--;\\n                    if (count <= 0) {\\n                        callback(null, res.contents, stats);\\n                    }\\n                });\\n            });\\n        });\\n    }\\n\\n    /**\\n     * Create a directory at the given path, and call back asynchronously with\\n     * either a FileSystemError string or a stats object for the newly created\\n     * directory. The octal mode parameter is optional; if unspecified, the mode\\n     * of the created directory is implementation dependent.\\n     *\\n     * @param {string} path\\n     * @param {number=} mode The base-eight mode of the newly created directory.\\n     * @param {function(?string, FileSystemStats=)=} callback\\n     */\\n    function mkdir(path, mode, callback) {\\n        if (typeof mode === \\\"function\\\") {\\n            callback = mode;\\n            mode = parseInt(\\\"0755\\\", 8);\\n        }\\n        socket.emit(\\\"mkdir\\\", { path: path, mode: mode }, function (err) {\\n            if (callback) {\\n                if (err) {\\n                    return callback(_mapError(err));\\n                }\\n                stat(path, callback);\\n            }\\n        });\\n    }\\n\\n    /**\\n     * Rename the file or directory at oldPath to newPath, and call back\\n     * asynchronously with a possibly null FileSystemError string.\\n     *\\n     * @param {string} oldPath\\n     * @param {string} newPath\\n     * @param {function(?string)=} callback\\n     */\\n    function rename(oldPath, newPath, callback) {\\n        socket.emit(\\\"rename\\\", { oldPath: oldPath, newPath: newPath }, function (err) {\\n            if (callback) {\\n                callback(_mapError(err));\\n            }\\n        });\\n    }\\n\\n    /**\\n     * Read the contents of the file at the given path, calling back\\n     * asynchronously with either a FileSystemError string, or with the data and\\n     * the FileSystemStats object associated with the read file. The options\\n     * parameter can be used to specify an encoding (default \\\"utf8\\\"), and also\\n     * a cached stats object that the implementation is free to use in order\\n     * to avoid an additional stat call.\\n     *\\n     * Note: if either the read or the stat call fails then neither the read data\\n     * nor stat will be passed back, and the call should be considered to have failed.\\n     * If both calls fail, the error from the read call is passed back.\\n     *\\n     * @param {string} path\\n     * @param {{encoding: string=, stat: FileSystemStats=}} options\\n     * @param {function(?string, string=, FileSystemStats=)} callback\\n     */\\n    function readFile(path, options, callback) {\\n        var encoding = options.encoding || \\\"utf8\\\";\\n\\n        // Execute the read and stat calls in parallel. Callback early if the\\n        // read call completes first with an error; otherwise wait for both\\n        // to finish.\\n        var done = false, data, fileStat, err;\\n\\n        if (options.stat) {\\n            done = true;\\n            fileStat = options.stat;\\n        } else {\\n            stat(path, function (_err, _stat) {\\n                if (done) {\\n                    callback(_err, _err ? null : data, _stat);\\n                } else {\\n                    done = true;\\n                    fileStat = _stat;\\n                    err = _err;\\n                }\\n            });\\n        }\\n\\n        socket.emit(\\\"readFile\\\", { path: path, encoding: encoding }, function (res) {\\n            if (res.err) {\\n                callback(_mapError(res.err));\\n                return;\\n            }\\n\\n            if (done) {\\n                callback(err, err ? null : res.data, fileStat);\\n            } else {\\n                done = true;\\n                data = res.data;\\n            }\\n        });\\n    }\\n\\n    /**\\n     * Write data to the file at the given path, calling back asynchronously with\\n     * either a FileSystemError string or the FileSystemStats object associated\\n     * with the written file and a boolean that indicates whether the file was\\n     * created by the write (true) or not (false). If no file exists at the\\n     * given path, a new file will be created. The options parameter can be used\\n     * to specify an encoding (default \\\"utf8\\\"), an octal mode (default\\n     * unspecified and implementation dependent), and a consistency hash, which\\n     * is used to the current state of the file before overwriting it. If a\\n     * consistency hash is provided but does not match the hash of the file on\\n     * disk, a FileSystemError.CONTENTS_MODIFIED error is passed to the callback.\\n     *\\n     * @param {string} path\\n     * @param {string} data\\n     * @param {{encoding : string=, mode : number=, expectedHash : object=, expectedContents : string=}} options\\n     * @param {function(?string, FileSystemStats=, boolean)} callback\\n     */\\n    function writeFile(path, data, options, callback) {\\n        var encoding = options.encoding || \\\"utf8\\\";\\n\\n        function _finishWrite(created) {\\n            socket.emit(\\\"writeFile\\\", { path: path, data: data, encoding: encoding }, function (err) {\\n                if (err) {\\n                    callback(_mapError(err));\\n                } else {\\n                    stat(path, function (err, stat) {\\n                        callback(err, stat, created);\\n                    });\\n                }\\n            });\\n        }\\n\\n        stat(path, function (err, stats) {\\n            if (err) {\\n                switch (err) {\\n                    case FileSystemError.NOT_FOUND:\\n                        _finishWrite(true);\\n                        break;\\n                    default:\\n                        callback(err);\\n                }\\n                return;\\n            }\\n\\n            if (options.hasOwnProperty(\\\"expectedHash\\\") && options.expectedHash !== stats._hash) {\\n                console.error(\\\"Blind write attempted: \\\", path, stats._hash, options.expectedHash);\\n\\n                if (options.hasOwnProperty(\\\"expectedContents\\\")) {\\n                    readFile(path, options, function (_err, _data) {\\n                        if (_err || _data !== options.expectedContents) {\\n                            callback(FileSystemError.CONTENTS_MODIFIED);\\n                            return;\\n                        }\\n\\n                        _finishWrite(false);\\n                    });\\n                    return;\\n                } else {\\n                    callback(FileSystemError.CONTENTS_MODIFIED);\\n                    return;\\n                }\\n            }\\n\\n            _finishWrite(false);\\n        });\\n    }\\n\\n    /**\\n     * Unlink (i.e., permanently delete) the file or directory at the given path,\\n     * calling back asynchronously with a possibly null FileSystemError string.\\n     * Directories will be unlinked even when non-empty.\\n     *\\n     * @param {string} path\\n     * @param {function(string)=} callback\\n     */\\n    function unlink(path, callback) {\\n        socket.emit(\\\"unlink\\\", path, function (err) {\\n            if (callback) {\\n                callback(_mapError(err));\\n            }\\n        });\\n    }\\n\\n    /**\\n     * Move the file or directory at the given path to a system dependent trash\\n     * location, calling back asynchronously with a possibly null FileSystemError\\n     * string. Directories will be moved even when non-empty.\\n     *\\n     * @param {string} path\\n     * @param {function(string)=} callback\\n     */\\n    function moveToTrash(path, callback) {\\n        socket.emit(\\\"moveToTrash\\\", path, function (err) {\\n            if (callback) {\\n                callback(_mapError(err));\\n            }\\n        });\\n    }\\n\\n    /**\\n     * Initialize file watching for this filesystem, using the supplied\\n     * changeCallback to provide change notifications. The first parameter of\\n     * changeCallback specifies the changed path (either a file or a directory);\\n     * if this parameter is null, it indicates that the implementation cannot\\n     * specify a particular changed path, and so the callers should consider all\\n     * paths to have changed and to update their state accordingly. The second\\n     * parameter to changeCallback is an optional FileSystemStats object that\\n     * may be provided in case the changed path already exists and stats are\\n     * readily available. The offlineCallback will be called in case watchers\\n     * are no longer expected to function properly. All watched paths are\\n     * cleared when the offlineCallback is called.\\n     *\\n     * @param {function(?string, FileSystemStats=)} changeCallback\\n     * @param {function()=} offlineCallback\\n     */\\n    function initWatchers(changeCallback, offlineCallback) {\\n        _changeCallback = changeCallback;\\n        _offlineCallback = offlineCallback;\\n    }\\n\\n    /**\\n     * Start providing change notifications for the file or directory at the\\n     * given path, calling back asynchronously with a possibly null FileSystemError\\n     * string when the initialization is complete. Notifications are provided\\n     * using the changeCallback function provided by the initWatchers method.\\n     * Note that change notifications are only provided recursively for directories\\n     * when the recursiveWatch property of this module is true.\\n     *\\n     * @param {string} path\\n     * @param {function(?string)=} callback\\n     */\\n    function watchPath(path, callback) {\\n        socket.emit(\\\"watchPath\\\", path, function (err) {\\n            if (callback) {\\n                callback(_mapError(err));\\n            }\\n        });\\n    }\\n\\n    /**\\n     * Stop providing change notifications for the file or directory at the\\n     * given path, calling back asynchronously with a possibly null FileSystemError\\n     * string when the operation is complete.\\n     *\\n     * @param {string} path\\n     * @param {function(?string)=} callback\\n     */\\n    function unwatchPath(path, callback) {\\n        socket.emit(\\\"unwatchPath\\\", path, function (err) {\\n            if (callback) {\\n                callback(_mapError(err));\\n            }\\n        });\\n    }\\n\\n    /**\\n     * Stop providing change notifications for all previously watched files and\\n     * directories, optionally calling back asynchronously with a possibly null\\n     * FileSystemError string when the operation is complete.\\n     *\\n     * @param {function(?string)=} callback\\n     */\\n    function unwatchAll(callback) {\\n        socket.emit(\\\"unwatchAll\\\", \\\"\\\", function (err) {\\n            if (callback) {\\n                callback(_mapError(err));\\n            }\\n        });\\n    }\\n\\n    function copyFile(srcPath, destPath, callback) {\\n        socket.emit(\\\"copyFile\\\", { src: srcPath, dest: destPath}, function (err) {\\n            if (callback) {\\n                callback(_mapError(err));\\n            }\\n        });\\n    }\\n\\n    function setDialogs(openDlg, saveDlg) {\\n        OpenDialog = openDlg;\\n        SaveDialog = saveDlg;\\n    }\\n\\n    // Export public API\\n    exports.showOpenDialog  = showOpenDialog;\\n    exports.showSaveDialog  = showSaveDialog;\\n    exports.exists          = exists;\\n    exports.readdir         = readdir;\\n    exports.mkdir           = mkdir;\\n    exports.rename          = rename;\\n    exports.stat            = stat;\\n    exports.readFile        = readFile;\\n    exports.writeFile       = writeFile;\\n    exports.unlink          = unlink;\\n    exports.moveToTrash     = moveToTrash;\\n    exports.initWatchers    = initWatchers;\\n    exports.watchPath       = watchPath;\\n    exports.unwatchPath     = unwatchPath;\\n    exports.unwatchAll      = unwatchAll;\\n    exports.copyFile        = copyFile;\\n    exports._setDialogs     = setDialogs;\\n    exports._init           = init;\\n\\n    /**\\n     * Indicates whether or not recursive watching notifications are supported\\n     * by the watchPath call. Currently, only Darwin supports recursive watching.\\n     *\\n     * @type {boolean}\\n     */\\n    exports.recursiveWatch = false;\\n\\n    /**\\n     * Indicates whether or not the filesystem should expect and normalize UNC\\n     * paths. If set, then //server/directory/ is a normalized path; otherwise the\\n     * filesystem will normalize it to /server/directory. Currently, UNC path\\n     * normalization only occurs on Windows.\\n     *\\n     * @type {boolean}\\n     */\\n    exports.normalizeUNCPaths = false;\\n\\n    // The line below is a placeholder for the server version.\\n    // init(\\\"/brackets\\\");\\n});\\n\\n//# sourceURL=/lib/file-system.js\");\n\n","eval(\"define(\\'lib/fs-wrapper\\',[\\'require\\',\\'exports\\',\\'module\\',\\'./file-system\\'],function (require, exports) {\\n    \\\"use strict\\\";\\n\\n    var nativeFs    = brackets.getModule(\\\"fileSystemImpl\\\"),\\n        remoteFs    = require(\\\"./file-system\\\"),\\n        fs          = nativeFs;\\n\\n    function showOpenDialog(allowMultipleSelection, chooseDirectories, title, initialPath, fileTypes, callback) {\\n        nativeFs.showOpenDialog(allowMultipleSelection, chooseDirectories, title, initialPath, fileTypes, callback);\\n    }\\n\\n    function showSaveDialog(title, initialPath, proposedNewFilename, callback) {\\n        nativeFs.showSaveDialog(title, initialPath, proposedNewFilename, callback);\\n    }\\n\\n    function stat(path, callback) {\\n        fs.stat(path, callback);\\n    }\\n\\n    function exists(path, callback) {\\n        fs.exists(path, callback);\\n    }\\n\\n    function readdir(path, callback) {\\n        fs.readdir(path, callback);\\n    }\\n\\n    function mkdir(path, mode, callback) {\\n        fs.mkdir(path, mode, callback);\\n    }\\n\\n    function rename(oldPath, newPath, callback) {\\n        fs.rename(oldPath, newPath, callback);\\n    }\\n\\n    function readFile(path, options, callback) {\\n        fs.readFile(path, options, callback);\\n    }\\n\\n    function writeFile(path, data, options, callback) {\\n        fs.writeFile(path, data, options, callback);\\n    }\\n\\n    function unlink(path, callback) {\\n        fs.unlink(path, callback);\\n    }\\n\\n    function moveToTrash(path, callback) {\\n        fs.moveToTrash(path, callback);\\n    }\\n\\n    function initWatchers(changeCallback, offlineCallback) {\\n//      Initialize watchers for both implementations.\\n        nativeFs.initWatchers(changeCallback, offlineCallback);\\n        remoteFs.initWatchers(changeCallback, offlineCallback);\\n    }\\n\\n    function watchPath(path, callback) {\\n        fs.watchPath(path, callback);\\n    }\\n\\n    function unwatchPath(path, callback) {\\n        fs.unwatchPath(path, callback);\\n    }\\n\\n    function unwatchAll(callback) {\\n        fs.unwatchAll(callback);\\n    }\\n\\n    function setFs(remote) {\\n        if (remote) {\\n            fs = remote;\\n            fs._init(remote);\\n        } else {\\n            fs = nativeFs;\\n        }\\n    }\\n\\n    Object.defineProperty(exports, \\\"recursiveWatch\\\", {\\n        get: function () {\\n            return nativeFs.recursiveWatch;\\n        }\\n    });\\n\\n    Object.defineProperty(exports, \\\"normalizeUNCPaths\\\", {\\n        get: function () {\\n            return nativeFs.normalizeUNCPaths;\\n        }\\n    });\\n\\n    // Export public API\\n    exports.showOpenDialog  = showOpenDialog;\\n    exports.showSaveDialog  = showSaveDialog;\\n    exports.exists          = exists;\\n    exports.readdir         = readdir;\\n    exports.mkdir           = mkdir;\\n    exports.rename          = rename;\\n    exports.stat            = stat;\\n    exports.readFile        = readFile;\\n    exports.writeFile       = writeFile;\\n    exports.unlink          = unlink;\\n    exports.moveToTrash     = moveToTrash;\\n    exports.initWatchers    = initWatchers;\\n    exports.watchPath       = watchPath;\\n    exports.unwatchPath     = unwatchPath;\\n    exports.unwatchAll      = unwatchAll;\\n    exports.setFs           = setFs;\\n});\\n\\n//# sourceURL=/lib/fs-wrapper.js\");\n\n","eval(\"define(\\'main\\',[\\'require\\',\\'exports\\',\\'module\\',\\'./strings\\',\\'./lib/open-dialog\\',\\'./lib/save-dialog\\',\\'./lib/fs-wrapper\\'],function (require, exports, module) {\\n    \\\"use strict\\\";\\n\\n    var CommandManager      = brackets.getModule(\\\"command/CommandManager\\\"),\\n        Commands            = brackets.getModule(\\\"command/Commands\\\"),\\n        Menus               = brackets.getModule(\\\"command/Menus\\\"),\\n        ExtensionUtils      = brackets.getModule(\\\"utils/ExtensionUtils\\\"),\\n        fsImpl              = brackets.getModule(\\\"fileSystemImpl\\\"),\\n        Strings             = require(\\\"./strings\\\"),\\n        OPEN_CMD_ID         = \\\"remoteFS.open\\\",\\n        OPEN_FLDR_CMD_ID    = \\\"remoteFS.openFolder\\\",\\n        SAVE_AS_CMD_ID      = \\\"remoteFS.saveAs\\\";\\n\\n    ExtensionUtils.loadStyleSheet(module, \\\"styles/dialog.less\\\");\\n\\n    if (fsImpl._setDialogs) {\\n        // This means we are running in hosted Brackets and remote-fs is already bound.\\n        // We still have to set the dialogs.\\n        fsImpl._setDialogs(require(\\\"./lib/open-dialog\\\"), require(\\\"./lib/save-dialog\\\"));\\n    } else {\\n        // We are running on native OS shell.\\n        var FileSystem  = brackets.getModule(\\\"filesystem/FileSystem\\\"),\\n            wrapper     = require(\\\"./lib/fs-wrapper\\\"),\\n            menu        = Menus.getMenu(Menus.AppMenuBar.FILE_MENU),\\n            handler     = function () {};\\n\\n        FileSystem.init(wrapper);\\n\\n        CommandManager.register(Strings.MENU_OPEN, OPEN_CMD_ID, handler);\\n        CommandManager.register(Strings.MENU_OPEN_FOLDER, OPEN_FLDR_CMD_ID, handler);\\n        CommandManager.register(Strings.MENU_SAVE_AS, SAVE_AS_CMD_ID, handler);\\n\\n        menu.addMenuItem(SAVE_AS_CMD_ID, \\\"\\\", Menus.AFTER, Commands.FILE_SAVE_AS);\\n        menu.addMenuItem(OPEN_FLDR_CMD_ID, \\\"\\\", Menus.AFTER, Commands.FILE_SAVE_AS);\\n        menu.addMenuItem(OPEN_CMD_ID, \\\"\\\", Menus.AFTER, Commands.FILE_SAVE_AS);\\n        menu.addMenuDivider(Menus.AFTER, Commands.FILE_SAVE_AS);\\n    }\\n});\\n\\n//# sourceURL=/main.js\");\n\n"]}