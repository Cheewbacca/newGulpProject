{"version":3,"file":"main.js","sources":["main.js"],"names":["eval"],"mappings":"AAAAA,KAAA","sourcesContent":["eval(\"/*\\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\\n *  \\n * Permission is hereby granted, free of charge, to any person obtaining a\\n * copy of this software and associated documentation files (the \\\"Software\\\"), \\n * to deal in the Software without restriction, including without limitation \\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \\n * and/or sell copies of the Software, and to permit persons to whom the \\n * Software is furnished to do so, subject to the following conditions:\\n *  \\n * The above copyright notice and this permission notice shall be included in\\n * all copies or substantial portions of the Software.\\n *  \\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \\n * DEALINGS IN THE SOFTWARE.\\n * \\n */\\n\\n\\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\\n/*global define, brackets, $ */\\n\\ndefine(\\'main\\',[\\'require\\',\\'exports\\',\\'module\\'],function (require, exports, module) {\\n    \\\"use strict\\\";\\n    \\n    // Brackets modules\\n    var MultiRangeInlineEditor  = brackets.getModule(\\\"editor/MultiRangeInlineEditor\\\").MultiRangeInlineEditor,\\n        EditorManager           = brackets.getModule(\\\"editor/EditorManager\\\"),\\n        JSUtils                 = brackets.getModule(\\\"language/JSUtils\\\"),\\n        LanguageManager         = brackets.getModule(\\\"language/LanguageManager\\\"),\\n        PerfUtils               = brackets.getModule(\\\"utils/PerfUtils\\\"),\\n        ProjectManager          = brackets.getModule(\\\"project/ProjectManager\\\"),\\n        Strings                 = brackets.getModule(\\\"strings\\\");\\n    \\n    /**\\n     * Return the token string that is at the specified position.\\n     *\\n     * @param hostEditor {!Editor} editor\\n     * @param {!{line:number, ch:number}} pos\\n     * @return {functionName: string, reason: string}\\n     */\\n    function _getFunctionName(hostEditor, pos) {\\n        var token = hostEditor._codeMirror.getTokenAt(pos, true);\\n        \\n        // If the pos is at the beginning of a name, token will be the \\n        // preceding whitespace or dot. In that case, try the next pos.\\n        if (!/\\\\S/.test(token.string) || token.string === \\\".\\\") {\\n            token = hostEditor._codeMirror.getTokenAt({line: pos.line, ch: pos.ch + 1}, true);\\n        }\\n        \\n        // Return valid function expressions only (function call or reference)\\n        if (!((token.type === \\\"variable\\\") ||\\n              (token.type === \\\"variable-2\\\") ||\\n              (token.type === \\\"property\\\"))) {\\n            return {\\n                functionName: null,\\n                reason: Strings.ERROR_JSQUICKEDIT_FUNCTIONNOTFOUND\\n            };\\n        }\\n        \\n        return {\\n            functionName: token.string,\\n            reason: null\\n        };\\n    }\\n    \\n    /**\\n     * @private\\n     * For unit and performance tests. Allows lookup by function name instead of editor offset\\n     * without constructing an inline editor.\\n     *\\n     * @param {!string} functionName\\n     * @return {$.Promise} a promise that will be resolved with an array of function offset information\\n     */\\n    function _findInProject(functionName) {\\n        var result = new $.Deferred();\\n        \\n        PerfUtils.markStart(PerfUtils.JAVASCRIPT_FIND_FUNCTION);\\n        \\n        function _nonBinaryFileFilter(file) {\\n            return !LanguageManager.getLanguageForPath(file.fullPath).isBinary();\\n        }\\n        \\n        ProjectManager.getAllFiles(_nonBinaryFileFilter)\\n            .done(function (files) {\\n                JSUtils.findMatchingFunctions(functionName, files)\\n                    .done(function (functions) {\\n                        PerfUtils.addMeasurement(PerfUtils.JAVASCRIPT_FIND_FUNCTION);\\n                        result.resolve(functions);\\n                    })\\n                    .fail(function () {\\n                        PerfUtils.finalizeMeasurement(PerfUtils.JAVASCRIPT_FIND_FUNCTION);\\n                        result.reject();\\n                    });\\n            })\\n            .fail(function () {\\n                result.reject();\\n            });\\n        \\n        return result.promise();\\n    }\\n    \\n    /**\\n     * @private\\n     * For unit and performance tests. Allows lookup by function name instead of editor offset .\\n     *\\n     * @param {!Editor} hostEditor\\n     * @param {!string} functionName\\n     * @return {?$.Promise} synchronously resolved with an InlineWidget, or\\n     *         {string} if js other than function is detected at pos, or\\n     *         null if we\\'re not ready to provide anything.\\n     */\\n    function _createInlineEditor(hostEditor, functionName) {\\n        // Use Tern jump-to-definition helper, if it\\'s available, to find InlineEditor target.\\n        var helper = brackets._jsCodeHintsHelper;\\n        if (helper === null) {\\n            return null;\\n        }\\n\\n        var result = new $.Deferred();\\n        PerfUtils.markStart(PerfUtils.JAVASCRIPT_INLINE_CREATE);\\n\\n        var response = helper();\\n        if (response.hasOwnProperty(\\\"promise\\\")) {\\n            response.promise.done(function (jumpResp) {\\n                var resolvedPath = jumpResp.fullPath;\\n                if (resolvedPath) {\\n\\n                    // Tern doesn\\'t always return entire function extent.\\n                    // Use QuickEdit search now that we know which file to look at.\\n                    var fileInfos = [];\\n                    fileInfos.push({name: jumpResp.resultFile, fullPath: resolvedPath});\\n                    JSUtils.findMatchingFunctions(functionName, fileInfos, true)\\n                        .done(function (functions) {\\n                            if (functions && functions.length > 0) {\\n                                var jsInlineEditor = new MultiRangeInlineEditor(functions);\\n                                jsInlineEditor.load(hostEditor);\\n                                \\n                                PerfUtils.addMeasurement(PerfUtils.JAVASCRIPT_INLINE_CREATE);\\n                                result.resolve(jsInlineEditor);\\n                            } else {\\n                                // No matching functions were found\\n                                PerfUtils.addMeasurement(PerfUtils.JAVASCRIPT_INLINE_CREATE);\\n                                result.reject();\\n                            }\\n                        })\\n                        .fail(function () {\\n                            PerfUtils.addMeasurement(PerfUtils.JAVASCRIPT_INLINE_CREATE);\\n                            result.reject();\\n                        });\\n\\n                } else {        // no result from Tern.  Fall back to _findInProject().\\n\\n                    _findInProject(functionName).done(function (functions) {\\n                        if (functions && functions.length > 0) {\\n                            var jsInlineEditor = new MultiRangeInlineEditor(functions);\\n                            jsInlineEditor.load(hostEditor);\\n                            \\n                            PerfUtils.addMeasurement(PerfUtils.JAVASCRIPT_INLINE_CREATE);\\n                            result.resolve(jsInlineEditor);\\n                        } else {\\n                            // No matching functions were found\\n                            PerfUtils.addMeasurement(PerfUtils.JAVASCRIPT_INLINE_CREATE);\\n                            result.reject();\\n                        }\\n                    }).fail(function () {\\n                        PerfUtils.finalizeMeasurement(PerfUtils.JAVASCRIPT_INLINE_CREATE);\\n                        result.reject();\\n                    });\\n                }\\n\\n            }).fail(function () {\\n                PerfUtils.finalizeMeasurement(PerfUtils.JAVASCRIPT_INLINE_CREATE);\\n                result.reject();\\n            });\\n\\n        }\\n\\n        return result.promise();\\n    }\\n    \\n    /**\\n     * This function is registered with EditorManager as an inline editor provider. It creates an inline editor\\n     * when the cursor is on a JavaScript function name, finds all functions that match the name\\n     * and shows (one/all of them) in an inline editor.\\n     *\\n     * @param {!Editor} editor\\n     * @param {!{line:number, ch:number}} pos\\n     * @return {$.Promise} a promise that will be resolved with an InlineWidget\\n     *      or null if we\\'re not ready to provide anything.\\n     */\\n    function javaScriptFunctionProvider(hostEditor, pos) {\\n        // Only provide a JavaScript editor when cursor is in JavaScript content\\n        if (hostEditor.getModeForSelection() !== \\\"javascript\\\") {\\n            return null;\\n        }\\n        \\n        // Only provide JavaScript editor if the selection is within a single line\\n        var sel = hostEditor.getSelection();\\n        if (sel.start.line !== sel.end.line) {\\n            return null;\\n        }\\n\\n        // Always use the selection start for determining the function name. The pos\\n        // parameter is usually the selection end.        \\n        var functionResult = _getFunctionName(hostEditor, sel.start);\\n        if (!functionResult.functionName) {\\n            return functionResult.reason || null;\\n        }\\n\\n        return _createInlineEditor(hostEditor, functionResult.functionName);\\n    }\\n\\n    // init\\n    EditorManager.registerInlineEditProvider(javaScriptFunctionProvider);\\n    PerfUtils.createPerfMeasurement(\\\"JAVASCRIPT_INLINE_CREATE\\\", \\\"JavaScript Inline Editor Creation\\\");\\n    PerfUtils.createPerfMeasurement(\\\"JAVASCRIPT_FIND_FUNCTION\\\", \\\"JavaScript Find Function\\\");\\n    \\n    // for unit tests only\\n    exports.javaScriptFunctionProvider  = javaScriptFunctionProvider;\\n    exports._createInlineEditor         = _createInlineEditor;\\n    exports._findInProject              = _findInProject;\\n});\\n\\n//# sourceURL=/main.js\");\n\n"]}