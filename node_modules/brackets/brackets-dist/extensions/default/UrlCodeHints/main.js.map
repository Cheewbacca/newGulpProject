{"version":3,"file":"main.js","sources":["../../../thirdparty/text/text.js","data.json!text","main.js"],"names":["eval"],"mappings":"AAAAA,KAAA,yqfCCAA,KAAA,uOCDAA,KAAA","sourcesContent":["eval(\"/**\\n * @license RequireJS text 2.0.10 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.\\n * Available via the MIT or new BSD license.\\n * see: http://github.com/requirejs/text for details\\n */\\n/*jslint regexp: true */\\n/*global require, XMLHttpRequest, ActiveXObject,\\n  define, window, process, Packages,\\n  java, location, Components, FileUtils */\\n\\ndefine(\\'text\\',[\\'module\\'], function (module) {\\n    \\'use strict\\';\\n\\n    var text, fs, Cc, Ci, xpcIsWindows,\\n        progIds = [\\'Msxml2.XMLHTTP\\', \\'Microsoft.XMLHTTP\\', \\'Msxml2.XMLHTTP.4.0\\'],\\n        xmlRegExp = /^\\\\s*<\\\\?xml(\\\\s)+version=[\\\\\\'\\\\\\\"](\\\\d)*.(\\\\d)*[\\\\\\'\\\\\\\"](\\\\s)*\\\\?>/im,\\n        bodyRegExp = /<body[^>]*>\\\\s*([\\\\s\\\\S]+)\\\\s*<\\\\/body>/im,\\n        hasLocation = typeof location !== \\'undefined\\' && location.href,\\n        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\\\\:/, \\'\\'),\\n        defaultHostName = hasLocation && location.hostname,\\n        defaultPort = hasLocation && (location.port || undefined),\\n        buildMap = {},\\n        masterConfig = (module.config && module.config()) || {};\\n\\n    text = {\\n        version: \\'2.0.10\\',\\n\\n        strip: function (content) {\\n            //Strips <?xml ...?> declarations so that external SVG and XML\\n            //documents can be added to a document without worry. Also, if the string\\n            //is an HTML document, only the part inside the body tag is returned.\\n            if (content) {\\n                content = content.replace(xmlRegExp, \\\"\\\");\\n                var matches = content.match(bodyRegExp);\\n                if (matches) {\\n                    content = matches[1];\\n                }\\n            } else {\\n                content = \\\"\\\";\\n            }\\n            return content;\\n        },\\n\\n        jsEscape: function (content) {\\n            return content.replace(/([\\'\\\\\\\\])/g, \\'\\\\\\\\$1\\')\\n                .replace(/[\\\\f]/g, \\\"\\\\\\\\f\\\")\\n                .replace(/[\\\\b]/g, \\\"\\\\\\\\b\\\")\\n                .replace(/[\\\\n]/g, \\\"\\\\\\\\n\\\")\\n                .replace(/[\\\\t]/g, \\\"\\\\\\\\t\\\")\\n                .replace(/[\\\\r]/g, \\\"\\\\\\\\r\\\")\\n                .replace(/[\\\\u2028]/g, \\\"\\\\\\\\u2028\\\")\\n                .replace(/[\\\\u2029]/g, \\\"\\\\\\\\u2029\\\");\\n        },\\n\\n        createXhr: masterConfig.createXhr || function () {\\n            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.\\n            var xhr, i, progId;\\n            if (typeof XMLHttpRequest !== \\\"undefined\\\") {\\n                return new XMLHttpRequest();\\n            } else if (typeof ActiveXObject !== \\\"undefined\\\") {\\n                for (i = 0; i < 3; i += 1) {\\n                    progId = progIds[i];\\n                    try {\\n                        xhr = new ActiveXObject(progId);\\n                    } catch (e) {}\\n\\n                    if (xhr) {\\n                        progIds = [progId];  // so faster next time\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return xhr;\\n        },\\n\\n        /**\\n         * Parses a resource name into its component parts. Resource names\\n         * look like: module/name.ext!strip, where the !strip part is\\n         * optional.\\n         * @param {String} name the resource name\\n         * @returns {Object} with properties \\\"moduleName\\\", \\\"ext\\\" and \\\"strip\\\"\\n         * where strip is a boolean.\\n         */\\n        parseName: function (name) {\\n            var modName, ext, temp,\\n                strip = false,\\n                index = name.indexOf(\\\".\\\"),\\n                isRelative = name.indexOf(\\'./\\') === 0 ||\\n                             name.indexOf(\\'../\\') === 0;\\n\\n            if (index !== -1 && (!isRelative || index > 1)) {\\n                modName = name.substring(0, index);\\n                ext = name.substring(index + 1, name.length);\\n            } else {\\n                modName = name;\\n            }\\n\\n            temp = ext || modName;\\n            index = temp.indexOf(\\\"!\\\");\\n            if (index !== -1) {\\n                //Pull off the strip arg.\\n                strip = temp.substring(index + 1) === \\\"strip\\\";\\n                temp = temp.substring(0, index);\\n                if (ext) {\\n                    ext = temp;\\n                } else {\\n                    modName = temp;\\n                }\\n            }\\n\\n            return {\\n                moduleName: modName,\\n                ext: ext,\\n                strip: strip\\n            };\\n        },\\n\\n        xdRegExp: /^((\\\\w+)\\\\:)?\\\\/\\\\/([^\\\\/\\\\\\\\]+)/,\\n\\n        /**\\n         * Is an URL on another domain. Only works for browser use, returns\\n         * false in non-browser environments. Only used to know if an\\n         * optimized .js version of a text resource should be loaded\\n         * instead.\\n         * @param {String} url\\n         * @returns Boolean\\n         */\\n        useXhr: function (url, protocol, hostname, port) {\\n            var uProtocol, uHostName, uPort,\\n                match = text.xdRegExp.exec(url);\\n            if (!match) {\\n                return true;\\n            }\\n            uProtocol = match[2];\\n            uHostName = match[3];\\n\\n            uHostName = uHostName.split(\\':\\');\\n            uPort = uHostName[1];\\n            uHostName = uHostName[0];\\n\\n            return (!uProtocol || uProtocol === protocol) &&\\n                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&\\n                   ((!uPort && !uHostName) || uPort === port);\\n        },\\n\\n        finishLoad: function (name, strip, content, onLoad) {\\n            content = strip ? text.strip(content) : content;\\n            if (masterConfig.isBuild) {\\n                buildMap[name] = content;\\n            }\\n            onLoad(content);\\n        },\\n\\n        load: function (name, req, onLoad, config) {\\n            //Name has format: some.module.filext!strip\\n            //The strip part is optional.\\n            //if strip is present, then that means only get the string contents\\n            //inside a body tag in an HTML string. For XML/SVG content it means\\n            //removing the <?xml ...?> declarations so the content can be inserted\\n            //into the current doc without problems.\\n\\n            // Do not bother with the work if a build and text will\\n            // not be inlined.\\n            if (config.isBuild && !config.inlineText) {\\n                onLoad();\\n                return;\\n            }\\n\\n            masterConfig.isBuild = config.isBuild;\\n\\n            var parsed = text.parseName(name),\\n                nonStripName = parsed.moduleName +\\n                    (parsed.ext ? \\'.\\' + parsed.ext : \\'\\'),\\n                url = req.toUrl(nonStripName),\\n                useXhr = (masterConfig.useXhr) ||\\n                         text.useXhr;\\n\\n            // Do not load if it is an empty: url\\n            if (url.indexOf(\\'empty:\\') === 0) {\\n                onLoad();\\n                return;\\n            }\\n\\n            //Load the text. Use XHR if possible and in a browser.\\n            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {\\n                text.get(url, function (content) {\\n                    text.finishLoad(name, parsed.strip, content, onLoad);\\n                }, function (err) {\\n                    if (onLoad.error) {\\n                        onLoad.error(err);\\n                    }\\n                });\\n            } else {\\n                //Need to fetch the resource across domains. Assume\\n                //the resource has been optimized into a JS module. Fetch\\n                //by the module name + extension, but do not include the\\n                //!strip part to avoid file system issues.\\n                req([nonStripName], function (content) {\\n                    text.finishLoad(parsed.moduleName + \\'.\\' + parsed.ext,\\n                                    parsed.strip, content, onLoad);\\n                });\\n            }\\n        },\\n\\n        write: function (pluginName, moduleName, write, config) {\\n            if (buildMap.hasOwnProperty(moduleName)) {\\n                var content = text.jsEscape(buildMap[moduleName]);\\n                write.asModule(pluginName + \\\"!\\\" + moduleName,\\n                               \\\"define(function () { return \\'\\\" +\\n                                   content +\\n                               \\\"\\';});\\\\n\\\");\\n            }\\n        },\\n\\n        writeFile: function (pluginName, moduleName, req, write, config) {\\n            var parsed = text.parseName(moduleName),\\n                extPart = parsed.ext ? \\'.\\' + parsed.ext : \\'\\',\\n                nonStripName = parsed.moduleName + extPart,\\n                //Use a \\'.js\\' file name so that it indicates it is a\\n                //script that can be loaded across domains.\\n                fileName = req.toUrl(parsed.moduleName + extPart) + \\'.js\\';\\n\\n            //Leverage own load() method to load plugin value, but only\\n            //write out values that do not have the strip argument,\\n            //to avoid any potential issues with ! in file names.\\n            text.load(nonStripName, req, function (value) {\\n                //Use own write() method to construct full module value.\\n                //But need to create shell that translates writeFile\\'s\\n                //write() to the right interface.\\n                var textWrite = function (contents) {\\n                    return write(fileName, contents);\\n                };\\n                textWrite.asModule = function (moduleName, contents) {\\n                    return write.asModule(moduleName, fileName, contents);\\n                };\\n\\n                text.write(pluginName, nonStripName, textWrite, config);\\n            }, config);\\n        }\\n    };\\n\\n    if (masterConfig.env === \\'node\\' || (!masterConfig.env &&\\n            typeof process !== \\\"undefined\\\" &&\\n            process.versions &&\\n            !!process.versions.node &&\\n            !process.versions[\\'node-webkit\\'])) {\\n        //Using special require.nodeRequire, something added by r.js.\\n        fs = require.nodeRequire(\\'fs\\');\\n\\n        text.get = function (url, callback, errback) {\\n            try {\\n                var file = fs.readFileSync(url, \\'utf8\\');\\n                //Remove BOM (Byte Mark Order) from utf8 files if it is there.\\n                if (file.indexOf(\\'\\\\uFEFF\\') === 0) {\\n                    file = file.substring(1);\\n                }\\n                callback(file);\\n            } catch (e) {\\n                errback(e);\\n            }\\n        };\\n    } else if (masterConfig.env === \\'xhr\\' || (!masterConfig.env &&\\n            text.createXhr())) {\\n        text.get = function (url, callback, errback, headers) {\\n            var xhr = text.createXhr(), header;\\n            xhr.open(\\'GET\\', url, true);\\n\\n            //Allow plugins direct access to xhr headers\\n            if (headers) {\\n                for (header in headers) {\\n                    if (headers.hasOwnProperty(header)) {\\n                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);\\n                    }\\n                }\\n            }\\n\\n            //Allow overrides specified in config\\n            if (masterConfig.onXhr) {\\n                masterConfig.onXhr(xhr, url);\\n            }\\n\\n            xhr.onreadystatechange = function (evt) {\\n                var status, err;\\n                //Do not explicitly handle errors, those should be\\n                //visible via console output in the browser.\\n                if (xhr.readyState === 4) {\\n                    status = xhr.status;\\n                    if (status > 399 && status < 600) {\\n                        //An http 4xx or 5xx error. Signal an error.\\n                        err = new Error(url + \\' HTTP status: \\' + status);\\n                        err.xhr = xhr;\\n                        errback(err);\\n                    } else {\\n                        callback(xhr.responseText);\\n                    }\\n\\n                    if (masterConfig.onXhrComplete) {\\n                        masterConfig.onXhrComplete(xhr, url);\\n                    }\\n                }\\n            };\\n            xhr.send(null);\\n        };\\n    } else if (masterConfig.env === \\'rhino\\' || (!masterConfig.env &&\\n            typeof Packages !== \\'undefined\\' && typeof java !== \\'undefined\\')) {\\n        //Why Java, why is this so awkward?\\n        text.get = function (url, callback) {\\n            var stringBuffer, line,\\n                encoding = \\\"utf-8\\\",\\n                file = new java.io.File(url),\\n                lineSeparator = java.lang.System.getProperty(\\\"line.separator\\\"),\\n                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),\\n                content = \\'\\';\\n            try {\\n                stringBuffer = new java.lang.StringBuffer();\\n                line = input.readLine();\\n\\n                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324\\n                // http://www.unicode.org/faq/utf_bom.html\\n\\n                // Note that when we use utf-8, the BOM should appear as \\\"EF BB BF\\\", but it doesn\\'t due to this bug in the JDK:\\n                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058\\n                if (line && line.length() && line.charAt(0) === 0xfeff) {\\n                    // Eat the BOM, since we\\'ve already found the encoding on this file,\\n                    // and we plan to concatenating this buffer with others; the BOM should\\n                    // only appear at the top of a file.\\n                    line = line.substring(1);\\n                }\\n\\n                if (line !== null) {\\n                    stringBuffer.append(line);\\n                }\\n\\n                while ((line = input.readLine()) !== null) {\\n                    stringBuffer.append(lineSeparator);\\n                    stringBuffer.append(line);\\n                }\\n                //Make sure we return a JavaScript string and not a Java string.\\n                content = String(stringBuffer.toString()); //String\\n            } finally {\\n                input.close();\\n            }\\n            callback(content);\\n        };\\n    } else if (masterConfig.env === \\'xpconnect\\' || (!masterConfig.env &&\\n            typeof Components !== \\'undefined\\' && Components.classes &&\\n            Components.interfaces)) {\\n        //Avert your gaze!\\n        Cc = Components.classes,\\n        Ci = Components.interfaces;\\n        Components.utils[\\'import\\'](\\'resource://gre/modules/FileUtils.jsm\\');\\n        xpcIsWindows = (\\'@mozilla.org/windows-registry-key;1\\' in Cc);\\n\\n        text.get = function (url, callback) {\\n            var inStream, convertStream, fileObj,\\n                readData = {};\\n\\n            if (xpcIsWindows) {\\n                url = url.replace(/\\\\//g, \\'\\\\\\\\\\');\\n            }\\n\\n            fileObj = new FileUtils.File(url);\\n\\n            //XPCOM, you so crazy\\n            try {\\n                inStream = Cc[\\'@mozilla.org/network/file-input-stream;1\\']\\n                           .createInstance(Ci.nsIFileInputStream);\\n                inStream.init(fileObj, 1, 0, false);\\n\\n                convertStream = Cc[\\'@mozilla.org/intl/converter-input-stream;1\\']\\n                                .createInstance(Ci.nsIConverterInputStream);\\n                convertStream.init(inStream, \\\"utf-8\\\", inStream.available(),\\n                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);\\n\\n                convertStream.readString(inStream.available(), readData);\\n                convertStream.close();\\n                inStream.close();\\n                callback(readData.value);\\n            } catch (e) {\\n                throw new Error((fileObj && fileObj.path || \\'\\') + \\': \\' + e);\\n            }\\n        };\\n    }\\n    return text;\\n});\\n\\n//# sourceURL=/var/src/brackets/brackets-src/src/thirdparty/text/text.js\");\n\n","\neval(\"define(\\'text!data.json\\',[],function () { return \\'{\\\\n    \\\"htmlAttrs\\\": {\\\\n        \\\"href\\\":         { \\\"attribOption\\\": [] },\\\\n        \\\"src\\\":          { \\\"attribOption\\\": [] }\\\\n    }\\\\n}\\\\n\\';});\\n\\n//# sourceURL=/text!data.json\");\n\n","eval(\"/*\\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a\\n * copy of this software and associated documentation files (the \\\"Software\\\"),\\n * to deal in the Software without restriction, including without limitation\\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\\n * and/or sell copies of the Software, and to permit persons to whom the\\n * Software is furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in\\n * all copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\\n * DEALINGS IN THE SOFTWARE.\\n */\\n\\n/*jslint vars: true, plusplus: true, devel: true, nomen: true,  regexp: true, indent: 4, maxerr: 50 */\\n/*global define, brackets, $, window */\\n\\n\\ndefine(\\'main\\',[\\'require\\',\\'exports\\',\\'module\\',\\'text!data.json\\'],function (require, exports, module) {\\n    \\\"use strict\\\";\\n    \\n    // Brackets modules\\n    var AppInit         = brackets.getModule(\\\"utils/AppInit\\\"),\\n        CodeHintManager = brackets.getModule(\\\"editor/CodeHintManager\\\"),\\n        CSSUtils        = brackets.getModule(\\\"language/CSSUtils\\\"),\\n        FileSystem      = brackets.getModule(\\\"filesystem/FileSystem\\\"),\\n        FileUtils       = brackets.getModule(\\\"file/FileUtils\\\"),\\n        HTMLUtils       = brackets.getModule(\\\"language/HTMLUtils\\\"),\\n        ProjectManager  = brackets.getModule(\\\"project/ProjectManager\\\"),\\n        StringUtils     = brackets.getModule(\\\"utils/StringUtils\\\"),\\n\\n        Data            = require(\\\"text!data.json\\\"),\\n\\n        urlHints,\\n        data,\\n        htmlAttrs,\\n        styleModes      = [\\\"css\\\", \\\"text/x-less\\\", \\\"text/x-scss\\\"];\\n    \\n    /**\\n     * @constructor\\n     */\\n    function UrlCodeHints() {}\\n\\n    /**\\n     * Helper function to create a list of urls to existing files based on the query.\\n     * @param {{queryStr: string}} query -- a query object, used to filter the code hints\\n     *\\n     * @return {Array.<string>|$.Deferred} The (possibly deferred) hints.\\n     */\\n    UrlCodeHints.prototype._getUrlList = function (query) {\\n        var directory,\\n            doc,\\n            docDir,\\n            queryDir = \\\"\\\",\\n            queryUrl,\\n            result = [],\\n            self,\\n            targetDir,\\n            unfiltered = [];\\n\\n        doc = this.editor && this.editor.document;\\n        if (!doc || !doc.file) {\\n            return result;\\n        }\\n\\n        docDir = FileUtils.getDirectoryPath(doc.file.fullPath);\\n        \\n        // get relative path from query string\\n        queryUrl = window.PathUtils.parseUrl(query.queryStr);\\n        if (queryUrl) {\\n            queryDir = queryUrl.directory;\\n        }\\n\\n        // build target folder path\\n        if (queryDir.length > 0 && queryDir[0] === \\\"/\\\") {\\n            // site-root relative path\\n            targetDir = ProjectManager.getProjectRoot().fullPath +\\n                        decodeURI(queryDir).substring(1);\\n        } else {\\n            // page relative path\\n            targetDir = docDir + decodeURI(queryDir);\\n        }\\n\\n        // Get list of files from target folder. Getting the file/folder info is an\\n        // asynch operation, so it works like this:\\n        //\\n        // The initial pass initiates the asynchronous retrieval of data and returns an\\n        // empty list, so no code hints are displayed. In the async callback, the code\\n        // hints and the original query are stored in a cache, and then the process to\\n        // show code hints is re-initiated.\\n        //\\n        // During the next pass, there should now be code hints cached from the initial\\n        // pass, but user may have typed while file/folder info was being retrieved from\\n        // disk, so we need to make sure code hints still apply to current query. If so,\\n        // display them, otherwise, clear cache and start over.\\n        //\\n        // As user types within a folder, the same unfiltered file/folder list is still\\n        // valid and re-used from cache. Filtering based on user input is done outside\\n        // of this method. When user moves to a new folder, then the cache is deleted,\\n        // and file/folder info for new folder is then retrieved.\\n\\n        if (this.cachedHints) {\\n            // url hints have been cached, so determine if they\\'re stale\\n            if (!this.cachedHints.query ||\\n                    this.cachedHints.query.tag !== query.tag ||\\n                    this.cachedHints.query.attrName !== query.attrName ||\\n                    this.cachedHints.queryDir !== queryDir ||\\n                    this.cachedHints.docDir !== docDir) {\\n\\n                // delete stale cache\\n                this.cachedHints = null;\\n            }\\n        }\\n\\n        if (this.cachedHints) {\\n            // use cached hints\\n            unfiltered = this.cachedHints.unfiltered;\\n\\n        } else {\\n            directory = FileSystem.getDirectoryForPath(targetDir);\\n            self = this;\\n\\n            if (self.cachedHints && self.cachedHints.deferred) {\\n                self.cachedHints.deferred.reject();\\n            }\\n            // create empty object so we can detect \\\"waiting\\\" state\\n            self.cachedHints = {};\\n            self.cachedHints.deferred = $.Deferred();\\n            self.cachedHints.unfiltered = [];\\n\\n            directory.getContents(function (err, contents) {\\n                var currentDeferred, entryStr, syncResults;\\n\\n                if (!err) {\\n                    contents.forEach(function (entry) {\\n                        if (ProjectManager.shouldShow(entry)) {\\n                            // convert to doc relative path\\n                            entryStr = queryDir + entry._name;\\n                            if (entry._isDirectory) {\\n                                entryStr += \\\"/\\\";\\n                            }\\n\\n                            // code hints show the unencoded string so the\\n                            // choices are easier to read.  The encoded string\\n                            // will still be inserted into the editor.\\n                            unfiltered.push(entryStr);\\n                        }\\n                    });\\n\\n                    self.cachedHints.unfiltered = unfiltered;\\n                    self.cachedHints.query      = query;\\n                    self.cachedHints.queryDir   = queryDir;\\n                    self.cachedHints.docDir     = docDir;\\n                    \\n                    if (self.cachedHints.deferred.state() !== \\\"rejected\\\") {\\n                        currentDeferred = self.cachedHints.deferred;\\n\\n                        // Since we\\'ve cached the results, the next call to _getUrlList should be synchronous.\\n                        // If it isn\\'t, we\\'ve got a problem and should reject both the current deferred\\n                        // and any new deferred that got created on the call.\\n                        syncResults = self._getUrlList(query);\\n                        if (syncResults instanceof Array) {\\n                            currentDeferred.resolveWith(self, [syncResults]);\\n                        } else {\\n                            if (currentDeferred && currentDeferred.state() === \\\"pending\\\") {\\n                                currentDeferred.reject();\\n                            }\\n                            \\n                            if (self.cachedHints.deferred &&\\n                                    self.cachedHints.deferred.state() === \\\"pending\\\") {\\n                                self.cachedHints.deferred.reject();\\n                                self.cachedHints.deferred = null;\\n                            }\\n                        }\\n                    }\\n                }\\n            });\\n\\n            return self.cachedHints.deferred;\\n        }\\n\\n        // build list\\n\\n        // without these entries, typing \\\"../\\\" will not display entries for containing folder\\n        if (queryUrl.filename === \\\".\\\") {\\n            result.push(queryDir + \\\".\\\");\\n        } else if (queryUrl.filename === \\\"..\\\") {\\n            result.push(queryDir + \\\"..\\\");\\n        }\\n\\n        // add file/folder entries\\n        unfiltered.forEach(function (item) {\\n            result.push(item);\\n        });\\n\\n        // TODO: filter by desired file type based on tag, type attr, etc.\\n\\n        // TODO: add list item to top of list to popup modal File Finder dialog\\n        // New string: \\\"Browse...\\\" or \\\"Choose a File...\\\"\\n        // Command: Commands.FILE_OPEN\\n\\n        return result;\\n    };\\n\\n    /**\\n     * Helper function that determines the possible value hints for a given html tag/attribute name pair\\n     *\\n     * @param {{queryStr: string}} query\\n     * The current query\\n     *\\n     * @return {{hints: (Array.<string>|$.Deferred), sortFunc: ?function(string, string): number}}\\n     * The (possibly deferred) hints and the sort function to use on thise hints.\\n     */\\n    UrlCodeHints.prototype._getUrlHints = function (query) {\\n        var hints = [],\\n            sortFunc = null;\\n\\n        // Do not show hints after \\\"?\\\" in url\\n        if (query.queryStr.indexOf(\\\"?\\\") === -1) {\\n            \\n            // Default behavior for url hints is do not close on select.\\n            this.closeOnSelect = false;\\n            hints = this._getUrlList(query);\\n            sortFunc = StringUtils.urlSort;\\n        }\\n        \\n        return { hints: hints, sortFunc: sortFunc };\\n    };\\n    \\n    /**\\n     * Determines whether url hints are available in the current editor\\n     * context.\\n     *\\n     * @param {Editor} editor\\n     * A non-null editor object for the active window.\\n     *\\n     * @param {string} implicitChar\\n     * Either null, if the hinting request was explicit, or a single character\\n     * that represents the last insertion and that indicates an implicit\\n     * hinting request.\\n     *\\n     * @return {boolean}\\n     * Determines whether the current provider is able to provide hints for\\n     * the given editor context and, in case implicitChar is non-null,\\n     * whether it is appropriate to do so.\\n     */\\n    UrlCodeHints.prototype.hasHints = function (editor, implicitChar) {\\n        var mode = editor.getModeForSelection();\\n        if (mode === \\\"html\\\") {\\n            return this.hasHtmlHints(editor, implicitChar);\\n        } else if (styleModes.indexOf(mode) > -1) {\\n            return this.hasCssHints(editor, implicitChar);\\n        }\\n\\n        return false;\\n    };\\n\\n    /**\\n     * Helper function for hasHints() for CSS.\\n     *\\n     * @param {Editor} editor\\n     * A non-null editor object for the active window.\\n     *\\n     * @param {string} implicitChar\\n     * Either null, if the hinting request was explicit, or a single character\\n     * that represents the last insertion and that indicates an implicit\\n     * hinting request.\\n     *\\n     * @return {boolean}\\n     * Determines whether the current provider is able to provide hints for\\n     * the given editor context and, in case implicitChar is non-null,\\n     * whether it is appropriate to do so.\\n     */\\n    UrlCodeHints.prototype.hasCssHints = function (editor, implicitChar) {\\n        this.editor = editor;\\n        var cursor = this.editor.getCursorPos();\\n\\n        this.info = CSSUtils.getInfoAtPos(editor, cursor);\\n\\n        if (this.info.context !== CSSUtils.PROP_VALUE && this.info.context !== CSSUtils.IMPORT_URL) {\\n            return false;\\n        }\\n\\n        // collect existing value\\n        var i,\\n            val = \\\"\\\";\\n\\n        for (i = 0; i <= this.info.index && i < this.info.values.length; i++) {\\n            if (i < this.info.index) {\\n                val += this.info.values[i];\\n            } else {\\n                val += this.info.values[i].substring(0, this.info.offset);\\n            }\\n        }\\n        \\n        // starts with \\\"url(\\\" ?\\n        if (val.match(/^\\\\s*url\\\\(/i)) {\\n            return true;\\n        }\\n\\n        return false;\\n    };\\n\\n    /**\\n     * Helper function for hasHints() for HTML.\\n     *\\n     * @param {Editor} editor\\n     * A non-null editor object for the active window.\\n     *\\n     * @param {string} implicitChar\\n     * Either null, if the hinting request was explicit, or a single character\\n     * that represents the last insertion and that indicates an implicit\\n     * hinting request.\\n     *\\n     * @return {boolean}\\n     * Determines whether the current provider is able to provide hints for\\n     * the given editor context and, in case implicitChar is non-null,\\n     * whether it is appropriate to do so.\\n     */\\n    UrlCodeHints.prototype.hasHtmlHints = function (editor, implicitChar) {\\n        var tagInfo,\\n            query,\\n            tokenType;\\n\\n        this.editor = editor;\\n        \\n        tagInfo = HTMLUtils.getTagInfo(editor, editor.getCursorPos());\\n        query = null;\\n        tokenType = tagInfo.position.tokenType;\\n        \\n        if (tokenType === HTMLUtils.ATTR_VALUE) {\\n                \\n            // Verify that attribute name has hintable values\\n            if (htmlAttrs[tagInfo.attr.name]) {\\n                \\n                if (tagInfo.position.offset >= 0) {\\n                    query = tagInfo.attr.value.slice(0, tagInfo.position.offset);\\n                } else {\\n                    // We get negative offset for a quoted attribute value with some leading whitespaces\\n                    // as in <a rel= \\\"rtl\\\" where the cursor is just to the right of the \\\"=\\\".\\n                    // So just set the queryStr to an empty string.\\n                    query = \\\"\\\";\\n                }\\n                \\n                var hintsAndSortFunc = this._getUrlHints({queryStr: query}),\\n                    hints = hintsAndSortFunc.hints;\\n\\n                if (hints instanceof Array) {\\n                    // If we got synchronous hints, check if we have something we\\'ll actually use\\n                    var i, foundPrefix = false;\\n                    query = query.toLowerCase();\\n                    for (i = 0; i < hints.length; i++) {\\n                        if (hints[i].toLowerCase().indexOf(query) === 0) {\\n                            foundPrefix = true;\\n                            break;\\n                        }\\n                    }\\n\\n                    if (!foundPrefix) {\\n                        query = null;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return (query !== null);\\n    };\\n\\n    /**\\n     * Returns a list of available url hints, if possible, for the current\\n     * editor context.\\n     *\\n     * @return {jQuery.Deferred|{\\n     *              hints: Array.<string|jQueryObject>,\\n     *              match: string,\\n     *              selectInitial: boolean,\\n     *              handleWideResults: boolean}}\\n     * Null if the provider wishes to end the hinting session. Otherwise, a\\n     * response object that provides\\n     * 1. a sorted array hints that consists of strings\\n     * 2. a string match that is used by the manager to emphasize matching\\n     *    substrings when rendering the hint list\\n     * 3. a boolean that indicates whether the first result, if one exists, should be\\n     *    selected by default in the hint list window.\\n     * 4. handleWideResults, a boolean (or undefined) that indicates whether\\n     *    to allow result string to stretch width of display.\\n     */\\n    UrlCodeHints.prototype.getHints = function (key) {\\n        var mode = this.editor.getModeForSelection(),\\n            cursor = this.editor.getCursorPos(),\\n            filter = \\\"\\\",\\n            hints = [],\\n            sortFunc = null,\\n            query = { queryStr: \\\"\\\" },\\n            result = [];\\n\\n        if (mode === \\\"html\\\") {\\n            var tagInfo = HTMLUtils.getTagInfo(this.editor, cursor),\\n                tokenType = tagInfo.position.tokenType;\\n\\n            if (tokenType !== HTMLUtils.ATTR_VALUE || !htmlAttrs[tagInfo.attr.name]) {\\n                return null;\\n            }\\n            \\n            if (tagInfo.position.offset >= 0) {\\n                query.queryStr = tagInfo.attr.value.slice(0, tagInfo.position.offset);\\n            }\\n            this.info = tagInfo;\\n\\n        } else if (styleModes.indexOf(mode) > -1) {\\n            this.info = CSSUtils.getInfoAtPos(this.editor, cursor);\\n\\n            var context = this.info.context;\\n            if (context !== CSSUtils.PROP_VALUE && context !== CSSUtils.IMPORT_URL) {\\n                return null;\\n            }\\n\\n            // Cursor is in an existing property value or partially typed value\\n            if (this.info.index !== -1) {\\n\\n                // Collect value up to (item) index/(char) offset\\n                var i, val = \\\"\\\";\\n                for (i = 0; i < this.info.index; i++) {\\n                    val += this.info.values[i];\\n                }\\n                // index may exceed length of array for multiple-value case\\n                if (this.info.index < this.info.values.length) {\\n                    val += this.info.values[this.info.index].substr(0, this.info.offset);\\n                }\\n\\n                // Strip \\\"url(\\\"\\n                val = val.replace(/^\\\\s*url\\\\(/i, \\\"\\\");\\n\\n                // Keep track of leading whitespace and strip it\\n                var matchWhitespace = val.match(/^\\\\s*/);\\n                if (matchWhitespace) {\\n                    this.info.leadingWhitespace = matchWhitespace[0];\\n                    val = val.substring(matchWhitespace[0].length);\\n                } else {\\n                    this.info.leadingWhitespace = null;\\n                }\\n                \\n                // Keep track of opening quote and strip it\\n                if (val.match(/^[\\\"\\']/)) {\\n                    this.info.openingQuote = val[0];\\n                    val = val.substring(1);\\n                } else {\\n                    this.info.openingQuote = null;\\n                }\\n\\n                query.queryStr = val;\\n            }\\n\\n        } else {\\n            return null;\\n        }\\n\\n        if (query.queryStr !== null) {\\n            filter = query.queryStr;\\n            var hintsAndSortFunc = this._getUrlHints(query);\\n            hints = hintsAndSortFunc.hints;\\n            sortFunc = hintsAndSortFunc.sortFunc;\\n        }\\n        this.info.filter = filter;\\n\\n        if (hints instanceof Array && hints.length) {\\n            // Array was returned\\n            var lowerCaseFilter = filter.toLowerCase();\\n            console.assert(!result.length);\\n            result = $.map(hints, function (item) {\\n                if (item.toLowerCase().indexOf(lowerCaseFilter) === 0) {\\n                    return item;\\n                }\\n            }).sort(sortFunc);\\n\\n            return {\\n                hints: result,\\n                match: query.queryStr,\\n                selectInitial: true,\\n                handleWideResults: false\\n            };\\n\\n        } else if (hints instanceof Object && hints.hasOwnProperty(\\\"done\\\")) {\\n            // Deferred hints were returned\\n            var deferred = $.Deferred();\\n            hints.done(function (asyncHints) {\\n                var lowerCaseFilter = filter.toLowerCase();\\n                result = $.map(asyncHints, function (item) {\\n                    if (item.toLowerCase().indexOf(lowerCaseFilter) === 0) {\\n                        return item;\\n                    }\\n                }).sort(sortFunc);\\n\\n                deferred.resolveWith(this, [{\\n                    hints: result,\\n                    match: query.queryStr,\\n                    selectInitial: true,\\n                    handleWideResults: false\\n                }]);\\n            });\\n\\n            return deferred;\\n        }\\n\\n        return null;\\n    };\\n\\n    /**\\n     * Inserts a given url hint into the current editor context.\\n     *\\n     * @param {jQuery.Object} completion\\n     * The hint to be inserted into the editor context.\\n     *\\n     * @return {boolean}\\n     * Indicates whether the manager should follow hint insertion with an\\n     * additional explicit hint request.\\n     */\\n    UrlCodeHints.prototype.insertHint = function (completion) {\\n        var mode = this.editor.getModeForSelection();\\n        \\n        // Encode the string just prior to inserting the hint into the editor\\n        completion = encodeURI(completion);\\n        \\n        if (mode === \\\"html\\\") {\\n            return this.insertHtmlHint(completion);\\n        } else if (styleModes.indexOf(mode) > -1) {\\n            return this.insertCssHint(completion);\\n        }\\n\\n        return false;\\n    };\\n\\n    /**\\n     * Get distance between 2 positions.\\n     *\\n     * Assumption: pos2 >= pos1\\n     *\\n     * Note that this function is designed to work on CSSUtils info.values array,\\n     * so this could be made a method if that is converted to an object.\\n     *\\n     * @param {Array.<string>}  array  - strings to be searched\\n     * @param {{index: number, offset: number}} pos1 - starting index/offset in index string\\n     * @param {{index: number, offset: number}} pos2 - ending index/offset in index string\\n     *\\n     * @return {number}\\n     * Number of characters between 2 positions\\n     */\\n    UrlCodeHints.prototype.getCharOffset = function (array, pos1, pos2) {\\n        var i, count = 0;\\n        \\n        if (pos1.index === pos2.index) {\\n            return (pos2.offset >= pos1.offset) ? (pos2.offset - pos1.offset) : 0;\\n        } else if (pos1.index < pos2.index) {\\n            if (pos1.index < 0 || pos1.index >= array.length || pos2.index < 0 || pos2.index >= array.length) {\\n                return 0;\\n            }\\n            \\n            for (i = pos1.index; i <= pos2.index; i++) {\\n                if (i === pos1.index) {\\n                    count += (array[i].length - pos1.offset);\\n                } else if (i === pos2.index) {\\n                    count += pos2.offset;\\n                } else {\\n                    count += array[i].length;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    };\\n\\n    /**\\n     * Finds next position in array of specified char.\\n     *\\n     * Note that this function is designed to work on CSSUtils info.values array,\\n     * so this could be made a method if that is converted to an object.\\n     *\\n     * @param {Array}  array - strings to be searched\\n     * @param {string} ch    - char to search for\\n     * @param {{index: number, offset: number}} pos - starting index/offset in index string\\n     *\\n     * @return {{index: number, offset: number}}\\n     * Index of array, and offset in string where char found.\\n     */\\n    UrlCodeHints.prototype.findNextPosInArray = function (array, ch, pos) {\\n        var i, o, searchOffset;\\n        for (i = pos.index; i < array.length; i++) {\\n            // Only use offset on index, then offset of 0 after that\\n            searchOffset = (i === pos.index) ? pos.offset : 0;\\n            o = array[i].indexOf(ch, searchOffset);\\n            \\n            if (o !== -1) {\\n                return { index: i, offset: o };\\n            }\\n        }\\n        return { index: -1, offset: -1 };\\n    };\\n\\n    /**\\n     * Inserts a given css url hint into the current editor context.\\n     *\\n     * @param {jQuery.Object} completion\\n     * The hint to be inserted into the editor context.\\n     *\\n     * @return {boolean}\\n     * Indicates whether the manager should follow hint insertion with an\\n     * additional explicit hint request.\\n     */\\n    UrlCodeHints.prototype.insertCssHint = function (completion) {\\n        var cursor = this.editor.getCursorPos(),\\n            start  = { line: cursor.line, ch: cursor.ch },\\n            end    = { line: cursor.line, ch: cursor.ch };\\n\\n        var hasClosingQuote = false,\\n            hasClosingParen = false,\\n            insertText      = completion,\\n            moveLen         = 0,\\n            closingPos      = { index: -1, offset: -1 },\\n            searchResult    = { index: -1, offset: -1 };\\n\\n        if (this.info.context !== CSSUtils.PROP_VALUE && this.info.context !== CSSUtils.IMPORT_URL) {\\n            return false;\\n        }\\n\\n        // Special handling for URL hinting -- if the completion is a file name\\n        // and not a folder, then close the code hint list.\\n        if (!this.closeOnSelect && completion.match(/\\\\/$/) === null) {\\n            this.closeOnSelect = true;\\n        }\\n\\n        // Look for optional closing quote\\n        if (this.info.openingQuote) {\\n            closingPos = this.findNextPosInArray(this.info.values, this.info.openingQuote, this.info);\\n            hasClosingQuote = (closingPos.index !== -1);\\n        }\\n\\n        // Look for closing paren\\n        if (hasClosingQuote) {\\n            searchResult = this.findNextPosInArray(this.info.values, \\\")\\\", closingPos);\\n            hasClosingParen = (searchResult.index !== -1);\\n        } else {\\n            // index may exceed length of array for multiple-value case\\n            closingPos = this.findNextPosInArray(this.info.values, \\\")\\\", this.info);\\n            hasClosingParen = (closingPos.index !== -1);\\n        }\\n\\n        // Insert folder names, but replace file names, so if a file is selected\\n        // (i.e. closeOnSelect === true), then adjust insert char positions to\\n        // replace existing value, if there is a closing paren\\n        if (this.closeOnSelect) {\\n            if (closingPos.index !== -1) {\\n                end.ch += this.getCharOffset(this.info.values, this.info, closingPos);\\n            }\\n        } else {\\n            // If next char is \\\"/\\\", then overwrite it since we\\'re inserting a \\\"/\\\"\\n            var nextSlash = this.findNextPosInArray(this.info.values, \\\"/\\\", this.info);\\n            if (nextSlash.index === this.info.index && nextSlash.offset === this.info.offset) {\\n                end.ch += 1;\\n            }\\n        }\\n        if (this.info.filter.length > 0) {\\n            start.ch -= this.info.filter.length;\\n        }\\n\\n        // Append matching quote, whitespace, paren\\n        if (this.info.openingQuote && !hasClosingQuote) {\\n            insertText += this.info.openingQuote;\\n        }\\n        if (!hasClosingParen) {\\n            // Add trailing whitespace to match leading whitespace\\n            if (this.info.leadingWhitespace) {\\n                insertText += this.info.leadingWhitespace;\\n            }\\n            insertText += \\\")\\\";\\n        }\\n\\n        // HACK (tracking adobe/brackets#1688): We talk to the private CodeMirror instance\\n        // directly to replace the range instead of using the Document, as we should. The\\n        // reason is due to a flaw in our current document synchronization architecture when\\n        // inline editors are open.\\n        this.editor._codeMirror.replaceRange(insertText, start, end);\\n\\n        // Adjust cursor position\\n        if (this.closeOnSelect) {\\n            // If there is existing closing quote and/or paren, move the cursor past them\\n            moveLen = (hasClosingQuote ? 1 : 0) + (hasClosingParen ? 1 : 0);\\n            if (moveLen > 0) {\\n                this.editor.setCursorPos(start.line, start.ch + completion.length + moveLen);\\n            }\\n            return false;\\n\\n        } else {\\n            // If closing quote and/or paren are added, move the cursor to where it would have been\\n            moveLen = ((this.info.openingQuote && !hasClosingQuote) ? 1 : 0) + (!hasClosingParen ? 1 : 0);\\n            if (moveLen > 0) {\\n                this.editor.setCursorPos(start.line, start.ch + completion.length);\\n            }\\n        }\\n\\n        return true;\\n    };\\n\\n    /**\\n     * Inserts a given html url hint into the current editor context.\\n     *\\n     * @param {jQuery.Object} completion\\n     * The hint to be inserted into the editor context.\\n     *\\n     * @return {boolean}\\n     * Indicates whether the manager should follow hint insertion with an\\n     * additional explicit hint request.\\n     */\\n    UrlCodeHints.prototype.insertHtmlHint = function (completion) {\\n        var cursor = this.editor.getCursorPos(),\\n            start = {line: -1, ch: -1},\\n            end = {line: -1, ch: -1},\\n            tagInfo = HTMLUtils.getTagInfo(this.editor, cursor),\\n            tokenType = tagInfo.position.tokenType,\\n            charCount = 0,\\n            endQuote = \\\"\\\",\\n            shouldReplace = false;\\n\\n        if (tokenType === HTMLUtils.ATTR_VALUE) {\\n            // Special handling for URL hinting -- if the completion is a file name\\n            // and not a folder, then close the code hint list.\\n            if (!this.closeOnSelect && completion.match(/\\\\/$/) === null) {\\n                this.closeOnSelect = true;\\n\\n                // Insert folder names, but replace file names\\n                shouldReplace = true;\\n            }\\n            \\n            if (!tagInfo.attr.hasEndQuote) {\\n                endQuote = tagInfo.attr.quoteChar;\\n                if (endQuote) {\\n                    completion += endQuote;\\n                } else if (tagInfo.position.offset === 0) {\\n                    completion = \\\"\\\\\\\"\\\" + completion + \\\"\\\\\\\"\\\";\\n                }\\n            } else if (completion === tagInfo.attr.value) {\\n                shouldReplace = false;\\n            }\\n\\n            if (shouldReplace) {\\n                // Replace entire value\\n                charCount = tagInfo.attr.value.length;\\n            } else {\\n                // Replace filter (to insert new selection)\\n                charCount = this.info.filter.length;\\n\\n                // If next char is \\\"/\\\", then overwrite it since we\\'re inserting a \\\"/\\\"\\n                if (this.info.attr.value.length > charCount && this.info.attr.value[charCount] === \\\"/\\\") {\\n                    charCount += 1;\\n                }\\n            }\\n        }\\n\\n        end.line = start.line = cursor.line;\\n        start.ch = cursor.ch - tagInfo.position.offset;\\n        end.ch = start.ch + charCount;\\n\\n        this.editor.document.replaceRange(completion, start, end);\\n\\n        if (!this.closeOnSelect) {\\n            // If we append the missing quote, then we need to adjust the cursor postion\\n            // to keep the code hint list open.\\n            if (tokenType === HTMLUtils.ATTR_VALUE && !tagInfo.attr.hasEndQuote) {\\n                this.editor.setCursorPos(start.line, start.ch + completion.length - 1);\\n            }\\n            return true;\\n        }\\n        \\n        if (tokenType === HTMLUtils.ATTR_VALUE && tagInfo.attr.hasEndQuote) {\\n            // Move the cursor to the right of the existing end quote after value insertion.\\n            this.editor.setCursorPos(start.line, start.ch + completion.length + 1);\\n        }\\n        \\n        return false;\\n    };\\n\\n    function _clearCachedHints() {\\n        // Verify cache exists and is not deferred\\n        if (urlHints && urlHints.cachedHints && urlHints.cachedHints.deferred &&\\n                urlHints.cachedHints.deferred.state() !== \\\"pending\\\") {\\n\\n            // Cache may or may not be stale. Main benefit of cache is to limit async lookups\\n            // during typing. File tree updates cannot happen during typing, so it\\'s probably\\n            // not worth determining whether cache may still be valid. Just delete it.\\n            urlHints.cachedHints = null;\\n        }\\n    }\\n        \\n    AppInit.appReady(function () {\\n        data            = JSON.parse(Data);\\n        htmlAttrs       = data.htmlAttrs;\\n\\n        urlHints        = new UrlCodeHints();\\n        CodeHintManager.registerHintProvider(urlHints, [\\\"css\\\", \\\"html\\\", \\\"less\\\", \\\"scss\\\"], 5);\\n        \\n        FileSystem.on(\\\"change\\\", _clearCachedHints);\\n        FileSystem.on(\\\"rename\\\", _clearCachedHints);\\n\\n        // For unit testing\\n        exports.hintProvider = urlHints;\\n    });\\n});\\n\\n//# sourceURL=/main.js\");\n\n"]}