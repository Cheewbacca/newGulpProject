eval("/**\n * @license RequireJS text 2.0.10 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/requirejs/text for details\n */\n/*jslint regexp: true */\n/*global require, XMLHttpRequest, ActiveXObject,\n  define, window, process, Packages,\n  java, location, Components, FileUtils */\n\ndefine('text',['module'], function (module) {\n    'use strict';\n\n    var text, fs, Cc, Ci, xpcIsWindows,\n        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],\n        xmlRegExp = /^\\s*<\\?xml(\\s)+version=[\\'\\\"](\\d)*.(\\d)*[\\'\\\"](\\s)*\\?>/im,\n        bodyRegExp = /<body[^>]*>\\s*([\\s\\S]+)\\s*<\\/body>/im,\n        hasLocation = typeof location !== 'undefined' && location.href,\n        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\\:/, ''),\n        defaultHostName = hasLocation && location.hostname,\n        defaultPort = hasLocation && (location.port || undefined),\n        buildMap = {},\n        masterConfig = (module.config && module.config()) || {};\n\n    text = {\n        version: '2.0.10',\n\n        strip: function (content) {\n            //Strips <?xml ...?> declarations so that external SVG and XML\n            //documents can be added to a document without worry. Also, if the string\n            //is an HTML document, only the part inside the body tag is returned.\n            if (content) {\n                content = content.replace(xmlRegExp, \"\");\n                var matches = content.match(bodyRegExp);\n                if (matches) {\n                    content = matches[1];\n                }\n            } else {\n                content = \"\";\n            }\n            return content;\n        },\n\n        jsEscape: function (content) {\n            return content.replace(/(['\\\\])/g, '\\\\$1')\n                .replace(/[\\f]/g, \"\\\\f\")\n                .replace(/[\\b]/g, \"\\\\b\")\n                .replace(/[\\n]/g, \"\\\\n\")\n                .replace(/[\\t]/g, \"\\\\t\")\n                .replace(/[\\r]/g, \"\\\\r\")\n                .replace(/[\\u2028]/g, \"\\\\u2028\")\n                .replace(/[\\u2029]/g, \"\\\\u2029\");\n        },\n\n        createXhr: masterConfig.createXhr || function () {\n            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.\n            var xhr, i, progId;\n            if (typeof XMLHttpRequest !== \"undefined\") {\n                return new XMLHttpRequest();\n            } else if (typeof ActiveXObject !== \"undefined\") {\n                for (i = 0; i < 3; i += 1) {\n                    progId = progIds[i];\n                    try {\n                        xhr = new ActiveXObject(progId);\n                    } catch (e) {}\n\n                    if (xhr) {\n                        progIds = [progId];  // so faster next time\n                        break;\n                    }\n                }\n            }\n\n            return xhr;\n        },\n\n        /**\n         * Parses a resource name into its component parts. Resource names\n         * look like: module/name.ext!strip, where the !strip part is\n         * optional.\n         * @param {String} name the resource name\n         * @returns {Object} with properties \"moduleName\", \"ext\" and \"strip\"\n         * where strip is a boolean.\n         */\n        parseName: function (name) {\n            var modName, ext, temp,\n                strip = false,\n                index = name.indexOf(\".\"),\n                isRelative = name.indexOf('./') === 0 ||\n                             name.indexOf('../') === 0;\n\n            if (index !== -1 && (!isRelative || index > 1)) {\n                modName = name.substring(0, index);\n                ext = name.substring(index + 1, name.length);\n            } else {\n                modName = name;\n            }\n\n            temp = ext || modName;\n            index = temp.indexOf(\"!\");\n            if (index !== -1) {\n                //Pull off the strip arg.\n                strip = temp.substring(index + 1) === \"strip\";\n                temp = temp.substring(0, index);\n                if (ext) {\n                    ext = temp;\n                } else {\n                    modName = temp;\n                }\n            }\n\n            return {\n                moduleName: modName,\n                ext: ext,\n                strip: strip\n            };\n        },\n\n        xdRegExp: /^((\\w+)\\:)?\\/\\/([^\\/\\\\]+)/,\n\n        /**\n         * Is an URL on another domain. Only works for browser use, returns\n         * false in non-browser environments. Only used to know if an\n         * optimized .js version of a text resource should be loaded\n         * instead.\n         * @param {String} url\n         * @returns Boolean\n         */\n        useXhr: function (url, protocol, hostname, port) {\n            var uProtocol, uHostName, uPort,\n                match = text.xdRegExp.exec(url);\n            if (!match) {\n                return true;\n            }\n            uProtocol = match[2];\n            uHostName = match[3];\n\n            uHostName = uHostName.split(':');\n            uPort = uHostName[1];\n            uHostName = uHostName[0];\n\n            return (!uProtocol || uProtocol === protocol) &&\n                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&\n                   ((!uPort && !uHostName) || uPort === port);\n        },\n\n        finishLoad: function (name, strip, content, onLoad) {\n            content = strip ? text.strip(content) : content;\n            if (masterConfig.isBuild) {\n                buildMap[name] = content;\n            }\n            onLoad(content);\n        },\n\n        load: function (name, req, onLoad, config) {\n            //Name has format: some.module.filext!strip\n            //The strip part is optional.\n            //if strip is present, then that means only get the string contents\n            //inside a body tag in an HTML string. For XML/SVG content it means\n            //removing the <?xml ...?> declarations so the content can be inserted\n            //into the current doc without problems.\n\n            // Do not bother with the work if a build and text will\n            // not be inlined.\n            if (config.isBuild && !config.inlineText) {\n                onLoad();\n                return;\n            }\n\n            masterConfig.isBuild = config.isBuild;\n\n            var parsed = text.parseName(name),\n                nonStripName = parsed.moduleName +\n                    (parsed.ext ? '.' + parsed.ext : ''),\n                url = req.toUrl(nonStripName),\n                useXhr = (masterConfig.useXhr) ||\n                         text.useXhr;\n\n            // Do not load if it is an empty: url\n            if (url.indexOf('empty:') === 0) {\n                onLoad();\n                return;\n            }\n\n            //Load the text. Use XHR if possible and in a browser.\n            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {\n                text.get(url, function (content) {\n                    text.finishLoad(name, parsed.strip, content, onLoad);\n                }, function (err) {\n                    if (onLoad.error) {\n                        onLoad.error(err);\n                    }\n                });\n            } else {\n                //Need to fetch the resource across domains. Assume\n                //the resource has been optimized into a JS module. Fetch\n                //by the module name + extension, but do not include the\n                //!strip part to avoid file system issues.\n                req([nonStripName], function (content) {\n                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,\n                                    parsed.strip, content, onLoad);\n                });\n            }\n        },\n\n        write: function (pluginName, moduleName, write, config) {\n            if (buildMap.hasOwnProperty(moduleName)) {\n                var content = text.jsEscape(buildMap[moduleName]);\n                write.asModule(pluginName + \"!\" + moduleName,\n                               \"define(function () { return '\" +\n                                   content +\n                               \"';});\\n\");\n            }\n        },\n\n        writeFile: function (pluginName, moduleName, req, write, config) {\n            var parsed = text.parseName(moduleName),\n                extPart = parsed.ext ? '.' + parsed.ext : '',\n                nonStripName = parsed.moduleName + extPart,\n                //Use a '.js' file name so that it indicates it is a\n                //script that can be loaded across domains.\n                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';\n\n            //Leverage own load() method to load plugin value, but only\n            //write out values that do not have the strip argument,\n            //to avoid any potential issues with ! in file names.\n            text.load(nonStripName, req, function (value) {\n                //Use own write() method to construct full module value.\n                //But need to create shell that translates writeFile's\n                //write() to the right interface.\n                var textWrite = function (contents) {\n                    return write(fileName, contents);\n                };\n                textWrite.asModule = function (moduleName, contents) {\n                    return write.asModule(moduleName, fileName, contents);\n                };\n\n                text.write(pluginName, nonStripName, textWrite, config);\n            }, config);\n        }\n    };\n\n    if (masterConfig.env === 'node' || (!masterConfig.env &&\n            typeof process !== \"undefined\" &&\n            process.versions &&\n            !!process.versions.node &&\n            !process.versions['node-webkit'])) {\n        //Using special require.nodeRequire, something added by r.js.\n        fs = require.nodeRequire('fs');\n\n        text.get = function (url, callback, errback) {\n            try {\n                var file = fs.readFileSync(url, 'utf8');\n                //Remove BOM (Byte Mark Order) from utf8 files if it is there.\n                if (file.indexOf('\\uFEFF') === 0) {\n                    file = file.substring(1);\n                }\n                callback(file);\n            } catch (e) {\n                errback(e);\n            }\n        };\n    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&\n            text.createXhr())) {\n        text.get = function (url, callback, errback, headers) {\n            var xhr = text.createXhr(), header;\n            xhr.open('GET', url, true);\n\n            //Allow plugins direct access to xhr headers\n            if (headers) {\n                for (header in headers) {\n                    if (headers.hasOwnProperty(header)) {\n                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);\n                    }\n                }\n            }\n\n            //Allow overrides specified in config\n            if (masterConfig.onXhr) {\n                masterConfig.onXhr(xhr, url);\n            }\n\n            xhr.onreadystatechange = function (evt) {\n                var status, err;\n                //Do not explicitly handle errors, those should be\n                //visible via console output in the browser.\n                if (xhr.readyState === 4) {\n                    status = xhr.status;\n                    if (status > 399 && status < 600) {\n                        //An http 4xx or 5xx error. Signal an error.\n                        err = new Error(url + ' HTTP status: ' + status);\n                        err.xhr = xhr;\n                        errback(err);\n                    } else {\n                        callback(xhr.responseText);\n                    }\n\n                    if (masterConfig.onXhrComplete) {\n                        masterConfig.onXhrComplete(xhr, url);\n                    }\n                }\n            };\n            xhr.send(null);\n        };\n    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&\n            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {\n        //Why Java, why is this so awkward?\n        text.get = function (url, callback) {\n            var stringBuffer, line,\n                encoding = \"utf-8\",\n                file = new java.io.File(url),\n                lineSeparator = java.lang.System.getProperty(\"line.separator\"),\n                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),\n                content = '';\n            try {\n                stringBuffer = new java.lang.StringBuffer();\n                line = input.readLine();\n\n                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324\n                // http://www.unicode.org/faq/utf_bom.html\n\n                // Note that when we use utf-8, the BOM should appear as \"EF BB BF\", but it doesn't due to this bug in the JDK:\n                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058\n                if (line && line.length() && line.charAt(0) === 0xfeff) {\n                    // Eat the BOM, since we've already found the encoding on this file,\n                    // and we plan to concatenating this buffer with others; the BOM should\n                    // only appear at the top of a file.\n                    line = line.substring(1);\n                }\n\n                if (line !== null) {\n                    stringBuffer.append(line);\n                }\n\n                while ((line = input.readLine()) !== null) {\n                    stringBuffer.append(lineSeparator);\n                    stringBuffer.append(line);\n                }\n                //Make sure we return a JavaScript string and not a Java string.\n                content = String(stringBuffer.toString()); //String\n            } finally {\n                input.close();\n            }\n            callback(content);\n        };\n    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&\n            typeof Components !== 'undefined' && Components.classes &&\n            Components.interfaces)) {\n        //Avert your gaze!\n        Cc = Components.classes,\n        Ci = Components.interfaces;\n        Components.utils['import']('resource://gre/modules/FileUtils.jsm');\n        xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);\n\n        text.get = function (url, callback) {\n            var inStream, convertStream, fileObj,\n                readData = {};\n\n            if (xpcIsWindows) {\n                url = url.replace(/\\//g, '\\\\');\n            }\n\n            fileObj = new FileUtils.File(url);\n\n            //XPCOM, you so crazy\n            try {\n                inStream = Cc['@mozilla.org/network/file-input-stream;1']\n                           .createInstance(Ci.nsIFileInputStream);\n                inStream.init(fileObj, 1, 0, false);\n\n                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']\n                                .createInstance(Ci.nsIConverterInputStream);\n                convertStream.init(inStream, \"utf-8\", inStream.available(),\n                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);\n\n                convertStream.readString(inStream.available(), readData);\n                convertStream.close();\n                inStream.close();\n                callback(readData.value);\n            } catch (e) {\n                throw new Error((fileObj && fileObj.path || '') + ': ' + e);\n            }\n        };\n    }\n    return text;\n});\n\n//# sourceURL=/var/src/brackets/brackets-src/src/thirdparty/text/text.js"),eval("define('text!QuickViewTemplate.html',[],function () { return '<div id=\"quick-view-container\">\\n    <div class=\"preview-content\">\\n    </div>\\n</div>';});\n\n//# sourceURL=/text!QuickViewTemplate.html"),eval('/*\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n *  \n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the "Software"), \n * to deal in the Software without restriction, including without limitation \n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \n * and/or sell copies of the Software, and to permit persons to whom the \n * Software is furnished to do so, subject to the following conditions:\n *  \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *  \n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \n * DEALINGS IN THE SOFTWARE.\n * \n */\n\n/*jslint vars: true, plusplus: true, devel: true, nomen: true,  regexp: true, indent: 4, maxerr: 50 */\n/*global define, brackets, $, window, PathUtils */\n\ndefine(\'main\',[\'require\',\'exports\',\'module\',\'text!QuickViewTemplate.html\'],function (require, exports, module) {\n    "use strict";\n    \n    // Brackets modules\n    var ColorUtils          = brackets.getModule("utils/ColorUtils"),\n        CommandManager      = brackets.getModule("command/CommandManager"),\n        Commands            = brackets.getModule("command/Commands"),\n        CSSUtils            = brackets.getModule("language/CSSUtils"),\n        EditorManager       = brackets.getModule("editor/EditorManager"),\n        ExtensionUtils      = brackets.getModule("utils/ExtensionUtils"),\n        FileUtils           = brackets.getModule("file/FileUtils"),\n        Menus               = brackets.getModule("command/Menus"),\n        PreferencesManager  = brackets.getModule("preferences/PreferencesManager"),\n        Strings             = brackets.getModule("strings"),\n        ViewUtils           = brackets.getModule("utils/ViewUtils"),\n        TokenUtils          = brackets.getModule("utils/TokenUtils");\n   \n    var previewContainerHTML       = require("text!QuickViewTemplate.html");\n    \n    var enabled,                             // Only show preview if true\n        prefs                      = null,   // Preferences\n        $previewContainer,                   // Preview container\n        $previewContent,                     // Preview content holder\n        lastMousePos,                        // Last mouse position\n        animationRequest;                    // Request for animation frame\n    \n    // Constants\n    var CMD_ENABLE_QUICK_VIEW       = "view.enableQuickView",\n        HOVER_DELAY                 = 350,  // Time (ms) mouse must remain over a provider\'s matched text before popover appears\n        POINTER_HEIGHT              = 15,   // Pointer height, used to shift popover above pointer (plus a little bit of space)\n        POPOVER_HORZ_MARGIN         =  5;   // Horizontal margin\n    \n    var styleLanguages = ["css", "text/x-less", "sass", "text/x-scss"];\n\n    prefs = PreferencesManager.getExtensionPrefs("quickview");\n    prefs.definePreference("enabled", "boolean", true);\n\n    /**\n     * There are three states for this var:\n     * 1. If null, there is no provider result for the given mouse position.\n     * 2. If non-null, and visible==true, there is a popover currently showing.\n     * 3. If non-null, but visible==false, we\'re waiting for HOVER_DELAY, which\n     *    is tracked by hoverTimer. The state changes to visible==true as soon as\n     *    there is a provider. If the mouse moves before then, timer is restarted.\n     * \n     * @type {{\n     *      visible: boolean,\n     *      editor: !Editor,\n     *      hoverTimer: number,             - setTimeout() token\n     *      start: !{line, ch},             - start of matched text range\n     *      end: !{line, ch},               - end of matched text range\n     *      content: !string,               - HTML content to display in popover\n     *      onShow: ?function():void,       - called once popover content added to the DOM (may never be called) \n     *        - if specified, must call positionPreview()\n     *      xpos: number,                   - x of center of popover\n     *      ytop: number,                   - y of top of matched text (when popover placed above text, normally)\n     *      ybot: number,                   - y of bottom of matched text (when popover moved below text, avoiding window top)\n     *      marker: ?CodeMirror.TextMarker  - only set once visible==true\n     * }}\n     */\n    var popoverState = null;\n    \n    \n    \n    // Popover widget management ----------------------------------------------\n    \n    /**\n     * Cancels whatever popoverState was currently pending and sets it back to null. If the popover was visible,\n     * hides it; if the popover was invisible and still pending, cancels hoverTimer so it will never be shown.\n     */\n    function hidePreview() {\n        if (!popoverState) {\n            return;\n        }\n        \n        if (popoverState.visible) {\n            popoverState.marker.clear();\n            \n            $previewContent.empty();\n            $previewContainer.hide();\n            $previewContainer.removeClass("active");\n        } else {\n            window.clearTimeout(popoverState.hoverTimer);\n        }\n        popoverState = null;\n    }\n    \n    function positionPreview(editor, xpos, ypos, ybot) {\n        var previewWidth  = $previewContainer.outerWidth(),\n            top           = ypos - $previewContainer.outerHeight() - POINTER_HEIGHT,\n            left          = xpos - previewWidth / 2,\n            elementRect = {\n                top:    top,\n                left:   left - POPOVER_HORZ_MARGIN,\n                height: $previewContainer.outerHeight() + POINTER_HEIGHT,\n                width:  previewWidth + 2 * POPOVER_HORZ_MARGIN\n            },\n            clip = ViewUtils.getElementClipSize($(editor.getRootElement()), elementRect);\n\n        // Prevent horizontal clipping\n        if (clip.left > 0) {\n            left += clip.left;\n        } else if (clip.right > 0) {\n            left -= clip.right;\n        }\n\n        // If clipped on top, flip popover below line\n        if (clip.top > 0) {\n            top = ybot + POINTER_HEIGHT;\n            $previewContainer\n                .removeClass("preview-bubble-above")\n                .addClass("preview-bubble-below");\n        } else {\n            $previewContainer\n                .removeClass("preview-bubble-below")\n                .addClass("preview-bubble-above");\n        }\n        \n        $previewContainer\n            .css({\n                left: left,\n                top: top\n            })\n            .addClass("active");\n    }\n    \n    function divContainsMouse($div, mousePos) {\n        var offset = $div.offset();\n        \n        return (mousePos.clientX >= offset.left &&\n                mousePos.clientX <= offset.left + $div.width() &&\n                mousePos.clientY >= offset.top &&\n                mousePos.clientY <= offset.top + $div.height());\n    }\n    \n    \n    // Color & gradient preview provider --------------------------------------\n\n    function colorAndGradientPreviewProvider(editor, pos, token, line) {\n\n        // Check for gradient. -webkit-gradient() can have parens in parameters\n        // nested 2 levels. Other gradients can only nest 1 level.\n        var gradientRegEx = /-webkit-gradient\\((?:[^\\(]*?(?:\\((?:[^\\(]*?(?:\\([^\\)]*?\\))*?)*?\\))*?)*?\\)|(?:(?:-moz-|-ms-|-o-|-webkit-|:|\\s)((repeating-)?linear-gradient)|(?:-moz-|-ms-|-o-|-webkit-|:|\\s)((repeating-)?radial-gradient))(\\((?:[^\\)]*?(?:\\([^\\)]*?\\))*?)*?\\))/gi,\n            colorRegEx    = new RegExp(ColorUtils.COLOR_REGEX),\n            mode          = TokenUtils.getModeAt(editor._codeMirror, pos),\n            isStyleSheet  = (styleLanguages.indexOf(mode) !== -1);\n\n        function areParensBalanced(str) {\n            var i,\n                nestLevel = 0,\n                len;\n\n            if (isStyleSheet) {\n                // Remove comments & strings from style sheets\n                str = CSSUtils.reduceStyleSheetForRegExParsing(str);\n            }\n            len = str.length;\n            \n            for (i = 0; i < len; i++) {\n                switch (str[i]) {\n                case "(":\n                    nestLevel++;\n                    break;\n                case ")":\n                    nestLevel--;\n                    break;\n                case "\\\\":\n                    i++;    // next char is escaped, so skip it\n                    break;\n                }\n            }\n\n            // if parens are balanced, nest level will be 0\n            return (nestLevel === 0);\n        }\n        \n        function execGradientMatch(line) {\n            // Unbalanced parens cause infinite loop (see issue #4650)\n            var gradientMatch = (areParensBalanced(line) ? gradientRegEx.exec(line) : null),\n                prefix = "",\n                colorValue;\n            \n            if (gradientMatch) {\n                if (gradientMatch[0].indexOf("@") !== -1) {\n                    // If the gradient match has "@" in it, it is most likely a less or\n                    // sass variable. Ignore it since it won\'t be displayed correctly.\n                    gradientMatch = null;\n    \n                } else {\n                    // If it was a linear-gradient or radial-gradient variant with a vendor prefix \n                    // add "-webkit-" so it shows up correctly in Brackets.\n                    if (gradientMatch[0].match(/-o-|-moz-|-ms-|-webkit-/i)) {\n                        prefix = "-webkit-";\n                    }\n                    \n                    // For prefixed gradients, use the non-prefixed value as the color value.\n                    // "-webkit-" will be added before this value later\n                    if (gradientMatch[1]) {\n                        colorValue = gradientMatch[1] + gradientMatch[5];    // linear gradiant\n                    } else if (gradientMatch[3]) {\n                        colorValue = gradientMatch[3] + gradientMatch[5];    // radial gradiant\n                    } else if (gradientMatch[0]) {\n                        colorValue = gradientMatch[0];                       // -webkit-gradient\n                        prefix = "";                                         // do not prefix\n                    }\n                }\n            }\n\n            return {\n                match:      gradientMatch,\n                prefix:     prefix,\n                colorValue: colorValue\n            };\n        }\n\n        function execColorMatch(editor, line, pos) {\n            var colorMatch,\n                ignoreNamedColors;\n\n            function hyphenOnMatchBoundary(match, line) {\n                var beforeIndex, afterIndex;\n                if (match) {\n                    beforeIndex = match.index - 1;\n                    if (beforeIndex >= 0 && line[beforeIndex] === "-") {\n                        return true;\n                    } else {\n                        afterIndex = match.index + match[0].length;\n                        if (afterIndex < line.length && line[afterIndex] === "-") {\n                            return true;\n                        }\n                    }\n                }\n                \n                return false;\n            }\n            function isNamedColor(match) {\n                if (match && match[0] && /^[a-z]+$/i.test(match[0])) { // only for color names, not for hex-/rgb-values\n                    return true;\n                }\n            }\n\n            // Hyphens do not count as a regex word boundary (\\b), so check for those here\n            do {\n                colorMatch = colorRegEx.exec(line);\n                if (!colorMatch) {\n                    break;\n                }\n                if (ignoreNamedColors === undefined) {\n                    var mode = TokenUtils.getModeAt(editor._codeMirror, pos).name;\n                    ignoreNamedColors = styleLanguages.indexOf(mode) === -1;\n                }\n            } while (hyphenOnMatchBoundary(colorMatch, line) ||\n                    (ignoreNamedColors && isNamedColor(colorMatch)));\n\n            return colorMatch;\n        }\n        \n        // simple css property splitter (used to find color stop arguments in gradients)\n        function splitStyleProperty(property) {\n            var token = /((?:[^"\']|".*?"|\'.*?\')*?)([(,)]|$)/g;\n            var recurse = function () {\n                var array = [];\n                for (;;) {\n                    var result = token.exec(property);\n                    if (result[2] === "(") {\n                        var str = result[1].trim() + "(" + recurse().join(",") + ")";\n                        result = token.exec(property);\n                        str += result[1];\n                        array.push(str);\n                    } else {\n                        array.push(result[1].trim());\n                    }\n                    if (result[2] !== ",") {\n                        return array;\n                    }\n                }\n            };\n            return (recurse());\n        }\n        \n        // color stop helpers\n        function isGradientColorStop(args) {\n            return (args.length > 0 && args[0].match(colorRegEx) !== null);\n        }\n        \n        function hasLengthInPixels(args) {\n            return (args.length > 1 && args[1].indexOf("px") > 0);\n        }\n        \n        // Normalizes px color stops to % \n        function normalizeGradientExpressionForQuickview(expression) {\n            if (expression.indexOf("px") > 0) {\n                var paramStart = expression.indexOf("(") + 1,\n                    paramEnd = expression.lastIndexOf(")"),\n                    parameters = expression.substring(paramStart, paramEnd),\n                    params = splitStyleProperty(parameters),\n                    lowerBound = 0,\n                    upperBound = $previewContainer.width(),\n                    args,\n                    thisSize,\n                    i;\n\n                // find lower bound                \n                for (i = 0; i < params.length; i++) {\n                    args = params[i].split(" ");\n                    \n                    if (hasLengthInPixels(args)) {\n                        thisSize = parseFloat(args[1]);\n\n                        upperBound = Math.max(upperBound, thisSize);\n                        // we really only care about converting negative\n                        //  pixel values -- so take the smallest negative pixel \n                        //  value and use that as baseline for display purposes\n                        if (thisSize < 0) {\n                            lowerBound = Math.min(lowerBound, thisSize);\n                        }\n                    }\n                }\n                \n                // convert negative lower bound to positive and adjust all pixel values\n                //  so that -20px is now 0px and 100px is now 120px \n                lowerBound = Math.abs(lowerBound);\n                \n                // Offset the upperbound by the lowerBound to give us a corrected context\n                upperBound += lowerBound;\n                \n                // convert to %\n                for (i = 0; i < params.length; i++) {\n                    args = params[i].split(" ");\n                    if (isGradientColorStop(args) && hasLengthInPixels(args)) {\n                        if (upperBound === 0) {\n                            thisSize = 0;\n                        } else {\n                            thisSize = ((parseFloat(args[1]) + lowerBound) / upperBound) * 100;\n                        }\n                        args[1] = thisSize + "%";\n                    }\n                    params[i] = args.join(" ");\n                }\n\n                // put it back together.                \n                expression = expression.substring(0, paramStart) + params.join(", ") + expression.substring(paramEnd);\n            }\n            return expression;\n        }\n\n        var gradientMatch = execGradientMatch(line),\n            match = gradientMatch.match || execColorMatch(editor, line, pos),\n            cm = editor._codeMirror;\n\n        while (match) {\n            if (pos.ch < match.index) {\n                // Gradients are matched first, then colors, so...\n                if (gradientMatch.match) {\n                    // ... gradient match is past cursor -- stop looking for gradients, start searching for colors\n                    gradientMatch = { match: null, prefix: "", colorValue: null };\n                } else {\n                    // ... color match is past cursor -- stop looping\n                    break;\n                }\n            } else if (pos.ch <= match.index + match[0].length) {\n                // build the css for previewing the gradient from the regex result\n                var previewCSS = gradientMatch.prefix + (gradientMatch.colorValue || match[0]);\n                \n                // normalize the arguments to something that we can display to the user\n                // NOTE: we need both the div and the popover\'s _previewCSS member \n                //          (used by unit tests) to match so normalize the css for both\n                previewCSS = normalizeGradientExpressionForQuickview(previewCSS);\n                    \n                var preview = "<div class=\'color-swatch\' style=\'background:" + previewCSS + "\'>" +\n                              "</div>";\n                var startPos = {line: pos.line, ch: match.index},\n                    endPos = {line: pos.line, ch: match.index + match[0].length},\n                    startCoords = cm.charCoords(startPos),\n                    xPos;\n                \n                xPos = (cm.charCoords(endPos).left - startCoords.left) / 2 + startCoords.left;\n                \n                return {\n                    start: startPos,\n                    end: endPos,\n                    content: preview,\n                    xpos: xPos,\n                    ytop: startCoords.top,\n                    ybot: startCoords.bottom,\n                    _previewCSS: previewCSS\n                };\n            }\n\n            // Get next match\n            if (gradientMatch.match) {\n                gradientMatch = execGradientMatch(line);\n            }\n            match = gradientMatch.match || execColorMatch(editor, line, pos);\n        }\n        \n        return null;\n    }\n    \n    \n    // Image preview provider -------------------------------------------------\n    \n    function imagePreviewProvider(editor, pos, token, line) {\n        var cm = editor._codeMirror;\n        \n        // Check for image name\n        var urlRegEx = /url\\(([^\\)]*)\\)/gi,\n            tokenString,\n            urlMatch;\n\n        if (token.type === "string") {\n            tokenString = token.string;\n        } else {\n            urlMatch = urlRegEx.exec(line);\n            while (urlMatch) {\n                if (pos.ch < urlMatch.index) {\n                    // match is past cursor, so stop looping\n                    break;\n                } else if (pos.ch <= urlMatch.index + urlMatch[0].length) {\n                    tokenString = urlMatch[1];\n                    break;\n                }\n                urlMatch = urlRegEx.exec(line);\n            }\n        }\n        \n        if (tokenString) {\n            // Strip leading/trailing quotes, if present\n            tokenString = tokenString.replace(/(^[\'"])|([\'"]$)/g, "");\n            \n            if (/^(data\\:image)|(\\.gif|\\.png|\\.jpg|\\.jpeg|\\.svg)$/i.test(tokenString)) {\n                var sPos, ePos;\n                var docPath = editor.document.file.fullPath;\n                var imgPath;\n                \n                if (PathUtils.isAbsoluteUrl(tokenString)) {\n                    imgPath = tokenString;\n                } else {\n                    imgPath = "file:///" + FileUtils.getDirectoryPath(docPath) + tokenString;\n                }\n                \n                if (urlMatch) {\n                    sPos = {line: pos.line, ch: urlMatch.index};\n                    ePos = {line: pos.line, ch: urlMatch.index + urlMatch[0].length};\n                } else {\n                    sPos = {line: pos.line, ch: token.start};\n                    ePos = {line: pos.line, ch: token.end};\n                }\n                \n                if (imgPath) {\n                    var imgPreview = "<div class=\'image-preview\'>"          +\n                                     "    <img src=\\"" + imgPath + "\\">"    +\n                                     "</div>";\n                    var coord = cm.charCoords(sPos);\n                    var xpos = (cm.charCoords(ePos).left - coord.left) / 2 + coord.left;\n                    \n                    var showHandler = function () {\n                        // Hide the preview container until the image is loaded.\n                        $previewContainer.hide();\n                                                    \n                        \n                        $previewContainer.find(".image-preview > img").on("load", function () {\n                            $previewContent\n                                .append("<div class=\'img-size\'>" +\n                                            this.naturalWidth + " &times; " + this.naturalHeight + " " + Strings.UNIT_PIXELS +\n                                        "</div>"\n                                    );\n                            $previewContainer.show();\n                            positionPreview(editor, popoverState.xpos, popoverState.ytop, popoverState.ybot);\n                        });\n                    };\n                    \n                    return {\n                        start: sPos,\n                        end: ePos,\n                        content: imgPreview,\n                        onShow: showHandler,\n                        xpos: xpos,\n                        ytop: coord.top,\n                        ybot: coord.bottom,\n                        _imgPath: imgPath\n                    };\n                }\n            }\n        }\n        \n        return null;\n    }\n    \n\n    // Preview hide/show logic ------------------------------------------------\n    \n    /**\n     * Returns a \'ready for use\' popover state object:\n     * { visible: false, editor, start, end, content, ?onShow, xpos, ytop, ybot }\n     * Lacks only hoverTimer (supplied by handleMouseMove()) and marker (supplied by showPreview()).\n     */\n    function queryPreviewProviders(editor, pos, token) {\n        \n        var line = editor.document.getLine(pos.line);\n        \n        // FUTURE: Support plugin providers. For now we just hard-code...\n        var popover = colorAndGradientPreviewProvider(editor, pos, token, line) ||\n                      imagePreviewProvider(editor, pos, token, line);\n        \n        if (popover) {\n            // Providers return just { start, end, content, ?onShow, xpos, ytop, ybot }\n            popover.visible = false;\n            popover.editor  = editor;\n            return popover;\n        }\n\n        return null;\n    }\n    \n    function getHoveredEditor(mousePos) {\n        // Figure out which editor we are over\n        var fullEditor = EditorManager.getCurrentFullEditor();\n        \n        if (!fullEditor || !mousePos) {\n            return;\n        }\n        \n        // Check for inline Editor instances first\n        var inlines = fullEditor.getInlineWidgets(),\n            i,\n            editor;\n        \n        for (i = 0; i < inlines.length; i++) {\n            var $inlineEditorRoot = inlines[i].editor && $(inlines[i].editor.getRootElement()), // see MultiRangeInlineEditor\n                $otherDiv = inlines[i].$htmlContent;\n            \n            if ($inlineEditorRoot && divContainsMouse($inlineEditorRoot, mousePos)) {\n                editor = inlines[i].editor;\n                break;\n            } else if ($otherDiv && divContainsMouse($otherDiv, mousePos)) {\n                // Mouse inside unsupported inline editor like Quick Docs or Color Editor\n                return;\n            }\n        }\n        \n        // Check main editor\n        if (!editor) {\n            if (divContainsMouse($(fullEditor.getRootElement()), mousePos)) {\n                editor = fullEditor;\n            }\n        }\n        \n        return editor;\n    }\n    \n    /**\n     * Changes the current hidden popoverState to visible, showing it in the UI and highlighting\n     * its matching text in the editor.\n     */\n    function showPreview(editor, popover) {\n        var token, cm;\n\n        // Figure out which editor we are over\n        if (!editor) {\n            editor = getHoveredEditor(lastMousePos);\n        }\n\n        if (!editor || !editor._codeMirror) {\n            hidePreview();\n            return;\n        }\n\n        cm = editor._codeMirror;\n\n        // Find char mouse is over\n        var pos = cm.coordsChar({left: lastMousePos.clientX, top: lastMousePos.clientY});\n\n        // No preview if mouse is past last char on line\n        if (pos.ch >= editor.document.getLine(pos.line).length) {\n            return;\n        }\n\n        if (popover) {\n            popoverState = popover;\n        } else {\n            // Query providers and append to popoverState\n            token = cm.getTokenAt(pos, true);\n            popoverState = $.extend({}, popoverState, queryPreviewProviders(editor, pos, token));\n        }\n        \n        if (popoverState && popoverState.start && popoverState.end) {\n            popoverState.marker = cm.markText(\n                popoverState.start,\n                popoverState.end,\n                {className: "quick-view-highlight"}\n            );\n            \n            $previewContent.append(popoverState.content);\n            $previewContainer.show();\n            \n            popoverState.visible = true;\n            \n            if (popoverState.onShow) {\n                popoverState.onShow();\n            } else {\n                positionPreview(editor, popoverState.xpos, popoverState.ytop, popoverState.ybot);\n            }\n        }\n    }\n\n    function processMouseMove() {\n        animationRequest = null;\n        \n        if (!lastMousePos) {\n            return;         // should never get here, but safety first!\n        }\n\n        var showImmediately = false,\n            editor = null;\n\n        if (popoverState && popoverState.visible) {\n            // Only figure out which editor we are over when there is already a popover\n            // showing (otherwise wait until after delay to minimize processing)\n            editor = getHoveredEditor(lastMousePos);\n            if (editor && editor._codeMirror) {\n                // Find char mouse is over\n                var cm = editor._codeMirror,\n                    pos = cm.coordsChar({left: lastMousePos.clientX, top: lastMousePos.clientY});\n\n                if (popoverState.start && popoverState.end &&\n                        editor.posWithinRange(pos, popoverState.start, popoverState.end, true) &&\n                        (pos.ch < editor.document.getLine(pos.line).length)) {\n\n                    // That one\'s still relevant - nothing more to do\n                    // Note: posWithinRange() includes mouse past end of line, so need to check for that case\n                    return;\n                }\n            }\n\n            // That one doesn\'t cover this pos - hide it and start anew\n            showImmediately = true;\n        }\n\n        // Initialize popoverState\n        hidePreview();\n        popoverState = {};\n\n        // Set timer to scan and show. This will get cancelled (in hidePreview())\n        // if mouse movement rendered this popover inapplicable before timer fires.\n        // When showing "immediately", still use setTimeout() to make this async\n        // so we return from this mousemove event handler ASAP.\n        popoverState.hoverTimer = window.setTimeout(function () {\n            showPreview(editor);\n        }, showImmediately ? 0 : HOVER_DELAY);\n    }\n    \n    function handleMouseMove(event) {\n        lastMousePos = null;\n\n        if (!enabled) {\n            return;\n        }\n\n        if (event.which) {\n            // Button is down - don\'t show popovers while dragging\n            hidePreview();\n            return;\n        }\n\n        // Keep track of last mouse position\n        lastMousePos = {\n            clientX: event.clientX,\n            clientY: event.clientY\n        };\n\n        // Prevent duplicate animation frame requests\n        if (!animationRequest) {\n            animationRequest = window.requestAnimationFrame(processMouseMove);\n        }\n    }\n\n    function onActiveEditorChange(event, current, previous) {\n        // Hide preview when editor changes\n        hidePreview();\n\n        if (previous && previous.document) {\n            previous.document.off("change", hidePreview);\n        }\n\n        if (current && current.document) {\n            current.document.on("change", hidePreview);\n        }\n    }\n\n    // Menu command handlers\n    function updateMenuItemCheckmark() {\n        CommandManager.get(CMD_ENABLE_QUICK_VIEW).setChecked(enabled);\n    }\n\n    function setEnabled(_enabled, doNotSave) {\n        if (enabled !== _enabled) {\n            enabled = _enabled;\n            var editorHolder = $("#editor-holder")[0];\n            if (enabled) {\n                // Note: listening to "scroll" also catches text edits, which bubble a scroll event up from the hidden text area. This means\n                // we auto-hide on text edit, which is probably actually a good thing.\n                editorHolder.addEventListener("mousemove", handleMouseMove, true);\n                editorHolder.addEventListener("scroll", hidePreview, true);\n                editorHolder.addEventListener("mouseout", hidePreview, true);\n\n                // Setup doc "change" listener\n                onActiveEditorChange(null, EditorManager.getActiveEditor(), null);\n                EditorManager.on("activeEditorChange", onActiveEditorChange);\n\n            } else {\n                editorHolder.removeEventListener("mousemove", handleMouseMove, true);\n                editorHolder.removeEventListener("scroll", hidePreview, true);\n                editorHolder.removeEventListener("mouseout", hidePreview, true);\n\n                // Cleanup doc "change" listener\n                onActiveEditorChange(null, null, EditorManager.getActiveEditor());\n                EditorManager.off("activeEditorChange", onActiveEditorChange);\n\n                hidePreview();\n            }\n            if (!doNotSave) {\n                prefs.set("enabled", enabled);\n                prefs.save();\n            }\n        }\n        // Always update the checkmark, even if the enabled flag hasn\'t changed.\n        updateMenuItemCheckmark();\n    }\n    \n    function toggleEnableQuickView() {\n        setEnabled(!enabled);\n    }\n    \n    function _forceShow(popover) {\n        hidePreview();\n        lastMousePos = {\n            clientX: popover.xpos,\n            clientY: Math.floor((popover.ybot + popover.ytop) / 2)\n        };\n        showPreview(popover.editor, popover);\n    }\n    \n    // Create the preview container\n    $previewContainer = $(previewContainerHTML).appendTo($("body"));\n    $previewContent = $previewContainer.find(".preview-content");\n    \n    // Load our stylesheet\n    ExtensionUtils.loadStyleSheet(module, "QuickView.less");\n    \n    // Register command\n    // Insert menu at specific pos since this may load before OR after code folding extension\n    CommandManager.register(Strings.CMD_ENABLE_QUICK_VIEW, CMD_ENABLE_QUICK_VIEW, toggleEnableQuickView);\n    Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).addMenuItem(CMD_ENABLE_QUICK_VIEW, null, Menus.AFTER, Commands.VIEW_TOGGLE_INSPECTION);\n    \n    // Convert old preferences\n    PreferencesManager.convertPreferences(module, {\n        "enabled": "user quickview.enabled"\n    });\n\n    // Setup initial UI state\n    setEnabled(prefs.get("enabled"), true);\n    \n    prefs.on("change", "enabled", function () {\n        setEnabled(prefs.get("enabled"), true);\n    });\n    \n    // For unit testing\n    exports._queryPreviewProviders  = queryPreviewProviders;\n    exports._forceShow              = _forceShow;\n});\n\n//# sourceURL=/main.js');

//# sourceMappingURL=main.js
//# sourceMappingURL=main.js.map