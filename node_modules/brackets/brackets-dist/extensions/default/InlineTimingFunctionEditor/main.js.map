{"version":3,"file":"main.js","sources":["TimingFunctionUtils.js","../../../thirdparty/text/text.js","BezierCurveEditorTemplate.html!text","StepEditorTemplate.html!text","StepEditor.js","Localized.css!text","main.js"],"names":["eval"],"mappings":"AAAAA,KAAA,2piBCAAA,KDEA,yqfEDAA,KAAA,stBAEAA,KAAA,wiwBCFAA,KAAA,0eCDAA,KDGA,w0eCDAA,KAAA,6sWCDAA,KAAA,0rBAEAA,KCHA","sourcesContent":["eval(\"/*\\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\\n *  \\n * Permission is hereby granted, free of charge, to any person obtaining a\\n * copy of this software and associated documentation files (the \\\"Software\\\"), \\n * to deal in the Software without restriction, including without limitation \\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \\n * and/or sell copies of the Software, and to permit persons to whom the \\n * Software is furnished to do so, subject to the following conditions:\\n *  \\n * The above copyright notice and this permission notice shall be included in\\n * all copies or substantial portions of the Software.\\n *  \\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \\n * DEALINGS IN THE SOFTWARE.\\n * \\n */\\n\\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\\n/*global define, brackets */\\n\\n/**\\n *  Utilities functions related to color matching\\n */\\ndefine(\\'TimingFunctionUtils\\',[\\'require\\',\\'exports\\',\\'module\\'],function (require, exports, module) {\\n    \\\"use strict\\\";\\n    \\n    var Strings         = brackets.getModule(\\\"strings\\\"),\\n        StringUtils     = brackets.getModule(\\\"utils/StringUtils\\\"),\\n        AnimationUtils  = brackets.getModule(\\\"utils/AnimationUtils\\\");\\n    \\n    /**\\n     * Regular expressions for matching timing functions\\n     * @const @type {RegExp}\\n     */\\n    var BEZIER_CURVE_VALID_REGEX        = /cubic-bezier\\\\(\\\\s*(\\\\S+)\\\\s*,\\\\s*(\\\\S+)\\\\s*,\\\\s*(\\\\S+)\\\\s*,\\\\s*(\\\\S+)\\\\s*\\\\)/,\\n        BEZIER_CURVE_GENERAL_REGEX      = /cubic-bezier\\\\((.*)\\\\)/,\\n        EASE_STRICT_REGEX               = /[: ,]ease(?:-in)?(?:-out)?[ ,;]/,\\n        EASE_LAX_REGEX                  = /ease(?:-in)?(?:-out)?/,\\n        LINEAR_STRICT_REGEX             = /transition.*?[: ,]linear[ ,;]/,\\n        LINEAR_LAX_REGEX                = /linear/,\\n        STEPS_VALID_REGEX               = /steps\\\\(\\\\s*(\\\\d+)\\\\s*(?:,\\\\s*(\\\\w+)\\\\s*)?\\\\)/,\\n        STEPS_GENERAL_REGEX             = /steps\\\\((.*)\\\\)/,\\n        STEP_STRICT_REGEX               = /[: ,](?:step-start|step-end)[ ,;]/,\\n        STEP_LAX_REGEX                  = /step-start|step-end/;\\n\\n    /**\\n     * Type constants\\n     * @const @type {number}\\n     */\\n    var BEZIER  = 1,\\n        STEP    = 2;\\n\\n    /**\\n     * If string is a number, then convert it.\\n     *\\n     * @param {string} str  value parsed from page.\\n     * @return { isNumber: boolean, value: ?number }\\n     */\\n    function _convertToNumber(str) {\\n        if (typeof str !== \\\"string\\\") {\\n            return { isNumber: false, value: null };\\n        }\\n\\n        var val = parseFloat(+str, 10),\\n            isNum = (typeof val === \\\"number\\\") && !isNaN(val) &&\\n                    (val !== Infinity) && (val !== -Infinity);\\n\\n        return {\\n            isNumber: isNum,\\n            value:    val\\n        };\\n    }\\n\\n    /**\\n     * Get valid params for an invalid cubic-bezier.\\n     *\\n     * @param {RegExp.match} match (Invalid) matches from cubicBezierMatch()\\n     * @return {?RegExp.match} Valid match or null if the output is not valid\\n     */\\n    function _getValidBezierParams(match) {\\n        var param,\\n            // take ease-in-out as default value in case there are no params yet (or they are invalid)\\n            def = [ \\\".42\\\", \\\"0\\\", \\\".58\\\", \\\"1\\\" ],\\n            oldIndex = match.index, // we need to store the old match.index to re-set the index afterwards\\n            originalString = match[0],\\n            i;\\n\\n        if (match) {\\n            match = match[1].split(\\\",\\\");\\n        }\\n        \\n        if (match) {\\n            for (i = 0; i <= 3; i++) {\\n                if (match[i]) {\\n                    match[i] = match[i].trim();\\n                    param = _convertToNumber(match[i]);\\n\\n                    // Verify the param is a number\\n                    // If not, replace it with the default value\\n                    if (!param.isNumber) {\\n                        match[i] = undefined;\\n\\n                    // Verify x coordinates are in 0-1 range\\n                    // If not, set them to the closest value in range\\n                    } else if (i === 0 || i === 2) {\\n                        if (param.value < 0) {\\n                            match[i] = \\\"0\\\";\\n                        } else if (param.value > 1) {\\n                            match[i] = \\\"1\\\";\\n                        }\\n                    }\\n                }\\n\\n                if (!match[i]) {\\n                    match[i] = def[i];\\n                }\\n            }\\n        } else {\\n            match = def;\\n        }\\n        match = match.splice(0, 4); // make sure there are only 4 params\\n        match = \\\"cubic-bezier(\\\" + match.join(\\\", \\\") + \\\")\\\";\\n        match = match.match(BEZIER_CURVE_VALID_REGEX);\\n\\n        if (match) {\\n            match.index = oldIndex; // re-set the index here to get the right context\\n            match.originalString = originalString;\\n            return match;\\n        }\\n        return null;\\n    }\\n\\n    /**\\n     * Validate cubic-bezier function parameters that are not already validated by regex:\\n     *\\n     * @param {RegExp.match} match  RegExp Match object with cubic-bezier function parameters\\n     *                              in array positions 1-4.\\n     * @return {boolean} true if all parameters are valid, otherwise, false\\n     */\\n    function _validateCubicBezierParams(match) {\\n        var x1 = _convertToNumber(match[1]),\\n            y1 = _convertToNumber(match[2]),\\n            x2 = _convertToNumber(match[3]),\\n            y2 = _convertToNumber(match[4]);\\n\\n        // Verify all params are numbers\\n        if (!x1.isNumber || !y1.isNumber || !x2.isNumber || !y2.isNumber) {\\n            return false;\\n        }\\n\\n        // Verify x params are in 0-1 range\\n        if (x1.value < 0 || x1.value > 1 || x2.value < 0 || x2.value > 1) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * Get valid params for an invalid steps function.\\n     *\\n     * @param {RegExp.match} match (Invalid) matches from stepsMatch()\\n     * @return {?RegExp.match} Valid match or null if the output is not valid\\n     */\\n    function _getValidStepsParams(match) {\\n        var param,\\n            def = [ \\\"5\\\", \\\"end\\\" ],\\n            params = def,\\n            oldIndex = match.index, // we need to store the old match.index to re-set the index afterwards\\n            originalString = match[0];\\n\\n        if (match) {\\n            match = match[1].split(\\\",\\\");\\n        }\\n\\n        if (match) {\\n            if (match[0]) {\\n                param = match[0].replace(/[\\\\s\\\\\\\"\\']/g, \\\"\\\"); // replace possible trailing whitespace or leading quotes\\n                param = _convertToNumber(param);\\n\\n                // Verify number_of_params is a number\\n                // If not, replace it with the default value\\n                if (!param.isNumber) {\\n                    param.value = def[0];\\n\\n                // Round number_of_params to an integer\\n                } else if (param.value) {\\n                    param.value = Math.floor(param.value);\\n                }\\n\\n                // Verify number_of_steps is >= 1\\n                // If not, set them to the default value\\n                if (param.value < 1) {\\n                    param.value = def[0];\\n                }\\n                params[0] = param.value;\\n            }\\n            if (match[1]) {\\n                // little autocorrect feature: leading s gets \\'start\\', everything else gets \\'end\\'\\n                param = match[1].replace(/[\\\\s\\\\\\\"\\']/g, \\\"\\\"); // replace possible trailing whitespace or leading quotes\\n                param = param.substr(0, 1);\\n                if (param === \\\"s\\\") {\\n                    params[1] = \\\"start\\\";\\n                } else {\\n                    params[1] = \\\"end\\\";\\n                }\\n            }\\n        }\\n        params = \\\"steps(\\\" + params.join(\\\", \\\") + \\\")\\\";\\n        params = params.match(STEPS_VALID_REGEX);\\n\\n        if (params) {\\n            params.index = oldIndex; // re-set the index here to get the right context\\n            params.originalString = originalString;\\n            return params;\\n        }\\n        return null;\\n    }\\n\\n    /**\\n     * Validate steps function parameters that are not already validated by regex:\\n     *\\n     * @param {RegExp.match} match  RegExp Match object with steps function parameters\\n     *                              in array position 1 (and optionally 2).\\n     * @return {boolean} true if all parameters are valid, otherwise, false\\n     */\\n    function _validateStepsParams(match) {\\n        var count = _convertToNumber(match[1]);\\n\\n        if (!count.isNumber || count.value < 1 || Math.floor(count.value) !== count.value) {\\n            return false;\\n        }\\n\\n        if (match[2] && match[2] !== \\\"start\\\" && match[2] !== \\\"end\\\") {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n    \\n    /**\\n     * Show, hide or update the hint text\\n     * \\n     * @param {object} hint Editor.hint object of the current InlineTimingFunctionEditor\\n     * @param {boolean} show Whether the hint should be shown or hidden\\n     * @param {string=} documentCode The invalid code from the document (can be omitted when hiding)\\n     * @param {string=} editorCode The valid code that is shown in the Inline Editor (can be omitted when hiding)\\n     */\\n    function showHideHint(hint, show, documentCode, editorCode) {\\n        if (!hint || !hint.elem) {\\n            return;\\n        }\\n        \\n        if (show) {\\n            hint.shown = true;\\n            hint.animationInProgress = false;\\n            hint.elem.removeClass(\\\"fadeout\\\");\\n            hint.elem.html(StringUtils.format(Strings.INLINE_TIMING_EDITOR_INVALID, documentCode, editorCode));\\n            hint.elem.css(\\\"display\\\", \\\"block\\\");\\n        } else if (hint.shown) {\\n            hint.animationInProgress = true;\\n            AnimationUtils.animateUsingClass(hint.elem[0], \\\"fadeout\\\", 750)\\n                .done(function () {\\n                    if (hint.animationInProgress) { // do this only if the animation was not cancelled\\n                        hint.elem.hide();\\n                    }\\n                    hint.shown = false;\\n                    hint.animationInProgress = false;\\n                });\\n        } else {\\n            hint.elem.hide();\\n        }\\n    }\\n\\n    /**\\n     * Tag this match with type and return it for chaining\\n     *\\n     * @param {!RegExp.match} match  RegExp Match object with steps function parameters\\n     *                              in array position 1 (and optionally 2).\\n     * @param {number} type Either BEZIER or STEP\\n     * @return {RegExp.match} Same object that was passed in.\\n     */\\n    function _tagMatch(match, type) {\\n        switch (type) {\\n        case BEZIER:\\n            match.isBezier = true;\\n            break;\\n        case STEP:\\n            match.isStep = true;\\n            break;\\n        }\\n        \\n        return match;\\n    }\\n\\n    /**\\n     * Match a bezier curve function value from a CSS Declaration or Value.\\n     *\\n     * Matches returned from this function must be handled in\\n     * BezierCurveEditor._getCubicBezierCoords().\\n     *\\n     * @param {string} str  Input string.\\n     * @param {!boolean} lax  Parsing mode where:\\n     *          lax=false Input is a Full or partial line containing CSS Declaration.\\n     *                    This is the more strict search used for initial detection.\\n     *          lax=true  Input is a previously parsed value. This is the less strict search\\n     *                    used to convert previously parsed values to RegExp match format.\\n     * @return {!RegExpMatch}\\n     */\\n    function bezierCurveMatch(str, lax) {\\n        var match;\\n\\n        // First look for any cubic-bezier().\\n        match = str.match(BEZIER_CURVE_VALID_REGEX);\\n        if (match && _validateCubicBezierParams(match)) { // cubic-bezier() with valid params\\n            return _tagMatch(match, BEZIER);\\n        }\\n\\n        match = str.match(BEZIER_CURVE_GENERAL_REGEX);\\n        if (match) {\\n            match = _getValidBezierParams(match);\\n            if (match && _validateCubicBezierParams(match)) {\\n                return _tagMatch(match, BEZIER);\\n            } else { // this should not happen!\\n                window.console.log(\\\"brackets-cubic-bezier: TimingFunctionUtils._getValidBezierParams created invalid code\\\");\\n            }\\n        }\\n\\n        // Next look for the ease functions (which are special cases of cubic-bezier())\\n        if (lax) {\\n            // For lax parsing, just look for the keywords\\n            match = str.match(EASE_LAX_REGEX);\\n            if (match) {\\n                return _tagMatch(match, BEZIER);\\n            }\\n        } else {\\n            // For strict parsing, start with a syntax verifying search\\n            match = str.match(EASE_STRICT_REGEX);\\n            if (match) {\\n                // return exact match to keyword that we need for later replacement\\n                return _tagMatch(str.match(EASE_LAX_REGEX), BEZIER);\\n            }\\n        }\\n\\n        // Final case is linear.\\n        if (lax) {\\n            // For lax parsing, just look for the keyword\\n            match = str.match(LINEAR_LAX_REGEX);\\n            if (match) {\\n                return _tagMatch(match, BEZIER);\\n            }\\n        } else {\\n            // The linear keyword can occur in other values, so for strict parsing we\\n            // only detect when it\\'s on same line as \\\"transition\\\"\\n            match = str.match(LINEAR_STRICT_REGEX);\\n            if (match) {\\n                // return exact match to keyword that we need for later replacement\\n                return _tagMatch(str.match(LINEAR_LAX_REGEX), BEZIER);\\n            }\\n        }\\n\\n        return null;\\n    }\\n\\n    /**\\n     * Match a steps function value from a CSS Declaration or Value.\\n     *\\n     * Matches returned from this function must be handled in\\n     * BezierCurveEditor._getCubicBezierCoords().\\n     *\\n     * @param {string} str  Input string.\\n     * @param {!boolean} lax  Parsing mode where:\\n     *          lax=false Input is a Full or partial line containing CSS Declaration.\\n     *                    This is the more strict search used for initial detection.\\n     *          lax=true  Input is a previously parsed value. This is the less strict search\\n     *                    used to convert previously parsed values to RegExp match format.\\n     * @return {!RegExpMatch}\\n     */\\n    function stepsMatch(str, lax) {\\n        var match;\\n\\n        // First look for any steps().\\n        match = str.match(STEPS_VALID_REGEX);\\n        if (match && _validateStepsParams(match)) { // cubic-bezier() with valid params\\n            return _tagMatch(match, STEP);\\n        }\\n\\n        match = str.match(STEPS_GENERAL_REGEX);\\n        if (match) {\\n            match = _getValidStepsParams(match);\\n            if (match && _validateStepsParams(match)) {\\n                return _tagMatch(match, STEP);\\n            } else { // this should not happen!\\n                window.console.log(\\\"brackets-steps: TimingFunctionUtils._getValidStepsParams created invalid code\\\");\\n            }\\n        }\\n\\n        // Next look for the step functions (which are special cases of steps())\\n        if (lax) {\\n            // For lax parsing, just look for the keywords\\n            match = str.match(STEP_LAX_REGEX);\\n            if (match) {\\n                return _tagMatch(match, STEP);\\n            }\\n        } else {\\n            // For strict parsing, start with a syntax verifying search\\n            match = str.match(STEP_STRICT_REGEX);\\n            if (match) {\\n                // return exact match to keyword that we need for later replacement\\n                return _tagMatch(str.match(STEP_LAX_REGEX), STEP);\\n            }\\n        }\\n\\n        return null;\\n    }\\n\\n    /**\\n     * Match a timing function value from a CSS Declaration or Value.\\n     *\\n     * Matches returned from this function must be handled in\\n     * BezierCurveEditor._getCubicBezierCoords().\\n     *\\n     * @param {string} str  Input string.\\n     * @param {!boolean} lax  Parsing mode where:\\n     *          lax=false Input is a Full or partial line containing CSS Declaration.\\n     *                    This is the more strict search used for initial detection.\\n     *          lax=true  Input is a previously parsed value. This is the less strict search\\n     *                    used to convert previously parsed values to RegExp match format.\\n     * @return {!RegExpMatch}\\n     */\\n    function timingFunctionMatch(str, lax) {\\n        return bezierCurveMatch(str, lax) || stepsMatch(str, lax);\\n    }\\n\\n    // Define public API\\n    exports.timingFunctionMatch = timingFunctionMatch;\\n    exports.bezierCurveMatch    = bezierCurveMatch;\\n    exports.stepsMatch          = stepsMatch;\\n    exports.showHideHint        = showHideHint;\\n});\\n\\n//# sourceURL=/TimingFunctionUtils.js\");\n\n","eval(\"/**\\n * @license RequireJS text 2.0.10 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.\\n * Available via the MIT or new BSD license.\\n * see: http://github.com/requirejs/text for details\\n */\\n/*jslint regexp: true */\\n/*global require, XMLHttpRequest, ActiveXObject,\\n  define, window, process, Packages,\\n  java, location, Components, FileUtils */\\n\\ndefine(\\'text\\',[\\'module\\'], function (module) {\\n    \\'use strict\\';\\n\\n    var text, fs, Cc, Ci, xpcIsWindows,\\n        progIds = [\\'Msxml2.XMLHTTP\\', \\'Microsoft.XMLHTTP\\', \\'Msxml2.XMLHTTP.4.0\\'],\\n        xmlRegExp = /^\\\\s*<\\\\?xml(\\\\s)+version=[\\\\\\'\\\\\\\"](\\\\d)*.(\\\\d)*[\\\\\\'\\\\\\\"](\\\\s)*\\\\?>/im,\\n        bodyRegExp = /<body[^>]*>\\\\s*([\\\\s\\\\S]+)\\\\s*<\\\\/body>/im,\\n        hasLocation = typeof location !== \\'undefined\\' && location.href,\\n        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\\\\:/, \\'\\'),\\n        defaultHostName = hasLocation && location.hostname,\\n        defaultPort = hasLocation && (location.port || undefined),\\n        buildMap = {},\\n        masterConfig = (module.config && module.config()) || {};\\n\\n    text = {\\n        version: \\'2.0.10\\',\\n\\n        strip: function (content) {\\n            //Strips <?xml ...?> declarations so that external SVG and XML\\n            //documents can be added to a document without worry. Also, if the string\\n            //is an HTML document, only the part inside the body tag is returned.\\n            if (content) {\\n                content = content.replace(xmlRegExp, \\\"\\\");\\n                var matches = content.match(bodyRegExp);\\n                if (matches) {\\n                    content = matches[1];\\n                }\\n            } else {\\n                content = \\\"\\\";\\n            }\\n            return content;\\n        },\\n\\n        jsEscape: function (content) {\\n            return content.replace(/([\\'\\\\\\\\])/g, \\'\\\\\\\\$1\\')\\n                .replace(/[\\\\f]/g, \\\"\\\\\\\\f\\\")\\n                .replace(/[\\\\b]/g, \\\"\\\\\\\\b\\\")\\n                .replace(/[\\\\n]/g, \\\"\\\\\\\\n\\\")\\n                .replace(/[\\\\t]/g, \\\"\\\\\\\\t\\\")\\n                .replace(/[\\\\r]/g, \\\"\\\\\\\\r\\\")\\n                .replace(/[\\\\u2028]/g, \\\"\\\\\\\\u2028\\\")\\n                .replace(/[\\\\u2029]/g, \\\"\\\\\\\\u2029\\\");\\n        },\\n\\n        createXhr: masterConfig.createXhr || function () {\\n            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.\\n            var xhr, i, progId;\\n            if (typeof XMLHttpRequest !== \\\"undefined\\\") {\\n                return new XMLHttpRequest();\\n            } else if (typeof ActiveXObject !== \\\"undefined\\\") {\\n                for (i = 0; i < 3; i += 1) {\\n                    progId = progIds[i];\\n                    try {\\n                        xhr = new ActiveXObject(progId);\\n                    } catch (e) {}\\n\\n                    if (xhr) {\\n                        progIds = [progId];  // so faster next time\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return xhr;\\n        },\\n\\n        /**\\n         * Parses a resource name into its component parts. Resource names\\n         * look like: module/name.ext!strip, where the !strip part is\\n         * optional.\\n         * @param {String} name the resource name\\n         * @returns {Object} with properties \\\"moduleName\\\", \\\"ext\\\" and \\\"strip\\\"\\n         * where strip is a boolean.\\n         */\\n        parseName: function (name) {\\n            var modName, ext, temp,\\n                strip = false,\\n                index = name.indexOf(\\\".\\\"),\\n                isRelative = name.indexOf(\\'./\\') === 0 ||\\n                             name.indexOf(\\'../\\') === 0;\\n\\n            if (index !== -1 && (!isRelative || index > 1)) {\\n                modName = name.substring(0, index);\\n                ext = name.substring(index + 1, name.length);\\n            } else {\\n                modName = name;\\n            }\\n\\n            temp = ext || modName;\\n            index = temp.indexOf(\\\"!\\\");\\n            if (index !== -1) {\\n                //Pull off the strip arg.\\n                strip = temp.substring(index + 1) === \\\"strip\\\";\\n                temp = temp.substring(0, index);\\n                if (ext) {\\n                    ext = temp;\\n                } else {\\n                    modName = temp;\\n                }\\n            }\\n\\n            return {\\n                moduleName: modName,\\n                ext: ext,\\n                strip: strip\\n            };\\n        },\\n\\n        xdRegExp: /^((\\\\w+)\\\\:)?\\\\/\\\\/([^\\\\/\\\\\\\\]+)/,\\n\\n        /**\\n         * Is an URL on another domain. Only works for browser use, returns\\n         * false in non-browser environments. Only used to know if an\\n         * optimized .js version of a text resource should be loaded\\n         * instead.\\n         * @param {String} url\\n         * @returns Boolean\\n         */\\n        useXhr: function (url, protocol, hostname, port) {\\n            var uProtocol, uHostName, uPort,\\n                match = text.xdRegExp.exec(url);\\n            if (!match) {\\n                return true;\\n            }\\n            uProtocol = match[2];\\n            uHostName = match[3];\\n\\n            uHostName = uHostName.split(\\':\\');\\n            uPort = uHostName[1];\\n            uHostName = uHostName[0];\\n\\n            return (!uProtocol || uProtocol === protocol) &&\\n                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&\\n                   ((!uPort && !uHostName) || uPort === port);\\n        },\\n\\n        finishLoad: function (name, strip, content, onLoad) {\\n            content = strip ? text.strip(content) : content;\\n            if (masterConfig.isBuild) {\\n                buildMap[name] = content;\\n            }\\n            onLoad(content);\\n        },\\n\\n        load: function (name, req, onLoad, config) {\\n            //Name has format: some.module.filext!strip\\n            //The strip part is optional.\\n            //if strip is present, then that means only get the string contents\\n            //inside a body tag in an HTML string. For XML/SVG content it means\\n            //removing the <?xml ...?> declarations so the content can be inserted\\n            //into the current doc without problems.\\n\\n            // Do not bother with the work if a build and text will\\n            // not be inlined.\\n            if (config.isBuild && !config.inlineText) {\\n                onLoad();\\n                return;\\n            }\\n\\n            masterConfig.isBuild = config.isBuild;\\n\\n            var parsed = text.parseName(name),\\n                nonStripName = parsed.moduleName +\\n                    (parsed.ext ? \\'.\\' + parsed.ext : \\'\\'),\\n                url = req.toUrl(nonStripName),\\n                useXhr = (masterConfig.useXhr) ||\\n                         text.useXhr;\\n\\n            // Do not load if it is an empty: url\\n            if (url.indexOf(\\'empty:\\') === 0) {\\n                onLoad();\\n                return;\\n            }\\n\\n            //Load the text. Use XHR if possible and in a browser.\\n            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {\\n                text.get(url, function (content) {\\n                    text.finishLoad(name, parsed.strip, content, onLoad);\\n                }, function (err) {\\n                    if (onLoad.error) {\\n                        onLoad.error(err);\\n                    }\\n                });\\n            } else {\\n                //Need to fetch the resource across domains. Assume\\n                //the resource has been optimized into a JS module. Fetch\\n                //by the module name + extension, but do not include the\\n                //!strip part to avoid file system issues.\\n                req([nonStripName], function (content) {\\n                    text.finishLoad(parsed.moduleName + \\'.\\' + parsed.ext,\\n                                    parsed.strip, content, onLoad);\\n                });\\n            }\\n        },\\n\\n        write: function (pluginName, moduleName, write, config) {\\n            if (buildMap.hasOwnProperty(moduleName)) {\\n                var content = text.jsEscape(buildMap[moduleName]);\\n                write.asModule(pluginName + \\\"!\\\" + moduleName,\\n                               \\\"define(function () { return \\'\\\" +\\n                                   content +\\n                               \\\"\\';});\\\\n\\\");\\n            }\\n        },\\n\\n        writeFile: function (pluginName, moduleName, req, write, config) {\\n            var parsed = text.parseName(moduleName),\\n                extPart = parsed.ext ? \\'.\\' + parsed.ext : \\'\\',\\n                nonStripName = parsed.moduleName + extPart,\\n                //Use a \\'.js\\' file name so that it indicates it is a\\n                //script that can be loaded across domains.\\n                fileName = req.toUrl(parsed.moduleName + extPart) + \\'.js\\';\\n\\n            //Leverage own load() method to load plugin value, but only\\n            //write out values that do not have the strip argument,\\n            //to avoid any potential issues with ! in file names.\\n            text.load(nonStripName, req, function (value) {\\n                //Use own write() method to construct full module value.\\n                //But need to create shell that translates writeFile\\'s\\n                //write() to the right interface.\\n                var textWrite = function (contents) {\\n                    return write(fileName, contents);\\n                };\\n                textWrite.asModule = function (moduleName, contents) {\\n                    return write.asModule(moduleName, fileName, contents);\\n                };\\n\\n                text.write(pluginName, nonStripName, textWrite, config);\\n            }, config);\\n        }\\n    };\\n\\n    if (masterConfig.env === \\'node\\' || (!masterConfig.env &&\\n            typeof process !== \\\"undefined\\\" &&\\n            process.versions &&\\n            !!process.versions.node &&\\n            !process.versions[\\'node-webkit\\'])) {\\n        //Using special require.nodeRequire, something added by r.js.\\n        fs = require.nodeRequire(\\'fs\\');\\n\\n        text.get = function (url, callback, errback) {\\n            try {\\n                var file = fs.readFileSync(url, \\'utf8\\');\\n                //Remove BOM (Byte Mark Order) from utf8 files if it is there.\\n                if (file.indexOf(\\'\\\\uFEFF\\') === 0) {\\n                    file = file.substring(1);\\n                }\\n                callback(file);\\n            } catch (e) {\\n                errback(e);\\n            }\\n        };\\n    } else if (masterConfig.env === \\'xhr\\' || (!masterConfig.env &&\\n            text.createXhr())) {\\n        text.get = function (url, callback, errback, headers) {\\n            var xhr = text.createXhr(), header;\\n            xhr.open(\\'GET\\', url, true);\\n\\n            //Allow plugins direct access to xhr headers\\n            if (headers) {\\n                for (header in headers) {\\n                    if (headers.hasOwnProperty(header)) {\\n                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);\\n                    }\\n                }\\n            }\\n\\n            //Allow overrides specified in config\\n            if (masterConfig.onXhr) {\\n                masterConfig.onXhr(xhr, url);\\n            }\\n\\n            xhr.onreadystatechange = function (evt) {\\n                var status, err;\\n                //Do not explicitly handle errors, those should be\\n                //visible via console output in the browser.\\n                if (xhr.readyState === 4) {\\n                    status = xhr.status;\\n                    if (status > 399 && status < 600) {\\n                        //An http 4xx or 5xx error. Signal an error.\\n                        err = new Error(url + \\' HTTP status: \\' + status);\\n                        err.xhr = xhr;\\n                        errback(err);\\n                    } else {\\n                        callback(xhr.responseText);\\n                    }\\n\\n                    if (masterConfig.onXhrComplete) {\\n                        masterConfig.onXhrComplete(xhr, url);\\n                    }\\n                }\\n            };\\n            xhr.send(null);\\n        };\\n    } else if (masterConfig.env === \\'rhino\\' || (!masterConfig.env &&\\n            typeof Packages !== \\'undefined\\' && typeof java !== \\'undefined\\')) {\\n        //Why Java, why is this so awkward?\\n        text.get = function (url, callback) {\\n            var stringBuffer, line,\\n                encoding = \\\"utf-8\\\",\\n                file = new java.io.File(url),\\n                lineSeparator = java.lang.System.getProperty(\\\"line.separator\\\"),\\n                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),\\n                content = \\'\\';\\n            try {\\n                stringBuffer = new java.lang.StringBuffer();\\n                line = input.readLine();\\n\\n                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324\\n                // http://www.unicode.org/faq/utf_bom.html\\n\\n                // Note that when we use utf-8, the BOM should appear as \\\"EF BB BF\\\", but it doesn\\'t due to this bug in the JDK:\\n                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058\\n                if (line && line.length() && line.charAt(0) === 0xfeff) {\\n                    // Eat the BOM, since we\\'ve already found the encoding on this file,\\n                    // and we plan to concatenating this buffer with others; the BOM should\\n                    // only appear at the top of a file.\\n                    line = line.substring(1);\\n                }\\n\\n                if (line !== null) {\\n                    stringBuffer.append(line);\\n                }\\n\\n                while ((line = input.readLine()) !== null) {\\n                    stringBuffer.append(lineSeparator);\\n                    stringBuffer.append(line);\\n                }\\n                //Make sure we return a JavaScript string and not a Java string.\\n                content = String(stringBuffer.toString()); //String\\n            } finally {\\n                input.close();\\n            }\\n            callback(content);\\n        };\\n    } else if (masterConfig.env === \\'xpconnect\\' || (!masterConfig.env &&\\n            typeof Components !== \\'undefined\\' && Components.classes &&\\n            Components.interfaces)) {\\n        //Avert your gaze!\\n        Cc = Components.classes,\\n        Ci = Components.interfaces;\\n        Components.utils[\\'import\\'](\\'resource://gre/modules/FileUtils.jsm\\');\\n        xpcIsWindows = (\\'@mozilla.org/windows-registry-key;1\\' in Cc);\\n\\n        text.get = function (url, callback) {\\n            var inStream, convertStream, fileObj,\\n                readData = {};\\n\\n            if (xpcIsWindows) {\\n                url = url.replace(/\\\\//g, \\'\\\\\\\\\\');\\n            }\\n\\n            fileObj = new FileUtils.File(url);\\n\\n            //XPCOM, you so crazy\\n            try {\\n                inStream = Cc[\\'@mozilla.org/network/file-input-stream;1\\']\\n                           .createInstance(Ci.nsIFileInputStream);\\n                inStream.init(fileObj, 1, 0, false);\\n\\n                convertStream = Cc[\\'@mozilla.org/intl/converter-input-stream;1\\']\\n                                .createInstance(Ci.nsIConverterInputStream);\\n                convertStream.init(inStream, \\\"utf-8\\\", inStream.available(),\\n                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);\\n\\n                convertStream.readString(inStream.available(), readData);\\n                convertStream.close();\\n                inStream.close();\\n                callback(readData.value);\\n            } catch (e) {\\n                throw new Error((fileObj && fileObj.path || \\'\\') + \\': \\' + e);\\n            }\\n        };\\n    }\\n    return text;\\n});\\n\\n//# sourceURL=/var/src/brackets/brackets-src/src/thirdparty/text/text.js\");\n\n","\neval(\"define(\\'text!BezierCurveEditorTemplate.html\\',[],function () { return \\'<div tabindex=\\\"-1\\\" class=\\\"bezier-curve-editor\\\">\\\\n    <div class=\\\"cubic-bezier\\\">\\\\n        <div class=\\\"coordinate-plane\\\">\\\\n            <span   class=\\\"control-point P0\\\"></span>\\\\n            <button class=\\\"control-point P1\\\"></button>\\\\n            <button class=\\\"control-point P2\\\"></button>\\\\n            <span   class=\\\"control-point P3\\\"></span>\\\\n            <canvas height=\\\"300\\\" width=\\\"150\\\" class=\\\"curve\\\"></canvas>\\\\n        </div>\\\\n        <div class=\\\"info\\\">\\\\n            <p>{{{BEZIER_EDITOR_INFO}}}</p>\\\\n            <div class=\\\"hint\\\"></div>\\\\n        </div>\\\\n    </div>\\\\n</div>\\\\n\\';});\\n\\n//# sourceURL=/text!BezierCurveEditorTemplate.html\");\n\n","\neval(\"define(\\'text!StepEditorTemplate.html\\',[],function () { return \\'<div tabindex=\\\"-1\\\" class=\\\"step-editor\\\">\\\\n    <div class=\\\"steps-func\\\">\\\\n        <div class=\\\"coordinate-plane\\\">\\\\n            <canvas height=\\\"180\\\" width=\\\"180\\\" class=\\\"steps\\\" tabindex=\\\"1\\\"></canvas>\\\\n        </div>\\\\n        <div class=\\\"info\\\">\\\\n            <p>{{{STEPS_EDITOR_INFO}}}</p>\\\\n            <div class=\\\"hint\\\"></div>\\\\n        </div>\\\\n    </div>\\\\n</div>\\\\n\\';});\\n\\n//# sourceURL=/text!StepEditorTemplate.html\");\n\n","eval(\"/*\\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\\n *  \\n * Permission is hereby granted, free of charge, to any person obtaining a\\n * copy of this software and associated documentation files (the \\\"Software\\\"), \\n * to deal in the Software without restriction, including without limitation \\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \\n * and/or sell copies of the Software, and to permit persons to whom the \\n * Software is furnished to do so, subject to the following conditions:\\n *  \\n * The above copyright notice and this permission notice shall be included in\\n * all copies or substantial portions of the Software.\\n *  \\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \\n * DEALINGS IN THE SOFTWARE.\\n * \\n */\\n\\n/*jslint vars: true, plusplus: true, nomen: true, regexp: true, maxerr: 50 */\\n/*global define, brackets, $, window, Mustache */\\n\\ndefine(\\'StepEditor\\',[\\'require\\',\\'exports\\',\\'module\\',\\'TimingFunctionUtils\\',\\'text!StepEditorTemplate.html\\'],function (require, exports, module) {\\n    \\\"use strict\\\";\\n    \\n    var KeyEvent    = brackets.getModule(\\\"utils/KeyEvent\\\"),\\n        Strings     = brackets.getModule(\\\"strings\\\");\\n\\n    var TimingFunctionUtils = require(\\\"TimingFunctionUtils\\\");\\n    \\n    /** Mustache template that forms the bare DOM structure of the UI */\\n    var StepEditorTemplate   = require(\\\"text!StepEditorTemplate.html\\\");\\n    \\n    /** @const @type {number} */\\n    var STEP_LINE   = 1,\\n        DASH_LINE   = 2;\\n\\n    /**\\n     * StepParameters object constructor\\n     *\\n     * @param {{ count: number, timing: string}} params Parameters passed to steps()\\n     *      either in string or array format.\\n     */\\n    function StepParameters(params) {\\n        if (!params) {\\n            throw \\\"No parameters were defined\\\";\\n        }\\n\\n        this.count  = params.count;\\n        this.timing = params.timing;\\n    }\\n    \\n    /**\\n     * StepCanvas object constructor\\n     *\\n     * @param {Element} canvas Inline editor <canvas> element\\n     * @param {StepParameters} stepParams Associated StepParameters object\\n     * @param {number|Array.number} padding Element padding\\n     */\\n    function StepCanvas(canvas, stepParams, padding) {\\n        this.canvas     = canvas;\\n        this.stepParams = stepParams;\\n        this.padding    = this.getPadding(padding);\\n\\n        // Convert to a cartesian coordinate system with axes from 0 to 1\\n        var ctx = this.canvas.getContext(\\\"2d\\\"),\\n            p = this.padding;\\n\\n        ctx.scale(canvas.width * (1 - p[1] - p[3]), -canvas.height * (1 - p[0] - p[2]));\\n        ctx.translate(p[3] / (1 - p[1] - p[3]), (-1 - p[0] / (1 - p[0] - p[2])));\\n    }\\n\\n    StepCanvas.prototype = {\\n\\n        drawBackground: function () {\\n            this.ctx.beginPath();\\n            this.ctx.lineWidth   = this.settings.borderWidth;\\n            this.ctx.strokeStyle = this.settings.borderColor;\\n            this.ctx.fillStyle = this.settings.bgColor;\\n            this.ctx.moveTo(0, 0);\\n            this.ctx.lineTo(0, 1);\\n            this.ctx.lineTo(1, 1);\\n            this.ctx.lineTo(1, 0);\\n            this.ctx.lineTo(0, 0);\\n            this.ctx.stroke();\\n            this.ctx.fill();\\n            this.ctx.closePath();\\n        },\\n\\n        drawPoint: function (x, y, isFilled) {\\n            // Points are always step color\\n            this.ctx.beginPath();\\n            this.ctx.lineWidth   = this.settings.pointLineWidth;\\n            this.ctx.strokeStyle = this.settings.stepColor;\\n            this.ctx.arc(x, y, this.settings.pointRadius, 0, 2 * Math.PI, false);\\n            this.ctx.stroke();\\n            if (isFilled) {\\n                this.ctx.fillStyle = this.settings.stepColor;\\n                this.ctx.fill();\\n            }\\n            this.ctx.closePath();\\n        },\\n\\n        drawLine: function (x1, y1, x2, y2, type) {\\n            this.ctx.beginPath();\\n            if (type === STEP_LINE) {\\n                this.ctx.lineWidth   = this.settings.stepLineWidth;\\n                this.ctx.strokeStyle = this.settings.stepColor;\\n            } else if (type === DASH_LINE) {\\n                this.ctx.lineWidth   = this.settings.dashLineWidth;\\n                this.ctx.strokeStyle = this.settings.dashColor;\\n            }\\n            this.ctx.moveTo(x1, y1);\\n            this.ctx.lineTo(x2, y2);\\n            this.ctx.stroke();\\n            this.ctx.closePath();\\n        },\\n\\n        drawStartInterval: function (x1, y1, x2, y2) {\\n            var pr = this.settings.pointRadius;\\n\\n            // Draw empty start point\\n            this.drawPoint(x1, y1, false);\\n\\n            // Draw dashed line up to next step\\n            this.drawLine(x1, y1 + pr, x1, y2, DASH_LINE);\\n\\n            // Draw filled mid point\\n            this.drawPoint(x1, y2, true);\\n\\n            // Draw step line\\n            this.drawLine(x1, y2, x2 - pr, y2, STEP_LINE);\\n        },\\n\\n        drawEndInterval: function (x1, y1, x2, y2) {\\n            var pr = this.settings.pointRadius;\\n\\n            // Draw filled start point\\n            this.drawPoint(x1, y1, true);\\n\\n            // Draw step line\\n            this.drawLine(x1, y1, x2 - pr, y1, STEP_LINE);\\n\\n            // Draw empty mid point\\n            this.drawPoint(x2, y1, false);\\n\\n            // Draw dashed line up to next step\\n            this.drawLine(x2, y1 + pr, x2, y2, DASH_LINE);\\n        },\\n\\n        /**\\n         * Paint canvas\\n         *\\n         * @param {Object} settings Paint settings\\n         */\\n        plot: function (settings) {\\n            var setting, i, j, last, interval,\\n                sp = this.stepParams,\\n                isStart = (sp.timing === \\\"start\\\"),\\n                p = [];\\n\\n            var defaultSettings = {\\n                bgColor:        \\\"transparent\\\",\\n                borderColor:    \\\"#bbb\\\",\\n                stepColor:      \\\"#2893ef\\\",\\n                dashColor:      \\\"#b8b8b8\\\",\\n                borderWidth:    0.00667,\\n                stepLineWidth:  0.02,\\n                dashLineWidth:  0.008,\\n                pointLineWidth: 0.008,\\n                pointRadius:    0.015\\n            };\\n\\n            this.settings = settings || {};\\n\\n            for (setting in defaultSettings) {\\n                if (defaultSettings.hasOwnProperty(setting)) {\\n                    if (!this.settings.hasOwnProperty(setting)) {\\n                        this.settings[setting] = defaultSettings[setting];\\n                    }\\n                }\\n            }\\n\\n            this.ctx = this.canvas.getContext(\\\"2d\\\");\\n\\n            // Build points array. There\\'s a starting point at 0,0\\n            // plus a point for each step\\n            p[0] = { x: 0, y: 0 };\\n            for (i = 1; i <= sp.count; i++) {\\n                interval = i / sp.count;\\n                p[i] = { x: interval, y: interval };\\n            }\\n\\n            // Start with a clean slate\\n            this.ctx.clearRect(-0.5, -0.5, 2, 2);\\n            this.drawBackground();\\n\\n            // Draw each interval\\n            last = p.length - 1;\\n            for (i = 0, j = 1; i < last; i++, j++) {\\n                if (isStart) {\\n                    this.drawStartInterval(p[i].x, p[i].y, p[j].x, p[j].y);\\n                } else {\\n                    this.drawEndInterval(p[i].x, p[i].y, p[j].x, p[j].y);\\n                }\\n            }\\n\\n            // Each interval draws start and mid point for that interval,\\n            // so we need to draw last point. It\\'s always filled.\\n            this.drawPoint(p[last].x, p[last].y, true);\\n        },\\n\\n        /**\\n         * Convert CSS padding shorthand to longhand\\n         *\\n         * @param {number|Array.number} padding Element padding\\n         * @return {Array.number}\\n         */\\n        getPadding: function (padding) {\\n            var p = (typeof padding === \\\"number\\\") ? [padding] : padding;\\n\\n            if (p.length === 1) {\\n                p[1] = p[0];\\n            }\\n            if (p.length === 2) {\\n                p[2] = p[0];\\n            }\\n            if (p.length === 3) {\\n                p[3] = p[1];\\n            }\\n\\n            return p;\\n        }\\n    };\\n\\n    // Event handlers\\n    \\n    /**\\n     * Handle key down in <canvas> element\\n     *\\n     * @param {Event} e Key down event\\n     */\\n    function _canvasKeyDown(e) {\\n        var code = e.keyCode,\\n            self = e.target,\\n            stepEditor = self.stepEditor;\\n\\n        if (code >= KeyEvent.DOM_VK_LEFT && code <= KeyEvent.DOM_VK_DOWN) {\\n            e.preventDefault();\\n\\n            // Arrow keys pressed\\n            switch (code) {\\n            case KeyEvent.DOM_VK_LEFT:\\n                stepEditor.stepCanvas.stepParams.timing = \\\"start\\\";\\n                break;\\n            case KeyEvent.DOM_VK_UP:\\n                // No upper limit\\n                stepEditor.stepCanvas.stepParams.count++;\\n                break;\\n            case KeyEvent.DOM_VK_RIGHT:\\n                stepEditor.stepCanvas.stepParams.timing = \\\"end\\\";\\n                break;\\n            case KeyEvent.DOM_VK_DOWN:\\n                if (stepEditor.stepCanvas.stepParams.count > 1) {\\n                    stepEditor.stepCanvas.stepParams.count--;\\n                }\\n                break;\\n            }\\n\\n            // update step params\\n            stepEditor._stepParams = stepEditor.stepCanvas.stepParams;\\n\\n            stepEditor._commitTimingFunction();\\n            stepEditor._updateCanvas();\\n            return true;\\n\\n        } else if (code === KeyEvent.DOM_VK_ESCAPE) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n\\n    /**\\n     * Constructor for StepEditor Object. This control may be used standalone\\n     * or within an InlineTimingFunctionEditor inline widget.\\n     *\\n     * @param {!jQuery} $parent  DOM node into which to append the root of the step editor UI\\n     * @param {!RegExpMatch} stepMatch  RegExp match object of initially selected step function\\n     * @param {!function(string)} callback  Called whenever selected step function changes\\n     */\\n    function StepEditor($parent, stepMatch, callback) {\\n        // Create the DOM structure, filling in localized strings via Mustache\\n        this.$element = $(Mustache.render(StepEditorTemplate, Strings));\\n        $parent.append(this.$element);\\n        \\n        this._callback = callback;\\n\\n        // current step function params\\n        this._stepParams = this._getStepParams(stepMatch);\\n\\n        this.hint = {};\\n        this.hint.elem = $(\\\".hint\\\", this.$element);\\n        // If function was auto-corrected, then originalString holds the original function,\\n        // and an informational message needs to be shown\\n        if (stepMatch.originalString) {\\n            TimingFunctionUtils.showHideHint(this.hint, true, stepMatch.originalString, \\\"steps(\\\" + this._stepParams.count.toString() + \\\", \\\" + this._stepParams.timing + \\\")\\\");\\n        } else {\\n            TimingFunctionUtils.showHideHint(this.hint, false);\\n        }\\n\\n        this.canvas = this.$element.find(\\\".steps\\\")[0];\\n\\n        this.canvas.stepEditor = this;\\n\\n        // Padding (3rd param)is scaled, so 0.1 translates to 15px\\n        // Note that this is rendered inside canvas CSS \\\"content\\\"\\n        // (i.e. this does not map to CSS padding)\\n        this.stepCanvas = new StepCanvas(this.canvas, null, [0.1]);\\n      \\n        // redraw canvas\\n        this._updateCanvas();\\n\\n        $(this.canvas).on(\\\"keydown\\\", _canvasKeyDown);\\n    }\\n\\n    /**\\n     * Destructor called by InlineTimingFunctionEditor.onClosed()\\n     */\\n    StepEditor.prototype.destroy = function () {\\n        this.canvas.stepEditor = null;\\n        $(this.canvas).off(\\\"keydown\\\", _canvasKeyDown);\\n    };\\n\\n\\n    /** Returns the root DOM node of the StepEditor UI */\\n    StepEditor.prototype.getRootElement = function () {\\n        return this.$element;\\n    };\\n\\n    /**\\n     * Default focus needs to go somewhere, so give it to canvas\\n     */\\n    StepEditor.prototype.focus = function () {\\n        this.canvas.focus();\\n        return true;\\n    };\\n\\n    /**\\n     * Generates step function based on parameters, and updates the doc\\n     */\\n    StepEditor.prototype._commitTimingFunction = function () {\\n        var stepFuncVal = \\\"steps(\\\" +\\n            this._stepParams.count.toString() + \\\", \\\" +\\n            this._stepParams.timing + \\\")\\\";\\n        this._callback(stepFuncVal);\\n        TimingFunctionUtils.showHideHint(this.hint, false);\\n    };\\n\\n    /**\\n     * Handle all matches returned from TimingFunctionUtils.stepMatch() and\\n     * return array of coords\\n     *\\n     * @param {RegExp.match} match Matches returned from stepMatch()\\n     * @return {{count: number, timing: string}}\\n     */\\n    StepEditor.prototype._getStepParams = function (match) {\\n\\n        if (match[0].match(/^steps/)) {\\n            // steps()\\n            return {\\n                count:  parseInt(match[1], 10),\\n                timing: match[2] || \\\"end\\\"\\n            };\\n        } else {\\n            // handle special cases of steps functions\\n            switch (match[0]) {\\n            case \\\"step-start\\\":\\n                return { count: 1, timing: \\\"start\\\" };\\n            case \\\"step-end\\\":\\n                return { count: 1, timing: \\\"end\\\" };\\n            }\\n        }\\n\\n        window.console.log(\\\"step timing function: _getStepParams() passed invalid RegExp match array\\\");\\n        return { count: 1, timing: \\\"end\\\" };\\n    };\\n\\n    /**\\n     * Get <canvas> element\\'s bounding box\\n     *\\n     * @return {left: number, top: number, width: number, height: number}\\n     */\\n    StepEditor.prototype._getCanvasBoundingBox = function () {\\n        var $canvas = this.$element.find(\\\".steps\\\"),\\n            canvasOffset = $canvas.offset();\\n\\n        return {\\n            left:    canvasOffset.left,\\n            top:     canvasOffset.top,\\n            width:   $canvas.width(),\\n            height:  $canvas.height()\\n        };\\n    };\\n\\n    /**\\n     * Update <canvas> after a change\\n     */\\n    StepEditor.prototype._updateCanvas = function () {\\n        // collect data, build model\\n        if (this._stepParams) {\\n            this.stepCanvas.stepParams = window.stepParams = new StepParameters(this._stepParams);\\n\\n            this.stepCanvas.plot();\\n        }\\n    };\\n    \\n    /**\\n     * Handle external update\\n     *\\n     * @param {!RegExpMatch} stepMatch  RegExp match object of updated step function\\n     */\\n    StepEditor.prototype.handleExternalUpdate = function (stepMatch) {\\n        this._stepParams = this._getStepParams(stepMatch);\\n        this._updateCanvas();\\n        // If function was auto-corrected, then originalString holds the original function,\\n        // and an informational message needs to be shown\\n        if (stepMatch.originalString) {\\n            TimingFunctionUtils.showHideHint(this.hint, true, stepMatch.originalString, \\\"steps(\\\" + this._stepParams.count.toString() + \\\", \\\" + this._stepParams.timing + \\\")\\\");\\n        } else {\\n            TimingFunctionUtils.showHideHint(this.hint, false);\\n        }\\n    };\\n\\n    \\n    exports.StepEditor = StepEditor;\\n});\\n\\n//# sourceURL=/StepEditor.js\");\n\n","\neval(\"define(\\'text!Localized.css\\',[],function () { return \\'.bezier-curve-editor .coordinate-plane:after,\\\\n.step-editor .coordinate-plane:after {\\\\n    content: \\\\\\'{{INLINE_TIMING_EDITOR_TIME}}\\\\\\';\\\\n}\\\\n\\\\n.bezier-curve-editor .coordinate-plane:hover:before {\\\\n    content: \\\\\\'{{INLINE_TIMING_EDITOR_PROGRESSION}} (\\\\\\' attr(data-progression) \\\\\\'%)\\\\\\';\\\\n}\\\\n\\\\n.bezier-curve-editor .coordinate-plane:before,\\\\n.step-editor .coordinate-plane:before {\\\\n    content: \\\\\\'{{INLINE_TIMING_EDITOR_PROGRESSION}}\\\\\\';\\\\n}\\\\n\\\\n.bezier-curve-editor .coordinate-plane:hover:after {\\\\n    content: \\\\\\'{{INLINE_TIMING_EDITOR_TIME}} (\\\\\\' attr(data-time) \\\\\\'%)\\\\\\';\\\\n}\\\\n\\';});\\n\\n//# sourceURL=/text!Localized.css\");\n\n","eval(\"/*\\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a\\n * copy of this software and associated documentation files (the \\\"Software\\\"),\\n * to deal in the Software without restriction, including without limitation\\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\\n * and/or sell copies of the Software, and to permit persons to whom the\\n * Software is furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in\\n * all copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\\n * DEALINGS IN THE SOFTWARE.\\n */\\n\\n/*\\n * The timing function canvas and editing code was adapted from Lea Verou\\'s cubic-bezier project:\\n * - https://github.com/LeaVerou/cubic-bezier (cubic-bezier.com)\\n * \\n * The canvas exceeds the top and bottom of main grid so y-value of points can be\\n * dragged outside of the 0-1 range.\\n * \\n *   . . . . . .\\n *   .         .\\n *   +---------+\\n *   |         |\\n *   |         |\\n *   |         |\\n *   |         |\\n *   +---------+ <-- main grid has height of 150\\n *   .         .\\n *   . . . . . . <-- canvas has height of 300 (extra 75 above/below)\\n * \\n */\\n\\n/*jslint vars: true, plusplus: true, devel: true, nomen: true,  regexp: true, indent: 4, maxerr: 50 */\\n/*global define, brackets, $, Mustache */\\n\\ndefine(\\'main\\',[\\'require\\',\\'exports\\',\\'module\\',\\'InlineTimingFunctionEditor\\',\\'TimingFunctionUtils\\',\\'text!Localized.css\\'],function (require, exports, module) {\\n    \\\"use strict\\\";\\n\\n    // Brackets modules\\n    var EditorManager       = brackets.getModule(\\\"editor/EditorManager\\\"),\\n        ExtensionUtils      = brackets.getModule(\\\"utils/ExtensionUtils\\\"),\\n        Strings             = brackets.getModule(\\\"strings\\\"),\\n\\n        InlineTimingFunctionEditor = require(\\\"InlineTimingFunctionEditor\\\").InlineTimingFunctionEditor,\\n        TimingFunctionUtils        = require(\\\"TimingFunctionUtils\\\"),\\n        Localized                  = require(\\\"text!Localized.css\\\");\\n\\n    \\n    // Functions\\n\\n\\n    /**\\n     * Prepare hostEditor for an InlineTimingFunctionEditor at pos if possible.\\n     * Return editor context if so; otherwise null.\\n     *\\n     * @param {Editor} hostEditor\\n     * @param {{line:Number, ch:Number}} pos\\n     * @return {timingFunction:{?string}, reason:{?string}, start:{?TextMarker}, end:{?TextMarker}}\\n     */\\n    function prepareEditorForProvider(hostEditor, pos) {\\n        var cursorLine, sel, startPos, endPos, startBookmark, endBookmark, currentMatch,\\n            cm = hostEditor._codeMirror;\\n\\n        sel = hostEditor.getSelection();\\n        if (sel.start.line !== sel.end.line) {\\n            return {timingFunction: null, reason: null};\\n        }\\n        \\n        cursorLine = hostEditor.document.getLine(pos.line);\\n        \\n        // code runs several matches complicated patterns, multiple times, so\\n        // first do a quick, simple check to see make sure we may have a match\\n        if (!cursorLine.match(/cubic-bezier|linear|ease|step/)) {\\n            return {timingFunction: null, reason: null};\\n        }\\n\\n        currentMatch = TimingFunctionUtils.timingFunctionMatch(cursorLine, false);\\n        if (!currentMatch) {\\n            return {timingFunction: null, reason: Strings.ERROR_TIMINGQUICKEDIT_INVALIDSYNTAX};\\n        }\\n        \\n        // check for subsequent matches, and use first match after pos\\n        var lineOffset = 0,\\n            matchLength = ((currentMatch.originalString && currentMatch.originalString.length) || currentMatch[0].length);\\n        while (pos.ch > (currentMatch.index + matchLength + lineOffset)) {\\n            var restOfLine = cursorLine.substring(currentMatch.index + matchLength + lineOffset),\\n                newMatch = TimingFunctionUtils.timingFunctionMatch(restOfLine, false);\\n\\n            if (newMatch) {\\n                lineOffset += (currentMatch.index + matchLength);\\n                currentMatch = $.extend(true, [], newMatch);\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        currentMatch.lineOffset = lineOffset;\\n\\n        startPos = {line: pos.line, ch: lineOffset + currentMatch.index};\\n        endPos   = {line: pos.line, ch: lineOffset + currentMatch.index + matchLength};\\n        \\n        startBookmark = cm.setBookmark(startPos);\\n        endBookmark   = cm.setBookmark(endPos);\\n        \\n        // Adjust selection to the match so that the inline editor won\\'t\\n        // get dismissed while we\\'re updating the timing function.\\n        hostEditor.setSelection(startPos, endPos);\\n        \\n        return {\\n            timingFunction: currentMatch,\\n            start: startBookmark,\\n            end: endBookmark\\n        };\\n    }\\n    \\n    /**\\n     * Registered as an inline editor provider: creates an InlineTimingFunctionEditor\\n     * when the cursor is on a timing function value.\\n     *\\n     * @param {!Editor} hostEditor\\n     * @param {!{line:Number, ch:Number}} pos\\n     * @return {?$.Promise} synchronously resolved with an InlineWidget, or\\n     *         {string} if timing function with invalid syntax is detected at pos, or\\n     *         null if there\\'s no timing function at pos.\\n     */\\n    function inlineTimingFunctionEditorProvider(hostEditor, pos) {\\n        var context = prepareEditorForProvider(hostEditor, pos),\\n            inlineTimingFunctionEditor,\\n            result;\\n        \\n        if (!context.timingFunction) {\\n            return context.reason || null;\\n        } else {\\n            inlineTimingFunctionEditor = new InlineTimingFunctionEditor(context.timingFunction, context.start, context.end);\\n            inlineTimingFunctionEditor.load(hostEditor);\\n    \\n            result = new $.Deferred();\\n            result.resolve(inlineTimingFunctionEditor);\\n            return result.promise();\\n        }\\n    }\\n    \\n    /**\\n     * Initialization code\\n     */\\n    function init() {\\n        // Load our stylesheet\\n        ExtensionUtils.loadStyleSheet(module, \\\"main.less\\\");\\n        ExtensionUtils.addEmbeddedStyleSheet(Mustache.render(Localized, Strings));\\n    \\n        EditorManager.registerInlineEditProvider(inlineTimingFunctionEditorProvider);\\n    }\\n\\n    init();\\n\\n    \\n    // for unit tests only\\n    exports.inlineTimingFunctionEditorProvider = inlineTimingFunctionEditorProvider;\\n});\\n\\n//# sourceURL=/main.js\");\n\n"]}