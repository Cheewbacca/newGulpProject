eval('/*\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n *  \n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the "Software"), \n * to deal in the Software without restriction, including without limitation \n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \n * and/or sell copies of the Software, and to permit persons to whom the \n * Software is furnished to do so, subject to the following conditions:\n *  \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *  \n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \n * DEALINGS IN THE SOFTWARE.\n * \n */\n\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\n/*global define, brackets */\n\n/**\n *  Utilities functions related to color matching\n */\ndefine(\'TimingFunctionUtils\',[\'require\',\'exports\',\'module\'],function (require, exports, module) {\n    "use strict";\n    \n    var Strings         = brackets.getModule("strings"),\n        StringUtils     = brackets.getModule("utils/StringUtils"),\n        AnimationUtils  = brackets.getModule("utils/AnimationUtils");\n    \n    /**\n     * Regular expressions for matching timing functions\n     * @const @type {RegExp}\n     */\n    var BEZIER_CURVE_VALID_REGEX        = /cubic-bezier\\(\\s*(\\S+)\\s*,\\s*(\\S+)\\s*,\\s*(\\S+)\\s*,\\s*(\\S+)\\s*\\)/,\n        BEZIER_CURVE_GENERAL_REGEX      = /cubic-bezier\\((.*)\\)/,\n        EASE_STRICT_REGEX               = /[: ,]ease(?:-in)?(?:-out)?[ ,;]/,\n        EASE_LAX_REGEX                  = /ease(?:-in)?(?:-out)?/,\n        LINEAR_STRICT_REGEX             = /transition.*?[: ,]linear[ ,;]/,\n        LINEAR_LAX_REGEX                = /linear/,\n        STEPS_VALID_REGEX               = /steps\\(\\s*(\\d+)\\s*(?:,\\s*(\\w+)\\s*)?\\)/,\n        STEPS_GENERAL_REGEX             = /steps\\((.*)\\)/,\n        STEP_STRICT_REGEX               = /[: ,](?:step-start|step-end)[ ,;]/,\n        STEP_LAX_REGEX                  = /step-start|step-end/;\n\n    /**\n     * Type constants\n     * @const @type {number}\n     */\n    var BEZIER  = 1,\n        STEP    = 2;\n\n    /**\n     * If string is a number, then convert it.\n     *\n     * @param {string} str  value parsed from page.\n     * @return { isNumber: boolean, value: ?number }\n     */\n    function _convertToNumber(str) {\n        if (typeof str !== "string") {\n            return { isNumber: false, value: null };\n        }\n\n        var val = parseFloat(+str, 10),\n            isNum = (typeof val === "number") && !isNaN(val) &&\n                    (val !== Infinity) && (val !== -Infinity);\n\n        return {\n            isNumber: isNum,\n            value:    val\n        };\n    }\n\n    /**\n     * Get valid params for an invalid cubic-bezier.\n     *\n     * @param {RegExp.match} match (Invalid) matches from cubicBezierMatch()\n     * @return {?RegExp.match} Valid match or null if the output is not valid\n     */\n    function _getValidBezierParams(match) {\n        var param,\n            // take ease-in-out as default value in case there are no params yet (or they are invalid)\n            def = [ ".42", "0", ".58", "1" ],\n            oldIndex = match.index, // we need to store the old match.index to re-set the index afterwards\n            originalString = match[0],\n            i;\n\n        if (match) {\n            match = match[1].split(",");\n        }\n        \n        if (match) {\n            for (i = 0; i <= 3; i++) {\n                if (match[i]) {\n                    match[i] = match[i].trim();\n                    param = _convertToNumber(match[i]);\n\n                    // Verify the param is a number\n                    // If not, replace it with the default value\n                    if (!param.isNumber) {\n                        match[i] = undefined;\n\n                    // Verify x coordinates are in 0-1 range\n                    // If not, set them to the closest value in range\n                    } else if (i === 0 || i === 2) {\n                        if (param.value < 0) {\n                            match[i] = "0";\n                        } else if (param.value > 1) {\n                            match[i] = "1";\n                        }\n                    }\n                }\n\n                if (!match[i]) {\n                    match[i] = def[i];\n                }\n            }\n        } else {\n            match = def;\n        }\n        match = match.splice(0, 4); // make sure there are only 4 params\n        match = "cubic-bezier(" + match.join(", ") + ")";\n        match = match.match(BEZIER_CURVE_VALID_REGEX);\n\n        if (match) {\n            match.index = oldIndex; // re-set the index here to get the right context\n            match.originalString = originalString;\n            return match;\n        }\n        return null;\n    }\n\n    /**\n     * Validate cubic-bezier function parameters that are not already validated by regex:\n     *\n     * @param {RegExp.match} match  RegExp Match object with cubic-bezier function parameters\n     *                              in array positions 1-4.\n     * @return {boolean} true if all parameters are valid, otherwise, false\n     */\n    function _validateCubicBezierParams(match) {\n        var x1 = _convertToNumber(match[1]),\n            y1 = _convertToNumber(match[2]),\n            x2 = _convertToNumber(match[3]),\n            y2 = _convertToNumber(match[4]);\n\n        // Verify all params are numbers\n        if (!x1.isNumber || !y1.isNumber || !x2.isNumber || !y2.isNumber) {\n            return false;\n        }\n\n        // Verify x params are in 0-1 range\n        if (x1.value < 0 || x1.value > 1 || x2.value < 0 || x2.value > 1) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get valid params for an invalid steps function.\n     *\n     * @param {RegExp.match} match (Invalid) matches from stepsMatch()\n     * @return {?RegExp.match} Valid match or null if the output is not valid\n     */\n    function _getValidStepsParams(match) {\n        var param,\n            def = [ "5", "end" ],\n            params = def,\n            oldIndex = match.index, // we need to store the old match.index to re-set the index afterwards\n            originalString = match[0];\n\n        if (match) {\n            match = match[1].split(",");\n        }\n\n        if (match) {\n            if (match[0]) {\n                param = match[0].replace(/[\\s\\"\']/g, ""); // replace possible trailing whitespace or leading quotes\n                param = _convertToNumber(param);\n\n                // Verify number_of_params is a number\n                // If not, replace it with the default value\n                if (!param.isNumber) {\n                    param.value = def[0];\n\n                // Round number_of_params to an integer\n                } else if (param.value) {\n                    param.value = Math.floor(param.value);\n                }\n\n                // Verify number_of_steps is >= 1\n                // If not, set them to the default value\n                if (param.value < 1) {\n                    param.value = def[0];\n                }\n                params[0] = param.value;\n            }\n            if (match[1]) {\n                // little autocorrect feature: leading s gets \'start\', everything else gets \'end\'\n                param = match[1].replace(/[\\s\\"\']/g, ""); // replace possible trailing whitespace or leading quotes\n                param = param.substr(0, 1);\n                if (param === "s") {\n                    params[1] = "start";\n                } else {\n                    params[1] = "end";\n                }\n            }\n        }\n        params = "steps(" + params.join(", ") + ")";\n        params = params.match(STEPS_VALID_REGEX);\n\n        if (params) {\n            params.index = oldIndex; // re-set the index here to get the right context\n            params.originalString = originalString;\n            return params;\n        }\n        return null;\n    }\n\n    /**\n     * Validate steps function parameters that are not already validated by regex:\n     *\n     * @param {RegExp.match} match  RegExp Match object with steps function parameters\n     *                              in array position 1 (and optionally 2).\n     * @return {boolean} true if all parameters are valid, otherwise, false\n     */\n    function _validateStepsParams(match) {\n        var count = _convertToNumber(match[1]);\n\n        if (!count.isNumber || count.value < 1 || Math.floor(count.value) !== count.value) {\n            return false;\n        }\n\n        if (match[2] && match[2] !== "start" && match[2] !== "end") {\n            return false;\n        }\n\n        return true;\n    }\n    \n    /**\n     * Show, hide or update the hint text\n     * \n     * @param {object} hint Editor.hint object of the current InlineTimingFunctionEditor\n     * @param {boolean} show Whether the hint should be shown or hidden\n     * @param {string=} documentCode The invalid code from the document (can be omitted when hiding)\n     * @param {string=} editorCode The valid code that is shown in the Inline Editor (can be omitted when hiding)\n     */\n    function showHideHint(hint, show, documentCode, editorCode) {\n        if (!hint || !hint.elem) {\n            return;\n        }\n        \n        if (show) {\n            hint.shown = true;\n            hint.animationInProgress = false;\n            hint.elem.removeClass("fadeout");\n            hint.elem.html(StringUtils.format(Strings.INLINE_TIMING_EDITOR_INVALID, documentCode, editorCode));\n            hint.elem.css("display", "block");\n        } else if (hint.shown) {\n            hint.animationInProgress = true;\n            AnimationUtils.animateUsingClass(hint.elem[0], "fadeout", 750)\n                .done(function () {\n                    if (hint.animationInProgress) { // do this only if the animation was not cancelled\n                        hint.elem.hide();\n                    }\n                    hint.shown = false;\n                    hint.animationInProgress = false;\n                });\n        } else {\n            hint.elem.hide();\n        }\n    }\n\n    /**\n     * Tag this match with type and return it for chaining\n     *\n     * @param {!RegExp.match} match  RegExp Match object with steps function parameters\n     *                              in array position 1 (and optionally 2).\n     * @param {number} type Either BEZIER or STEP\n     * @return {RegExp.match} Same object that was passed in.\n     */\n    function _tagMatch(match, type) {\n        switch (type) {\n        case BEZIER:\n            match.isBezier = true;\n            break;\n        case STEP:\n            match.isStep = true;\n            break;\n        }\n        \n        return match;\n    }\n\n    /**\n     * Match a bezier curve function value from a CSS Declaration or Value.\n     *\n     * Matches returned from this function must be handled in\n     * BezierCurveEditor._getCubicBezierCoords().\n     *\n     * @param {string} str  Input string.\n     * @param {!boolean} lax  Parsing mode where:\n     *          lax=false Input is a Full or partial line containing CSS Declaration.\n     *                    This is the more strict search used for initial detection.\n     *          lax=true  Input is a previously parsed value. This is the less strict search\n     *                    used to convert previously parsed values to RegExp match format.\n     * @return {!RegExpMatch}\n     */\n    function bezierCurveMatch(str, lax) {\n        var match;\n\n        // First look for any cubic-bezier().\n        match = str.match(BEZIER_CURVE_VALID_REGEX);\n        if (match && _validateCubicBezierParams(match)) { // cubic-bezier() with valid params\n            return _tagMatch(match, BEZIER);\n        }\n\n        match = str.match(BEZIER_CURVE_GENERAL_REGEX);\n        if (match) {\n            match = _getValidBezierParams(match);\n            if (match && _validateCubicBezierParams(match)) {\n                return _tagMatch(match, BEZIER);\n            } else { // this should not happen!\n                window.console.log("brackets-cubic-bezier: TimingFunctionUtils._getValidBezierParams created invalid code");\n            }\n        }\n\n        // Next look for the ease functions (which are special cases of cubic-bezier())\n        if (lax) {\n            // For lax parsing, just look for the keywords\n            match = str.match(EASE_LAX_REGEX);\n            if (match) {\n                return _tagMatch(match, BEZIER);\n            }\n        } else {\n            // For strict parsing, start with a syntax verifying search\n            match = str.match(EASE_STRICT_REGEX);\n            if (match) {\n                // return exact match to keyword that we need for later replacement\n                return _tagMatch(str.match(EASE_LAX_REGEX), BEZIER);\n            }\n        }\n\n        // Final case is linear.\n        if (lax) {\n            // For lax parsing, just look for the keyword\n            match = str.match(LINEAR_LAX_REGEX);\n            if (match) {\n                return _tagMatch(match, BEZIER);\n            }\n        } else {\n            // The linear keyword can occur in other values, so for strict parsing we\n            // only detect when it\'s on same line as "transition"\n            match = str.match(LINEAR_STRICT_REGEX);\n            if (match) {\n                // return exact match to keyword that we need for later replacement\n                return _tagMatch(str.match(LINEAR_LAX_REGEX), BEZIER);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Match a steps function value from a CSS Declaration or Value.\n     *\n     * Matches returned from this function must be handled in\n     * BezierCurveEditor._getCubicBezierCoords().\n     *\n     * @param {string} str  Input string.\n     * @param {!boolean} lax  Parsing mode where:\n     *          lax=false Input is a Full or partial line containing CSS Declaration.\n     *                    This is the more strict search used for initial detection.\n     *          lax=true  Input is a previously parsed value. This is the less strict search\n     *                    used to convert previously parsed values to RegExp match format.\n     * @return {!RegExpMatch}\n     */\n    function stepsMatch(str, lax) {\n        var match;\n\n        // First look for any steps().\n        match = str.match(STEPS_VALID_REGEX);\n        if (match && _validateStepsParams(match)) { // cubic-bezier() with valid params\n            return _tagMatch(match, STEP);\n        }\n\n        match = str.match(STEPS_GENERAL_REGEX);\n        if (match) {\n            match = _getValidStepsParams(match);\n            if (match && _validateStepsParams(match)) {\n                return _tagMatch(match, STEP);\n            } else { // this should not happen!\n                window.console.log("brackets-steps: TimingFunctionUtils._getValidStepsParams created invalid code");\n            }\n        }\n\n        // Next look for the step functions (which are special cases of steps())\n        if (lax) {\n            // For lax parsing, just look for the keywords\n            match = str.match(STEP_LAX_REGEX);\n            if (match) {\n                return _tagMatch(match, STEP);\n            }\n        } else {\n            // For strict parsing, start with a syntax verifying search\n            match = str.match(STEP_STRICT_REGEX);\n            if (match) {\n                // return exact match to keyword that we need for later replacement\n                return _tagMatch(str.match(STEP_LAX_REGEX), STEP);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Match a timing function value from a CSS Declaration or Value.\n     *\n     * Matches returned from this function must be handled in\n     * BezierCurveEditor._getCubicBezierCoords().\n     *\n     * @param {string} str  Input string.\n     * @param {!boolean} lax  Parsing mode where:\n     *          lax=false Input is a Full or partial line containing CSS Declaration.\n     *                    This is the more strict search used for initial detection.\n     *          lax=true  Input is a previously parsed value. This is the less strict search\n     *                    used to convert previously parsed values to RegExp match format.\n     * @return {!RegExpMatch}\n     */\n    function timingFunctionMatch(str, lax) {\n        return bezierCurveMatch(str, lax) || stepsMatch(str, lax);\n    }\n\n    // Define public API\n    exports.timingFunctionMatch = timingFunctionMatch;\n    exports.bezierCurveMatch    = bezierCurveMatch;\n    exports.stepsMatch          = stepsMatch;\n    exports.showHideHint        = showHideHint;\n});\n\n//# sourceURL=/TimingFunctionUtils.js'),eval("/**\n * @license RequireJS text 2.0.10 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/requirejs/text for details\n */\n/*jslint regexp: true */\n/*global require, XMLHttpRequest, ActiveXObject,\n  define, window, process, Packages,\n  java, location, Components, FileUtils */\n\ndefine('text',['module'], function (module) {\n    'use strict';\n\n    var text, fs, Cc, Ci, xpcIsWindows,\n        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],\n        xmlRegExp = /^\\s*<\\?xml(\\s)+version=[\\'\\\"](\\d)*.(\\d)*[\\'\\\"](\\s)*\\?>/im,\n        bodyRegExp = /<body[^>]*>\\s*([\\s\\S]+)\\s*<\\/body>/im,\n        hasLocation = typeof location !== 'undefined' && location.href,\n        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\\:/, ''),\n        defaultHostName = hasLocation && location.hostname,\n        defaultPort = hasLocation && (location.port || undefined),\n        buildMap = {},\n        masterConfig = (module.config && module.config()) || {};\n\n    text = {\n        version: '2.0.10',\n\n        strip: function (content) {\n            //Strips <?xml ...?> declarations so that external SVG and XML\n            //documents can be added to a document without worry. Also, if the string\n            //is an HTML document, only the part inside the body tag is returned.\n            if (content) {\n                content = content.replace(xmlRegExp, \"\");\n                var matches = content.match(bodyRegExp);\n                if (matches) {\n                    content = matches[1];\n                }\n            } else {\n                content = \"\";\n            }\n            return content;\n        },\n\n        jsEscape: function (content) {\n            return content.replace(/(['\\\\])/g, '\\\\$1')\n                .replace(/[\\f]/g, \"\\\\f\")\n                .replace(/[\\b]/g, \"\\\\b\")\n                .replace(/[\\n]/g, \"\\\\n\")\n                .replace(/[\\t]/g, \"\\\\t\")\n                .replace(/[\\r]/g, \"\\\\r\")\n                .replace(/[\\u2028]/g, \"\\\\u2028\")\n                .replace(/[\\u2029]/g, \"\\\\u2029\");\n        },\n\n        createXhr: masterConfig.createXhr || function () {\n            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.\n            var xhr, i, progId;\n            if (typeof XMLHttpRequest !== \"undefined\") {\n                return new XMLHttpRequest();\n            } else if (typeof ActiveXObject !== \"undefined\") {\n                for (i = 0; i < 3; i += 1) {\n                    progId = progIds[i];\n                    try {\n                        xhr = new ActiveXObject(progId);\n                    } catch (e) {}\n\n                    if (xhr) {\n                        progIds = [progId];  // so faster next time\n                        break;\n                    }\n                }\n            }\n\n            return xhr;\n        },\n\n        /**\n         * Parses a resource name into its component parts. Resource names\n         * look like: module/name.ext!strip, where the !strip part is\n         * optional.\n         * @param {String} name the resource name\n         * @returns {Object} with properties \"moduleName\", \"ext\" and \"strip\"\n         * where strip is a boolean.\n         */\n        parseName: function (name) {\n            var modName, ext, temp,\n                strip = false,\n                index = name.indexOf(\".\"),\n                isRelative = name.indexOf('./') === 0 ||\n                             name.indexOf('../') === 0;\n\n            if (index !== -1 && (!isRelative || index > 1)) {\n                modName = name.substring(0, index);\n                ext = name.substring(index + 1, name.length);\n            } else {\n                modName = name;\n            }\n\n            temp = ext || modName;\n            index = temp.indexOf(\"!\");\n            if (index !== -1) {\n                //Pull off the strip arg.\n                strip = temp.substring(index + 1) === \"strip\";\n                temp = temp.substring(0, index);\n                if (ext) {\n                    ext = temp;\n                } else {\n                    modName = temp;\n                }\n            }\n\n            return {\n                moduleName: modName,\n                ext: ext,\n                strip: strip\n            };\n        },\n\n        xdRegExp: /^((\\w+)\\:)?\\/\\/([^\\/\\\\]+)/,\n\n        /**\n         * Is an URL on another domain. Only works for browser use, returns\n         * false in non-browser environments. Only used to know if an\n         * optimized .js version of a text resource should be loaded\n         * instead.\n         * @param {String} url\n         * @returns Boolean\n         */\n        useXhr: function (url, protocol, hostname, port) {\n            var uProtocol, uHostName, uPort,\n                match = text.xdRegExp.exec(url);\n            if (!match) {\n                return true;\n            }\n            uProtocol = match[2];\n            uHostName = match[3];\n\n            uHostName = uHostName.split(':');\n            uPort = uHostName[1];\n            uHostName = uHostName[0];\n\n            return (!uProtocol || uProtocol === protocol) &&\n                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&\n                   ((!uPort && !uHostName) || uPort === port);\n        },\n\n        finishLoad: function (name, strip, content, onLoad) {\n            content = strip ? text.strip(content) : content;\n            if (masterConfig.isBuild) {\n                buildMap[name] = content;\n            }\n            onLoad(content);\n        },\n\n        load: function (name, req, onLoad, config) {\n            //Name has format: some.module.filext!strip\n            //The strip part is optional.\n            //if strip is present, then that means only get the string contents\n            //inside a body tag in an HTML string. For XML/SVG content it means\n            //removing the <?xml ...?> declarations so the content can be inserted\n            //into the current doc without problems.\n\n            // Do not bother with the work if a build and text will\n            // not be inlined.\n            if (config.isBuild && !config.inlineText) {\n                onLoad();\n                return;\n            }\n\n            masterConfig.isBuild = config.isBuild;\n\n            var parsed = text.parseName(name),\n                nonStripName = parsed.moduleName +\n                    (parsed.ext ? '.' + parsed.ext : ''),\n                url = req.toUrl(nonStripName),\n                useXhr = (masterConfig.useXhr) ||\n                         text.useXhr;\n\n            // Do not load if it is an empty: url\n            if (url.indexOf('empty:') === 0) {\n                onLoad();\n                return;\n            }\n\n            //Load the text. Use XHR if possible and in a browser.\n            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {\n                text.get(url, function (content) {\n                    text.finishLoad(name, parsed.strip, content, onLoad);\n                }, function (err) {\n                    if (onLoad.error) {\n                        onLoad.error(err);\n                    }\n                });\n            } else {\n                //Need to fetch the resource across domains. Assume\n                //the resource has been optimized into a JS module. Fetch\n                //by the module name + extension, but do not include the\n                //!strip part to avoid file system issues.\n                req([nonStripName], function (content) {\n                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,\n                                    parsed.strip, content, onLoad);\n                });\n            }\n        },\n\n        write: function (pluginName, moduleName, write, config) {\n            if (buildMap.hasOwnProperty(moduleName)) {\n                var content = text.jsEscape(buildMap[moduleName]);\n                write.asModule(pluginName + \"!\" + moduleName,\n                               \"define(function () { return '\" +\n                                   content +\n                               \"';});\\n\");\n            }\n        },\n\n        writeFile: function (pluginName, moduleName, req, write, config) {\n            var parsed = text.parseName(moduleName),\n                extPart = parsed.ext ? '.' + parsed.ext : '',\n                nonStripName = parsed.moduleName + extPart,\n                //Use a '.js' file name so that it indicates it is a\n                //script that can be loaded across domains.\n                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';\n\n            //Leverage own load() method to load plugin value, but only\n            //write out values that do not have the strip argument,\n            //to avoid any potential issues with ! in file names.\n            text.load(nonStripName, req, function (value) {\n                //Use own write() method to construct full module value.\n                //But need to create shell that translates writeFile's\n                //write() to the right interface.\n                var textWrite = function (contents) {\n                    return write(fileName, contents);\n                };\n                textWrite.asModule = function (moduleName, contents) {\n                    return write.asModule(moduleName, fileName, contents);\n                };\n\n                text.write(pluginName, nonStripName, textWrite, config);\n            }, config);\n        }\n    };\n\n    if (masterConfig.env === 'node' || (!masterConfig.env &&\n            typeof process !== \"undefined\" &&\n            process.versions &&\n            !!process.versions.node &&\n            !process.versions['node-webkit'])) {\n        //Using special require.nodeRequire, something added by r.js.\n        fs = require.nodeRequire('fs');\n\n        text.get = function (url, callback, errback) {\n            try {\n                var file = fs.readFileSync(url, 'utf8');\n                //Remove BOM (Byte Mark Order) from utf8 files if it is there.\n                if (file.indexOf('\\uFEFF') === 0) {\n                    file = file.substring(1);\n                }\n                callback(file);\n            } catch (e) {\n                errback(e);\n            }\n        };\n    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&\n            text.createXhr())) {\n        text.get = function (url, callback, errback, headers) {\n            var xhr = text.createXhr(), header;\n            xhr.open('GET', url, true);\n\n            //Allow plugins direct access to xhr headers\n            if (headers) {\n                for (header in headers) {\n                    if (headers.hasOwnProperty(header)) {\n                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);\n                    }\n                }\n            }\n\n            //Allow overrides specified in config\n            if (masterConfig.onXhr) {\n                masterConfig.onXhr(xhr, url);\n            }\n\n            xhr.onreadystatechange = function (evt) {\n                var status, err;\n                //Do not explicitly handle errors, those should be\n                //visible via console output in the browser.\n                if (xhr.readyState === 4) {\n                    status = xhr.status;\n                    if (status > 399 && status < 600) {\n                        //An http 4xx or 5xx error. Signal an error.\n                        err = new Error(url + ' HTTP status: ' + status);\n                        err.xhr = xhr;\n                        errback(err);\n                    } else {\n                        callback(xhr.responseText);\n                    }\n\n                    if (masterConfig.onXhrComplete) {\n                        masterConfig.onXhrComplete(xhr, url);\n                    }\n                }\n            };\n            xhr.send(null);\n        };\n    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&\n            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {\n        //Why Java, why is this so awkward?\n        text.get = function (url, callback) {\n            var stringBuffer, line,\n                encoding = \"utf-8\",\n                file = new java.io.File(url),\n                lineSeparator = java.lang.System.getProperty(\"line.separator\"),\n                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),\n                content = '';\n            try {\n                stringBuffer = new java.lang.StringBuffer();\n                line = input.readLine();\n\n                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324\n                // http://www.unicode.org/faq/utf_bom.html\n\n                // Note that when we use utf-8, the BOM should appear as \"EF BB BF\", but it doesn't due to this bug in the JDK:\n                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058\n                if (line && line.length() && line.charAt(0) === 0xfeff) {\n                    // Eat the BOM, since we've already found the encoding on this file,\n                    // and we plan to concatenating this buffer with others; the BOM should\n                    // only appear at the top of a file.\n                    line = line.substring(1);\n                }\n\n                if (line !== null) {\n                    stringBuffer.append(line);\n                }\n\n                while ((line = input.readLine()) !== null) {\n                    stringBuffer.append(lineSeparator);\n                    stringBuffer.append(line);\n                }\n                //Make sure we return a JavaScript string and not a Java string.\n                content = String(stringBuffer.toString()); //String\n            } finally {\n                input.close();\n            }\n            callback(content);\n        };\n    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&\n            typeof Components !== 'undefined' && Components.classes &&\n            Components.interfaces)) {\n        //Avert your gaze!\n        Cc = Components.classes,\n        Ci = Components.interfaces;\n        Components.utils['import']('resource://gre/modules/FileUtils.jsm');\n        xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);\n\n        text.get = function (url, callback) {\n            var inStream, convertStream, fileObj,\n                readData = {};\n\n            if (xpcIsWindows) {\n                url = url.replace(/\\//g, '\\\\');\n            }\n\n            fileObj = new FileUtils.File(url);\n\n            //XPCOM, you so crazy\n            try {\n                inStream = Cc['@mozilla.org/network/file-input-stream;1']\n                           .createInstance(Ci.nsIFileInputStream);\n                inStream.init(fileObj, 1, 0, false);\n\n                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']\n                                .createInstance(Ci.nsIConverterInputStream);\n                convertStream.init(inStream, \"utf-8\", inStream.available(),\n                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);\n\n                convertStream.readString(inStream.available(), readData);\n                convertStream.close();\n                inStream.close();\n                callback(readData.value);\n            } catch (e) {\n                throw new Error((fileObj && fileObj.path || '') + ': ' + e);\n            }\n        };\n    }\n    return text;\n});\n\n//# sourceURL=/var/src/brackets/brackets-src/src/thirdparty/text/text.js"),eval('define(\'text!BezierCurveEditorTemplate.html\',[],function () { return \'<div tabindex="-1" class="bezier-curve-editor">\\n    <div class="cubic-bezier">\\n        <div class="coordinate-plane">\\n            <span   class="control-point P0"></span>\\n            <button class="control-point P1"></button>\\n            <button class="control-point P2"></button>\\n            <span   class="control-point P3"></span>\\n            <canvas height="300" width="150" class="curve"></canvas>\\n        </div>\\n        <div class="info">\\n            <p>{{{BEZIER_EDITOR_INFO}}}</p>\\n            <div class="hint"></div>\\n        </div>\\n    </div>\\n</div>\\n\';});\n\n//# sourceURL=/text!BezierCurveEditorTemplate.html'),eval('/*\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n *  \n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the "Software"), \n * to deal in the Software without restriction, including without limitation \n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \n * and/or sell copies of the Software, and to permit persons to whom the \n * Software is furnished to do so, subject to the following conditions:\n *  \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *  \n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \n * DEALINGS IN THE SOFTWARE.\n * \n */\n\n/*jslint vars: true, plusplus: true, nomen: true, regexp: true, maxerr: 50 */\n/*global define, brackets, $, window, Mustache */\n\ndefine(\'BezierCurveEditor\',[\'require\',\'exports\',\'module\',\'TimingFunctionUtils\',\'text!BezierCurveEditorTemplate.html\'],function (require, exports, module) {\n    "use strict";\n    \n    var KeyEvent        = brackets.getModule("utils/KeyEvent"),\n        Strings         = brackets.getModule("strings");\n\n    var TimingFunctionUtils = require("TimingFunctionUtils");\n    \n    /** Mustache template that forms the bare DOM structure of the UI */\n    var BezierCurveEditorTemplate = require("text!BezierCurveEditorTemplate.html");\n    \n    /** @const @type {number} */\n    var HEIGHT_ABOVE    =  75,    // extra height above main grid\n        HEIGHT_BELOW    =  75,    // extra height below main grid\n        HEIGHT_MAIN     = 150,    // height of main grid\n        WIDTH_MAIN      = 150;    // width of main grid\n\n    var animationRequest = null;\n\n    /**\n     * CubicBezier object constructor\n     *\n     * @param {string|Array.number[4]} coordinates Four parameters passes to cubic-bezier()\n     *      either in string or array format.\n     */\n    function CubicBezier(coordinates) {\n        if (typeof coordinates === "string") {\n            this.coordinates = coordinates.split(",");\n        } else {\n            this.coordinates = coordinates;\n        }\n\n        if (!this.coordinates) {\n            throw "No offsets were defined";\n        }\n\n        this.coordinates = this.coordinates.map(function (n) { return +n; });\n\n        var i;\n        for (i = 3; i >= 0; i--) {\n            var xy = this.coordinates[i];\n            if (isNaN(xy) || (((i % 2) === 0) && (xy < 0 || xy > 1))) {\n                throw "Wrong coordinate at " + i + "(" + xy + ")";\n            }\n        }\n    }\n    \n    /**\n     * BezierCanvas object constructor\n     *\n     * @param {Element} canvas Inline editor <canvas> element\n     * @param {CubicBezier} bezier Associated CubicBezier object\n     * @param {number|Array.number} padding Element padding\n     */\n    function BezierCanvas(canvas, bezier, padding) {\n        this.canvas  = canvas;\n        this.bezier  = bezier;\n        this.padding = this.getPadding(padding);\n\n        // Convert to a cartesian coordinate system with axes from 0 to 1\n        var ctx = this.canvas.getContext("2d"),\n            p = this.padding;\n\n        ctx.scale(canvas.width * (1 - p[1] - p[3]), -canvas.height * 0.5 * (1 - p[0] - p[2]));\n        ctx.translate(p[3] / (1 - p[1] - p[3]), (-1 - p[0] / (1 - p[0] - p[2])) - 0.5);\n    }\n\n    BezierCanvas.prototype = {\n\n        /**\n         * Calculates CSS offsets for <canvas> element\n         *\n         * @return {left:string, top:string}\n         */\n        getOffsets: function () {\n            var p = this.padding,\n                w = this.canvas.width,\n                h = this.canvas.height * 0.5;\n\n            return [{\n                left: w * (this.bezier.coordinates[0]     * (1 - p[3] - p[1]) - p[3]) + "px",\n                top:  h * (1 - this.bezier.coordinates[1] * (1 - p[0] - p[2]) - p[0]) + "px"\n            }, {\n                left: w * (this.bezier.coordinates[2]     * (1 - p[3] - p[1]) - p[3]) + "px",\n                top:  h * (1 - this.bezier.coordinates[3] * (1 - p[0] - p[2]) - p[0]) + "px"\n            }];\n        },\n\n        /**\n         * Round off number to hundreths place, convert to string, and strip leading zero\n         *\n         * @param {number} v Value\n         * @return {string}\n         */\n        prettify: function (v) {\n            return (Math.round(v * 100) / 100).toString().replace(/^0\\./, ".");\n        },\n\n        /**\n         * Get CSS left, top offsets for endpoint handle\n         *\n         * @param {Element} element Endpoint handle <button> element\n         * @return {Array.string[2]}\n         */\n        offsetsToCoordinates: function (element) {\n            var p = this.padding,\n                w = this.canvas.width,\n                h = this.canvas.height * 0.5;\n\n            // Convert padding percentage to actual padding\n            p = p.map(function (a, i) {\n                return a * ((i % 2) ? w : h);\n            });\n\n            return [\n                this.prettify((parseInt($(element).css("left"), 10)    - p[3]) / (w + p[1] + p[3])),\n                this.prettify((h - parseInt($(element).css("top"), 10) - p[2]) / (h - p[0] - p[2]))\n            ];\n        },\n\n        /**\n         * Paint canvas\n         *\n         * @param {Object} settings Paint settings\n         */\n        plot: function (settings) {\n            var xy = this.bezier.coordinates,\n                ctx = this.canvas.getContext("2d"),\n                setting;\n\n            var defaultSettings = {\n                handleTimingFunction: "#2893ef",\n                handleThickness: 0.008,\n                vBorderThickness: 0.02,\n                hBorderThickness: 0.01,\n                bezierTimingFunction: "#2893ef",\n                bezierThickness: 0.03\n            };\n\n            settings = settings || {};\n\n            for (setting in defaultSettings) {\n                if (defaultSettings.hasOwnProperty(setting)) {\n                    if (!settings.hasOwnProperty(setting)) {\n                        settings[setting] = defaultSettings[setting];\n                    }\n                }\n            }\n\n            ctx.clearRect(-0.5, -0.5, 2, 2);\n\n            // Draw control handles\n            ctx.beginPath();\n            ctx.fillStyle = settings.handleTimingFunction;\n            ctx.lineWidth = settings.handleThickness;\n            ctx.strokeStyle = settings.handleTimingFunction;\n\n            ctx.moveTo(0, 0);\n            ctx.lineTo(xy[0], xy[1]);\n            ctx.moveTo(1, 1);\n            ctx.lineTo(xy[2], xy[3]);\n\n            ctx.stroke();\n            ctx.closePath();\n\n            ctx.beginPath();\n            ctx.arc(xy[0], xy[1], 1.5 * settings.handleThickness, 0, 2 * Math.PI, false);\n            ctx.closePath();\n\n            ctx.fill();\n\n            ctx.beginPath();\n            ctx.arc(xy[2], xy[3], 1.5 * settings.handleThickness, 0, 2 * Math.PI, false);\n            ctx.closePath();\n\n            ctx.fill();\n\n            // Draw bezier curve\n            ctx.beginPath();\n            ctx.lineWidth = settings.bezierThickness;\n            ctx.strokeStyle = settings.bezierColor;\n            ctx.moveTo(0, 0);\n            ctx.bezierCurveTo(xy[0], xy[1], xy[2], xy[3], 1, 1);\n            ctx.stroke();\n            ctx.closePath();\n        },\n\n        /**\n         * Convert CSS padding shorthand to longhand\n         *\n         * @param {number|Array.number} padding Element padding\n         * @return {Array.number}\n         */\n        getPadding: function (padding) {\n            var p = (typeof padding === "number") ? [padding] : padding;\n\n            if (p.length === 1) {\n                p[1] = p[0];\n            }\n            if (p.length === 2) {\n                p[2] = p[0];\n            }\n            if (p.length === 3) {\n                p[3] = p[1];\n            }\n\n            return p;\n        }\n    };\n\n    // Event handlers\n    \n    /**\n     * Handle click in <canvas> element\n     *\n     * @param {Event} e Mouse click event\n     */\n    function _curveClick(e) {\n        var self = e.target,\n            bezierEditor = self.bezierEditor;\n\n        var curveBoundingBox = bezierEditor._getCurveBoundingBox(),\n            left = curveBoundingBox.left,\n            top  = curveBoundingBox.top,\n            x    = e.pageX - left,\n            y    = e.pageY - top - HEIGHT_ABOVE,\n            $P1  = $(bezierEditor.P1),\n            $P2  = $(bezierEditor.P2);\n\n        // Helper function to calculate distance between 2-D points\n        function distance(x1, y1, x2, y2) {\n            return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n        }\n\n        // Find which point is closer\n        var distP1 = distance(x, y, parseInt($P1.css("left"), 10), parseInt($P1.css("top"), 10)),\n            distP2 = distance(x, y, parseInt($P2.css("left"), 10), parseInt($P2.css("top"), 10)),\n            $P     = (distP1 < distP2) ? $P1 : $P2;\n\n        $P.css({\n            left: x + "px",\n            top:  y + "px"\n        });\n        $P.get(0).focus();\n\n        // update coords\n        bezierEditor._cubicBezierCoords = bezierEditor.bezierCanvas\n            .offsetsToCoordinates(bezierEditor.P1)\n            .concat(bezierEditor.bezierCanvas.offsetsToCoordinates(bezierEditor.P2));\n\n        bezierEditor._commitTimingFunction();\n        bezierEditor._updateCanvas();\n    }\n\n    /**\n     * Helper function for handling point move\n     *\n     * @param {Event} e Mouse move event\n     * @param {number} x New horizontal position\n     * @param {number} y New vertical position\n     */\n    function handlePointMove(e, x, y) {\n        var self = e.target,\n            bezierEditor = self.bezierEditor;\n\n        // Helper function to redraw curve\n        function mouseMoveRedraw() {\n            if (!bezierEditor.dragElement) {\n                animationRequest = null;\n                return;\n            }\n\n            // Update code\n            bezierEditor._commitTimingFunction();\n\n            bezierEditor._updateCanvas();\n            animationRequest = window.requestAnimationFrame(mouseMoveRedraw);\n        }\n\n        // This is a dragging state, but left button is no longer down, so mouse\n        // exited element, was released, and re-entered element. Treat like a drop.\n        if (bezierEditor.dragElement && (e.which !== 1)) {\n            bezierEditor.dragElement = null;\n            bezierEditor._commitTimingFunction();\n            bezierEditor._updateCanvas();\n            bezierEditor = null;\n            return;\n        }\n\n        // Constrain time (x-axis) to 0 to 1 range. Progression (y-axis) is\n        // theoretically not constrained, although canvas to drawing curve is\n        // arbitrarily constrained to -0.5 to 1.5 range.\n        x = Math.min(Math.max(0, x), WIDTH_MAIN);\n\n        if (bezierEditor.dragElement) {\n            $(bezierEditor.dragElement).css({\n                left: x + "px",\n                top:  y + "px"\n            });\n        }\n\n        // update coords\n        bezierEditor._cubicBezierCoords = bezierEditor.bezierCanvas\n            .offsetsToCoordinates(bezierEditor.P1)\n            .concat(bezierEditor.bezierCanvas.offsetsToCoordinates(bezierEditor.P2));\n\n        if (!animationRequest) {\n            animationRequest = window.requestAnimationFrame(mouseMoveRedraw);\n        }\n    }\n\n    /**\n     * Update Time (x-axis) and Progression (y-axis) data for mouse position\n     *\n     * @param {Element} canvas <canvas> element\n     * @param {number} x Horizontal position\n     * @param {number} y Vertical position\n     */\n    function updateTimeProgression(curve, x, y) {\n        var percentX = Math.round(100 * x / WIDTH_MAIN),\n            percentY = Math.round(100 * ((HEIGHT_MAIN - y) / HEIGHT_MAIN));\n\n        // Constrain horizontal percentage to [0, 100] range\n        percentX = Math.min(Math.max(0, percentX), 100);\n\n        curve.parentNode.setAttribute("data-time", percentX);\n        curve.parentNode.setAttribute("data-progression", percentY);\n    }\n\n    /**\n     * Handle mouse move in <canvas> element\n     *\n     * @param {Event} e Mouse move event\n     */\n    function _curveMouseMove(e) {\n        var self = e.target,\n            bezierEditor = self.bezierEditor,\n            curveBoundingBox = bezierEditor._getCurveBoundingBox(),\n            left   = curveBoundingBox.left,\n            top    = curveBoundingBox.top,\n            x = e.pageX - left,\n            y = e.pageY - top - HEIGHT_ABOVE;\n\n        updateTimeProgression(self, x, y);\n\n        if (bezierEditor.dragElement) {\n            if (e.pageX === 0 && e.pageY === 0) {\n                return;\n            }\n\n            handlePointMove(e, x, y);\n        }\n    }\n\n    /**\n     * Handle mouse move in <button> element\n     *\n     * @param {Event} e Mouse move event\n     */\n    function _pointMouseMove(e) {\n        var self = e.target,\n            bezierEditor = self.bezierEditor,\n            curveBoundingBox = bezierEditor._getCurveBoundingBox(),\n            left = curveBoundingBox.left,\n            top  = curveBoundingBox.top,\n            x = e.pageX - left,\n            y = e.pageY - top - HEIGHT_ABOVE;\n\n        updateTimeProgression(bezierEditor.curve, x, y);\n\n        if (e.pageX === 0 && e.pageY === 0) {\n            return;\n        }\n\n        handlePointMove(e, x, y);\n    }\n\n    /**\n     * Handle mouse down in <button> element\n     *\n     * @param {Event} e Mouse down event\n     */\n    function _pointMouseDown(e) {\n        var self = e.target;\n\n        self.bezierEditor.dragElement = self;\n    }\n\n    /**\n     * Handle mouse up in <button> element\n     *\n     * @param {Event} e Mouse up event\n     */\n    function _pointMouseUp(e) {\n        var self = e.target;\n\n        self.focus();\n\n        if (self.bezierEditor.dragElement) {\n            self.bezierEditor.dragElement = null;\n            self.bezierEditor._commitTimingFunction();\n            self.bezierEditor._updateCanvas();\n        }\n    }\n\n    /**\n     * Handle key down in <button> element\n     *\n     * @param {Event} e Key down event\n     */\n    function _pointKeyDown(e) {\n        var code = e.keyCode,\n            self = e.target,\n            bezierEditor = self.bezierEditor;\n\n        if (code >= KeyEvent.DOM_VK_LEFT && code <= KeyEvent.DOM_VK_DOWN) {\n            e.preventDefault();\n\n            // Arrow keys pressed\n            var $this = $(e.target),\n                left = parseInt($this.css("left"), 10),\n                top  = parseInt($this.css("top"), 10),\n                offset = (e.shiftKey ? 15 : 3),\n                newVal;\n\n            switch (code) {\n            case KeyEvent.DOM_VK_LEFT:\n                newVal = Math.max(0, left - offset);\n                if (left === newVal) {\n                    return false;\n                }\n                $this.css({ left: newVal + "px" });\n                break;\n            case KeyEvent.DOM_VK_UP:\n                newVal = Math.max(-HEIGHT_ABOVE, top - offset);\n                if (top === newVal) {\n                    return false;\n                }\n                $this.css({ top: newVal + "px" });\n                break;\n            case KeyEvent.DOM_VK_RIGHT:\n                newVal = Math.min(WIDTH_MAIN, left + offset);\n                if (left === newVal) {\n                    return false;\n                }\n                $this.css({ left: newVal + "px" });\n                break;\n            case KeyEvent.DOM_VK_DOWN:\n                newVal = Math.min(HEIGHT_MAIN + HEIGHT_BELOW, top + offset);\n                if (top === newVal) {\n                    return false;\n                }\n                $this.css({ top: newVal + "px" });\n                break;\n            }\n\n            // update coords\n            bezierEditor._cubicBezierCoords = bezierEditor.bezierCanvas\n                .offsetsToCoordinates(bezierEditor.P1)\n                .concat(bezierEditor.bezierCanvas.offsetsToCoordinates(bezierEditor.P2));\n\n            bezierEditor._commitTimingFunction();\n            bezierEditor._updateCanvas();\n            return true;\n\n        } else if (code === KeyEvent.DOM_VK_ESCAPE) {\n            return true;\n        } else if (code === KeyEvent.DOM_VK_TAB && !e.ctrlKey && !e.metaKey && !e.altKey) {\n            // Switch between the two points by tabbing\n            if ($(e.target).hasClass("P1")) {\n                $(".P2").focus();\n            } else {\n                $(".P1").focus();\n            }\n            e.preventDefault();\n            return true;\n        }\n\n        return false;\n    }\n\n\n    /**\n     * Constructor for BezierCurveEditor Object. This control may be used standalone\n     * or within an InlineTimingFunctionEditor inline widget.\n     *\n     * @param {!jQuery} $parent  DOM node into which to append the root of the bezier curve editor UI\n     * @param {!RegExpMatch} bezierCurve  RegExp match object of initially selected bezierCurve\n     * @param {!function(string)} callback  Called whenever selected bezierCurve changes\n     */\n    function BezierCurveEditor($parent, bezierCurve, callback) {\n        // Create the DOM structure, filling in localized strings via Mustache\n        this.$element = $(Mustache.render(BezierCurveEditorTemplate, Strings));\n        $parent.append(this.$element);\n        \n        this._callback = callback;\n        this.dragElement = null;\n\n        // current cubic-bezier() function params\n        this._cubicBezierCoords = this._getCubicBezierCoords(bezierCurve);\n\n        this.hint = {};\n        this.hint.elem = $(".hint", this.$element);\n        // If function was auto-corrected, then originalString holds the original function,\n        // and an informational message needs to be shown\n        if (bezierCurve.originalString) {\n            TimingFunctionUtils.showHideHint(this.hint, true, bezierCurve.originalString, "cubic-bezier(" + this._cubicBezierCoords.join(", ") + ")");\n        } else {\n            TimingFunctionUtils.showHideHint(this.hint, false);\n        }\n\n        this.P1 = this.$element.find(".P1")[0];\n        this.P2 = this.$element.find(".P2")[0];\n        this.curve = this.$element.find(".curve")[0];\n\n        this.P1.bezierEditor = this.P2.bezierEditor = this.curve.bezierEditor = this;\n\n        this.bezierCanvas = new BezierCanvas(this.curve, null, [0, 0]);\n        \n        // redraw canvas\n        this._updateCanvas();\n\n        $(this.curve)\n            .on("click", _curveClick)\n            .on("mousemove", _curveMouseMove);\n        $(this.P1)\n            .on("mousemove", _pointMouseMove)\n            .on("mousedown", _pointMouseDown)\n            .on("mouseup", _pointMouseUp)\n            .on("keydown", _pointKeyDown);\n        $(this.P2)\n            .on("mousemove", _pointMouseMove)\n            .on("mousedown", _pointMouseDown)\n            .on("mouseup", _pointMouseUp)\n            .on("keydown", _pointKeyDown);\n    }\n\n    /**\n     * Destructor called by InlineTimingFunctionEditor.onClosed()\n     */\n    BezierCurveEditor.prototype.destroy = function () {\n\n        this.P1.bezierEditor = this.P2.bezierEditor = this.curve.bezierEditor = null;\n\n        $(this.curve)\n            .off("click", _curveClick)\n            .off("mousemove", _curveMouseMove);\n        $(this.P1)\n            .off("mousemove", _pointMouseMove)\n            .off("mousedown", _pointMouseDown)\n            .off("mouseup", _pointMouseUp)\n            .off("keydown", _pointKeyDown);\n        $(this.P2)\n            .off("mousemove", _pointMouseMove)\n            .off("mousedown", _pointMouseDown)\n            .off("mouseup", _pointMouseUp)\n            .off("keydown", _pointKeyDown);\n    };\n\n\n    /** Returns the root DOM node of the BezierCurveEditor UI */\n    BezierCurveEditor.prototype.getRootElement = function () {\n        return this.$element;\n    };\n\n    /**\n     * Default focus needs to go somewhere, so give it to P1\n     */\n    BezierCurveEditor.prototype.focus = function () {\n        this.P1.focus();\n        return true;\n    };\n\n    /**\n     * Generates cubic-bezier function based on coords, and updates the doc\n     */\n    BezierCurveEditor.prototype._commitTimingFunction = function () {\n        var bezierCurveVal = "cubic-bezier(" +\n            this._cubicBezierCoords[0] + ", " +\n            this._cubicBezierCoords[1] + ", " +\n            this._cubicBezierCoords[2] + ", " +\n            this._cubicBezierCoords[3] + ")";\n        this._callback(bezierCurveVal);\n        TimingFunctionUtils.showHideHint(this.hint, false);\n    };\n\n    /**\n     * Handle all matches returned from TimingFunctionUtils.cubicBezierMatch() and\n     * return array of coords\n     *\n     * @param {RegExp.match} match Matches returned from cubicBezierMatch()\n     * @return {Array.number[4]}\n     */\n    BezierCurveEditor.prototype._getCubicBezierCoords = function (match) {\n\n        if (match[0].match(/^cubic-bezier/)) {\n            // cubic-bezier()\n            return match.slice(1, 5);\n        } else {\n            // handle special cases of cubic-bezier calls\n            switch (match[0]) {\n            case "linear":\n                return [ "0", "0", "1", "1" ];\n            case "ease":\n                return [ ".25", ".1", ".25", "1" ];\n            case "ease-in":\n                return [ ".42", "0", "1", "1" ];\n            case "ease-out":\n                return [ "0", "0", ".58", "1" ];\n            case "ease-in-out":\n                return [ ".42", "0", ".58", "1" ];\n            }\n        }\n\n        window.console.log("brackets-cubic-bezier: getCubicBezierCoords() passed invalid RegExp match array");\n        return [ "0", "0", "0", "0" ];\n    };\n\n    /**\n     * Get <canvas> element\'s bounding box\n     *\n     * @return {left: number, top: number, width: number, height: number}\n     */\n    BezierCurveEditor.prototype._getCurveBoundingBox = function () {\n        var $canvas = this.$element.find(".curve"),\n            canvasOffset = $canvas.offset();\n\n        return {\n            left:    canvasOffset.left,\n            top:     canvasOffset.top,\n            width:   $canvas.width(),\n            height:  $canvas.height()\n        };\n    };\n\n    /**\n     * Update <canvas> after a change\n     */\n    BezierCurveEditor.prototype._updateCanvas = function () {\n        // collect data, build model\n        if (this._cubicBezierCoords) {\n            this.bezierCanvas.bezier = window.bezier = new CubicBezier(this._cubicBezierCoords);\n\n            var offsets = this.bezierCanvas.getOffsets();\n\n            $(this.P1).css({\n                left: offsets[0].left,\n                top:  offsets[0].top\n            });\n            $(this.P2).css({\n                left: offsets[1].left,\n                top:  offsets[1].top\n            });\n\n            this.bezierCanvas.plot();\n        }\n    };\n    \n    /**\n     * Handle external update\n     *\n     * @param {!RegExpMatch} bezierCurve  RegExp match object of updated bezierCurve\n     */\n    BezierCurveEditor.prototype.handleExternalUpdate = function (bezierCurve) {\n        this._cubicBezierCoords = this._getCubicBezierCoords(bezierCurve);\n        this._updateCanvas();\n        // If function was auto-corrected, then originalString holds the original function,\n        // and an informational message needs to be shown\n        if (bezierCurve.originalString) {\n            TimingFunctionUtils.showHideHint(this.hint, true, bezierCurve.originalString, "cubic-bezier(" + this._cubicBezierCoords.join(", ") + ")");\n        } else {\n            TimingFunctionUtils.showHideHint(this.hint, false);\n        }\n    };\n\n    \n    exports.BezierCurveEditor = BezierCurveEditor;\n});\n\n//# sourceURL=/BezierCurveEditor.js'),eval('define(\'text!StepEditorTemplate.html\',[],function () { return \'<div tabindex="-1" class="step-editor">\\n    <div class="steps-func">\\n        <div class="coordinate-plane">\\n            <canvas height="180" width="180" class="steps" tabindex="1"></canvas>\\n        </div>\\n        <div class="info">\\n            <p>{{{STEPS_EDITOR_INFO}}}</p>\\n            <div class="hint"></div>\\n        </div>\\n    </div>\\n</div>\\n\';});\n\n//# sourceURL=/text!StepEditorTemplate.html'),eval('/*\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n *  \n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the "Software"), \n * to deal in the Software without restriction, including without limitation \n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \n * and/or sell copies of the Software, and to permit persons to whom the \n * Software is furnished to do so, subject to the following conditions:\n *  \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *  \n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \n * DEALINGS IN THE SOFTWARE.\n * \n */\n\n/*jslint vars: true, plusplus: true, nomen: true, regexp: true, maxerr: 50 */\n/*global define, brackets, $, window, Mustache */\n\ndefine(\'StepEditor\',[\'require\',\'exports\',\'module\',\'TimingFunctionUtils\',\'text!StepEditorTemplate.html\'],function (require, exports, module) {\n    "use strict";\n    \n    var KeyEvent    = brackets.getModule("utils/KeyEvent"),\n        Strings     = brackets.getModule("strings");\n\n    var TimingFunctionUtils = require("TimingFunctionUtils");\n    \n    /** Mustache template that forms the bare DOM structure of the UI */\n    var StepEditorTemplate   = require("text!StepEditorTemplate.html");\n    \n    /** @const @type {number} */\n    var STEP_LINE   = 1,\n        DASH_LINE   = 2;\n\n    /**\n     * StepParameters object constructor\n     *\n     * @param {{ count: number, timing: string}} params Parameters passed to steps()\n     *      either in string or array format.\n     */\n    function StepParameters(params) {\n        if (!params) {\n            throw "No parameters were defined";\n        }\n\n        this.count  = params.count;\n        this.timing = params.timing;\n    }\n    \n    /**\n     * StepCanvas object constructor\n     *\n     * @param {Element} canvas Inline editor <canvas> element\n     * @param {StepParameters} stepParams Associated StepParameters object\n     * @param {number|Array.number} padding Element padding\n     */\n    function StepCanvas(canvas, stepParams, padding) {\n        this.canvas     = canvas;\n        this.stepParams = stepParams;\n        this.padding    = this.getPadding(padding);\n\n        // Convert to a cartesian coordinate system with axes from 0 to 1\n        var ctx = this.canvas.getContext("2d"),\n            p = this.padding;\n\n        ctx.scale(canvas.width * (1 - p[1] - p[3]), -canvas.height * (1 - p[0] - p[2]));\n        ctx.translate(p[3] / (1 - p[1] - p[3]), (-1 - p[0] / (1 - p[0] - p[2])));\n    }\n\n    StepCanvas.prototype = {\n\n        drawBackground: function () {\n            this.ctx.beginPath();\n            this.ctx.lineWidth   = this.settings.borderWidth;\n            this.ctx.strokeStyle = this.settings.borderColor;\n            this.ctx.fillStyle = this.settings.bgColor;\n            this.ctx.moveTo(0, 0);\n            this.ctx.lineTo(0, 1);\n            this.ctx.lineTo(1, 1);\n            this.ctx.lineTo(1, 0);\n            this.ctx.lineTo(0, 0);\n            this.ctx.stroke();\n            this.ctx.fill();\n            this.ctx.closePath();\n        },\n\n        drawPoint: function (x, y, isFilled) {\n            // Points are always step color\n            this.ctx.beginPath();\n            this.ctx.lineWidth   = this.settings.pointLineWidth;\n            this.ctx.strokeStyle = this.settings.stepColor;\n            this.ctx.arc(x, y, this.settings.pointRadius, 0, 2 * Math.PI, false);\n            this.ctx.stroke();\n            if (isFilled) {\n                this.ctx.fillStyle = this.settings.stepColor;\n                this.ctx.fill();\n            }\n            this.ctx.closePath();\n        },\n\n        drawLine: function (x1, y1, x2, y2, type) {\n            this.ctx.beginPath();\n            if (type === STEP_LINE) {\n                this.ctx.lineWidth   = this.settings.stepLineWidth;\n                this.ctx.strokeStyle = this.settings.stepColor;\n            } else if (type === DASH_LINE) {\n                this.ctx.lineWidth   = this.settings.dashLineWidth;\n                this.ctx.strokeStyle = this.settings.dashColor;\n            }\n            this.ctx.moveTo(x1, y1);\n            this.ctx.lineTo(x2, y2);\n            this.ctx.stroke();\n            this.ctx.closePath();\n        },\n\n        drawStartInterval: function (x1, y1, x2, y2) {\n            var pr = this.settings.pointRadius;\n\n            // Draw empty start point\n            this.drawPoint(x1, y1, false);\n\n            // Draw dashed line up to next step\n            this.drawLine(x1, y1 + pr, x1, y2, DASH_LINE);\n\n            // Draw filled mid point\n            this.drawPoint(x1, y2, true);\n\n            // Draw step line\n            this.drawLine(x1, y2, x2 - pr, y2, STEP_LINE);\n        },\n\n        drawEndInterval: function (x1, y1, x2, y2) {\n            var pr = this.settings.pointRadius;\n\n            // Draw filled start point\n            this.drawPoint(x1, y1, true);\n\n            // Draw step line\n            this.drawLine(x1, y1, x2 - pr, y1, STEP_LINE);\n\n            // Draw empty mid point\n            this.drawPoint(x2, y1, false);\n\n            // Draw dashed line up to next step\n            this.drawLine(x2, y1 + pr, x2, y2, DASH_LINE);\n        },\n\n        /**\n         * Paint canvas\n         *\n         * @param {Object} settings Paint settings\n         */\n        plot: function (settings) {\n            var setting, i, j, last, interval,\n                sp = this.stepParams,\n                isStart = (sp.timing === "start"),\n                p = [];\n\n            var defaultSettings = {\n                bgColor:        "transparent",\n                borderColor:    "#bbb",\n                stepColor:      "#2893ef",\n                dashColor:      "#b8b8b8",\n                borderWidth:    0.00667,\n                stepLineWidth:  0.02,\n                dashLineWidth:  0.008,\n                pointLineWidth: 0.008,\n                pointRadius:    0.015\n            };\n\n            this.settings = settings || {};\n\n            for (setting in defaultSettings) {\n                if (defaultSettings.hasOwnProperty(setting)) {\n                    if (!this.settings.hasOwnProperty(setting)) {\n                        this.settings[setting] = defaultSettings[setting];\n                    }\n                }\n            }\n\n            this.ctx = this.canvas.getContext("2d");\n\n            // Build points array. There\'s a starting point at 0,0\n            // plus a point for each step\n            p[0] = { x: 0, y: 0 };\n            for (i = 1; i <= sp.count; i++) {\n                interval = i / sp.count;\n                p[i] = { x: interval, y: interval };\n            }\n\n            // Start with a clean slate\n            this.ctx.clearRect(-0.5, -0.5, 2, 2);\n            this.drawBackground();\n\n            // Draw each interval\n            last = p.length - 1;\n            for (i = 0, j = 1; i < last; i++, j++) {\n                if (isStart) {\n                    this.drawStartInterval(p[i].x, p[i].y, p[j].x, p[j].y);\n                } else {\n                    this.drawEndInterval(p[i].x, p[i].y, p[j].x, p[j].y);\n                }\n            }\n\n            // Each interval draws start and mid point for that interval,\n            // so we need to draw last point. It\'s always filled.\n            this.drawPoint(p[last].x, p[last].y, true);\n        },\n\n        /**\n         * Convert CSS padding shorthand to longhand\n         *\n         * @param {number|Array.number} padding Element padding\n         * @return {Array.number}\n         */\n        getPadding: function (padding) {\n            var p = (typeof padding === "number") ? [padding] : padding;\n\n            if (p.length === 1) {\n                p[1] = p[0];\n            }\n            if (p.length === 2) {\n                p[2] = p[0];\n            }\n            if (p.length === 3) {\n                p[3] = p[1];\n            }\n\n            return p;\n        }\n    };\n\n    // Event handlers\n    \n    /**\n     * Handle key down in <canvas> element\n     *\n     * @param {Event} e Key down event\n     */\n    function _canvasKeyDown(e) {\n        var code = e.keyCode,\n            self = e.target,\n            stepEditor = self.stepEditor;\n\n        if (code >= KeyEvent.DOM_VK_LEFT && code <= KeyEvent.DOM_VK_DOWN) {\n            e.preventDefault();\n\n            // Arrow keys pressed\n            switch (code) {\n            case KeyEvent.DOM_VK_LEFT:\n                stepEditor.stepCanvas.stepParams.timing = "start";\n                break;\n            case KeyEvent.DOM_VK_UP:\n                // No upper limit\n                stepEditor.stepCanvas.stepParams.count++;\n                break;\n            case KeyEvent.DOM_VK_RIGHT:\n                stepEditor.stepCanvas.stepParams.timing = "end";\n                break;\n            case KeyEvent.DOM_VK_DOWN:\n                if (stepEditor.stepCanvas.stepParams.count > 1) {\n                    stepEditor.stepCanvas.stepParams.count--;\n                }\n                break;\n            }\n\n            // update step params\n            stepEditor._stepParams = stepEditor.stepCanvas.stepParams;\n\n            stepEditor._commitTimingFunction();\n            stepEditor._updateCanvas();\n            return true;\n\n        } else if (code === KeyEvent.DOM_VK_ESCAPE) {\n            return true;\n        }\n\n        return false;\n    }\n\n\n    /**\n     * Constructor for StepEditor Object. This control may be used standalone\n     * or within an InlineTimingFunctionEditor inline widget.\n     *\n     * @param {!jQuery} $parent  DOM node into which to append the root of the step editor UI\n     * @param {!RegExpMatch} stepMatch  RegExp match object of initially selected step function\n     * @param {!function(string)} callback  Called whenever selected step function changes\n     */\n    function StepEditor($parent, stepMatch, callback) {\n        // Create the DOM structure, filling in localized strings via Mustache\n        this.$element = $(Mustache.render(StepEditorTemplate, Strings));\n        $parent.append(this.$element);\n        \n        this._callback = callback;\n\n        // current step function params\n        this._stepParams = this._getStepParams(stepMatch);\n\n        this.hint = {};\n        this.hint.elem = $(".hint", this.$element);\n        // If function was auto-corrected, then originalString holds the original function,\n        // and an informational message needs to be shown\n        if (stepMatch.originalString) {\n            TimingFunctionUtils.showHideHint(this.hint, true, stepMatch.originalString, "steps(" + this._stepParams.count.toString() + ", " + this._stepParams.timing + ")");\n        } else {\n            TimingFunctionUtils.showHideHint(this.hint, false);\n        }\n\n        this.canvas = this.$element.find(".steps")[0];\n\n        this.canvas.stepEditor = this;\n\n        // Padding (3rd param)is scaled, so 0.1 translates to 15px\n        // Note that this is rendered inside canvas CSS "content"\n        // (i.e. this does not map to CSS padding)\n        this.stepCanvas = new StepCanvas(this.canvas, null, [0.1]);\n      \n        // redraw canvas\n        this._updateCanvas();\n\n        $(this.canvas).on("keydown", _canvasKeyDown);\n    }\n\n    /**\n     * Destructor called by InlineTimingFunctionEditor.onClosed()\n     */\n    StepEditor.prototype.destroy = function () {\n        this.canvas.stepEditor = null;\n        $(this.canvas).off("keydown", _canvasKeyDown);\n    };\n\n\n    /** Returns the root DOM node of the StepEditor UI */\n    StepEditor.prototype.getRootElement = function () {\n        return this.$element;\n    };\n\n    /**\n     * Default focus needs to go somewhere, so give it to canvas\n     */\n    StepEditor.prototype.focus = function () {\n        this.canvas.focus();\n        return true;\n    };\n\n    /**\n     * Generates step function based on parameters, and updates the doc\n     */\n    StepEditor.prototype._commitTimingFunction = function () {\n        var stepFuncVal = "steps(" +\n            this._stepParams.count.toString() + ", " +\n            this._stepParams.timing + ")";\n        this._callback(stepFuncVal);\n        TimingFunctionUtils.showHideHint(this.hint, false);\n    };\n\n    /**\n     * Handle all matches returned from TimingFunctionUtils.stepMatch() and\n     * return array of coords\n     *\n     * @param {RegExp.match} match Matches returned from stepMatch()\n     * @return {{count: number, timing: string}}\n     */\n    StepEditor.prototype._getStepParams = function (match) {\n\n        if (match[0].match(/^steps/)) {\n            // steps()\n            return {\n                count:  parseInt(match[1], 10),\n                timing: match[2] || "end"\n            };\n        } else {\n            // handle special cases of steps functions\n            switch (match[0]) {\n            case "step-start":\n                return { count: 1, timing: "start" };\n            case "step-end":\n                return { count: 1, timing: "end" };\n            }\n        }\n\n        window.console.log("step timing function: _getStepParams() passed invalid RegExp match array");\n        return { count: 1, timing: "end" };\n    };\n\n    /**\n     * Get <canvas> element\'s bounding box\n     *\n     * @return {left: number, top: number, width: number, height: number}\n     */\n    StepEditor.prototype._getCanvasBoundingBox = function () {\n        var $canvas = this.$element.find(".steps"),\n            canvasOffset = $canvas.offset();\n\n        return {\n            left:    canvasOffset.left,\n            top:     canvasOffset.top,\n            width:   $canvas.width(),\n            height:  $canvas.height()\n        };\n    };\n\n    /**\n     * Update <canvas> after a change\n     */\n    StepEditor.prototype._updateCanvas = function () {\n        // collect data, build model\n        if (this._stepParams) {\n            this.stepCanvas.stepParams = window.stepParams = new StepParameters(this._stepParams);\n\n            this.stepCanvas.plot();\n        }\n    };\n    \n    /**\n     * Handle external update\n     *\n     * @param {!RegExpMatch} stepMatch  RegExp match object of updated step function\n     */\n    StepEditor.prototype.handleExternalUpdate = function (stepMatch) {\n        this._stepParams = this._getStepParams(stepMatch);\n        this._updateCanvas();\n        // If function was auto-corrected, then originalString holds the original function,\n        // and an informational message needs to be shown\n        if (stepMatch.originalString) {\n            TimingFunctionUtils.showHideHint(this.hint, true, stepMatch.originalString, "steps(" + this._stepParams.count.toString() + ", " + this._stepParams.timing + ")");\n        } else {\n            TimingFunctionUtils.showHideHint(this.hint, false);\n        }\n    };\n\n    \n    exports.StepEditor = StepEditor;\n});\n\n//# sourceURL=/StepEditor.js'),eval("/*\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n *  \n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"), \n * to deal in the Software without restriction, including without limitation \n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \n * and/or sell copies of the Software, and to permit persons to whom the \n * Software is furnished to do so, subject to the following conditions:\n *  \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *  \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \n * DEALINGS IN THE SOFTWARE.\n * \n */\n\n/*jslint vars: true, plusplus: true, nomen: true, regexp: true, maxerr: 50 */\n/*global define, brackets, window */\n\ndefine('InlineTimingFunctionEditor',['require','exports','module','BezierCurveEditor','StepEditor','TimingFunctionUtils'],function (require, exports, module) {\n    \"use strict\";\n    \n    var InlineWidget         = brackets.getModule(\"editor/InlineWidget\").InlineWidget,\n        BezierCurveEditor    = require(\"BezierCurveEditor\").BezierCurveEditor,\n        StepEditor           = require(\"StepEditor\").StepEditor,\n        TimingFunctionUtils  = require(\"TimingFunctionUtils\");\n        \n\n    /** @type {number} Global var used to provide a unique ID for each timingFunction editor instance's _origin field. */\n    var lastOriginId = 1;\n    \n    /**\n     * Constructor for inline widget containing a BezierCurveEditor control\n     *\n     * @param {!RegExpMatch} timingFunction  RegExp match object of initially selected timingFunction\n     * @param {!CodeMirror.Bookmark} startBookmark\n     * @param {!CodeMirror.Bookmark} endBookmark\n     */\n    function InlineTimingFunctionEditor(timingFunction, startBookmark, endBookmark) {\n        this._timingFunction = timingFunction;\n        this._startBookmark = startBookmark;\n        this._endBookmark = endBookmark;\n        this._isOwnChange = false;\n        this._isHostChange = false;\n        this._origin = \"+InlineTimingFunctionEditor_\" + (lastOriginId++);\n\n        this._handleTimingFunctionChange = this._handleTimingFunctionChange.bind(this);\n        this._handleHostDocumentChange = this._handleHostDocumentChange.bind(this);\n        \n        InlineWidget.call(this);\n    }\n    \n    InlineTimingFunctionEditor.prototype = Object.create(InlineWidget.prototype);\n    InlineTimingFunctionEditor.prototype.constructor = InlineTimingFunctionEditor;\n    InlineTimingFunctionEditor.prototype.parentClass = InlineWidget.prototype;\n    \n    /** @type {!BezierCurveEditor} BezierCurveEditor instance */\n    InlineTimingFunctionEditor.prototype.timingFunctionEditor = null;\n    \n    /** @type {!string} Current value of the timing function editor control */\n    InlineTimingFunctionEditor.prototype._timingFunction = null;\n    \n    /**\n     * Start of the range of code we're attached to; _startBookmark.find() may by null if sync is lost.\n     * @type {!CodeMirror.Bookmark}\n     */\n    InlineTimingFunctionEditor.prototype._startBookmark = null;\n    \n    /**\n     * End of the range of code we're attached to; _endBookmark.find() may by null if sync is lost or even\n     * in some cases when it's not. Call getCurrentRange() for the definitive text range we're attached to.\n     * @type {!CodeMirror.Bookmark}\n     */\n    InlineTimingFunctionEditor.prototype._endBookmark = null;\n    \n    /** @type {boolean} True while we're syncing a timing function editor change into the code editor */\n    InlineTimingFunctionEditor.prototype._isOwnChange = null;\n    \n    /** @type {boolean} True while we're syncing a code editor change into the timing function editor */\n    InlineTimingFunctionEditor.prototype._isHostChange = null;\n    \n    /** @type {number} ID used to identify edits coming from this inline widget for undo batching */\n    InlineTimingFunctionEditor.prototype._origin = null;\n    \n    \n    /**\n     * Returns the current text range of the timingFunction we're attached to, or null if\n     * we've lost sync with what's in the code.\n     *\n     * @return {?{\n     *              start: {line:number, ch:number},\n     *              end:   {line:number, ch:number},\n     *              match: {RegExpMatch}\n     *          }}\n     */\n    InlineTimingFunctionEditor.prototype.getCurrentRange = function () {\n        var start, end;\n        \n        start = this._startBookmark.find();\n        if (!start) {\n            return null;\n        }\n        \n        end = this._endBookmark.find();\n        if (!end) {\n            end = { line: start.line };\n        }\n        \n        // Even if we think we have a good end bookmark, we want to run the\n        // regexp match to see if there's a valid match that extends past the bookmark.\n        // This can happen if the user deletes the end of the existing timingFunction and then\n        // types some more.\n        // FUTURE: when we migrate to CodeMirror v3, we might be able to use markText()\n        // instead of two bookmarks to track the range. (In our current old version of\n        // CodeMirror v2, markText() isn't robust enough for this case.)\n        var line = this.hostEditor.document.getLine(start.line),\n            matches = TimingFunctionUtils.timingFunctionMatch(line.substr(start.ch), true),\n            originalLength;\n\n        // No longer have a match\n        if (!matches) {\n            return null;\n        }\n        \n        originalLength = ((matches.originalString && matches.originalString.length) || matches[0].length);\n        // Note that end.ch is exclusive, so we don't need to add 1 before comparing to\n        // the matched length here.\n        if (end.ch === undefined || (end.ch - start.ch) !== originalLength) {\n            end.ch = start.ch + originalLength;\n            this._endBookmark.clear();\n            this._endBookmark = this.hostEditor._codeMirror.setBookmark(end);\n        }\n        \n        if (end.ch === undefined) {\n            // We were unable to resync the end bookmark.\n            return null;\n        } else {\n            return {\n                start: start,\n                end:   end,\n                match: matches,\n                originalLength: originalLength\n            };\n        }\n    };\n        \n    /**\n     * When the timing function editor's selected timingFunction changes, update text in code editor\n     * @param {!string} timingFunctionString\n     */\n    InlineTimingFunctionEditor.prototype._handleTimingFunctionChange = function (timingFunctionString) {\n        var self                = this,\n            timingFunctionMatch = TimingFunctionUtils.timingFunctionMatch(timingFunctionString, true);\n        if (timingFunctionMatch !== this._timingFunction) {\n            var range = this.getCurrentRange();\n            if (!range) {\n                return;\n            }\n\n            // Don't push the change back into the host editor if it came from the host editor.\n            if (!this._isHostChange) {\n                this._isOwnChange = true;\n                this.hostEditor.document.batchOperation(function () {\n                    // Replace old timingFunction in code with the editor's timing function, and select it\n                    self.hostEditor.document.replaceRange(timingFunctionString, range.start, range.end, self._origin);\n                    var newEnd = { line: range.start.line, ch: range.start.ch + timingFunctionString.length };\n                    self.hostEditor.setSelection(range.start, newEnd, false, 0, self._origin);\n                });\n                this._isOwnChange = false;\n            }\n            \n            this._timingFunction = timingFunctionMatch;\n        }\n    };\n    \n    /**\n     * @override\n     * @param {!Editor} hostEditor\n     */\n    InlineTimingFunctionEditor.prototype.load = function (hostEditor) {\n        InlineTimingFunctionEditor.prototype.parentClass.load.apply(this, arguments);\n        \n        // Create appropriate timing function editor control\n        if (this._timingFunction.isBezier) {\n            this.timingFunctionEditor = new BezierCurveEditor(this.$htmlContent, this._timingFunction, this._handleTimingFunctionChange);\n        } else if (this._timingFunction.isStep) {\n            this.timingFunctionEditor = new StepEditor(this.$htmlContent, this._timingFunction, this._handleTimingFunctionChange);\n        } else {\n            window.console.log(\"InlineTimingFunctionEditor.load tried to load an unkown timing function type\");\n        }\n    };\n\n    /**\n     * @override\n     * Perform sizing & focus once we've been added to Editor's DOM\n     */\n    InlineTimingFunctionEditor.prototype.onAdded = function () {\n        InlineTimingFunctionEditor.prototype.parentClass.onAdded.apply(this, arguments);\n        \n        var doc = this.hostEditor.document;\n        doc.addRef();\n        doc.on(\"change\", this._handleHostDocumentChange);\n        \n        this.hostEditor.setInlineWidgetHeight(this, this.timingFunctionEditor.getRootElement().outerHeight(), true);\n        \n        this.timingFunctionEditor.focus();\n    };\n    \n    /**\n     * @override\n     * Called whenever the inline widget is closed, whether automatically or explicitly\n     */\n    InlineTimingFunctionEditor.prototype.onClosed = function () {\n        InlineTimingFunctionEditor.prototype.parentClass.onClosed.apply(this, arguments);\n\n        this.timingFunctionEditor.destroy();\n\n        if (this._startBookmark) {\n            this._startBookmark.clear();\n        }\n        if (this._endBookmark) {\n            this._endBookmark.clear();\n        }\n\n        var doc = this.hostEditor.document;\n        doc.off(\"change\", this._handleHostDocumentChange);\n        doc.releaseRef();\n    };\n\n    /**\n     * When text in the code editor changes, update timing function editor to reflect it\n     */\n    InlineTimingFunctionEditor.prototype._handleHostDocumentChange = function () {\n        // Don't push the change into the timingFunction editor if it came from the timingFunction editor.\n        if (this._isOwnChange) {\n            return;\n        }\n        \n        var range = this.getCurrentRange();\n        if (range) {\n            if (range.match !== this._timingFunction) {\n                this._isHostChange = true;\n                this._isHostChange = false;\n                this._timingFunction = range.match;\n                this.timingFunctionEditor.handleExternalUpdate(range.match);\n            }\n        } else {\n            // The edit caused our range to become invalid. Close the editor.\n            this.close();\n        }\n    };\n\n    exports.InlineTimingFunctionEditor = InlineTimingFunctionEditor;\n});\n\n//# sourceURL=/InlineTimingFunctionEditor.js"),eval("define('text!Localized.css',[],function () { return '.bezier-curve-editor .coordinate-plane:after,\\n.step-editor .coordinate-plane:after {\\n    content: \\'{{INLINE_TIMING_EDITOR_TIME}}\\';\\n}\\n\\n.bezier-curve-editor .coordinate-plane:hover:before {\\n    content: \\'{{INLINE_TIMING_EDITOR_PROGRESSION}} (\\' attr(data-progression) \\'%)\\';\\n}\\n\\n.bezier-curve-editor .coordinate-plane:before,\\n.step-editor .coordinate-plane:before {\\n    content: \\'{{INLINE_TIMING_EDITOR_PROGRESSION}}\\';\\n}\\n\\n.bezier-curve-editor .coordinate-plane:hover:after {\\n    content: \\'{{INLINE_TIMING_EDITOR_TIME}} (\\' attr(data-time) \\'%)\\';\\n}\\n';});\n\n//# sourceURL=/text!Localized.css"),eval('/*\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the "Software"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/*\n * The timing function canvas and editing code was adapted from Lea Verou\'s cubic-bezier project:\n * - https://github.com/LeaVerou/cubic-bezier (cubic-bezier.com)\n * \n * The canvas exceeds the top and bottom of main grid so y-value of points can be\n * dragged outside of the 0-1 range.\n * \n *   . . . . . .\n *   .         .\n *   +---------+\n *   |         |\n *   |         |\n *   |         |\n *   |         |\n *   +---------+ <-- main grid has height of 150\n *   .         .\n *   . . . . . . <-- canvas has height of 300 (extra 75 above/below)\n * \n */\n\n/*jslint vars: true, plusplus: true, devel: true, nomen: true,  regexp: true, indent: 4, maxerr: 50 */\n/*global define, brackets, $, Mustache */\n\ndefine(\'main\',[\'require\',\'exports\',\'module\',\'InlineTimingFunctionEditor\',\'TimingFunctionUtils\',\'text!Localized.css\'],function (require, exports, module) {\n    "use strict";\n\n    // Brackets modules\n    var EditorManager       = brackets.getModule("editor/EditorManager"),\n        ExtensionUtils      = brackets.getModule("utils/ExtensionUtils"),\n        Strings             = brackets.getModule("strings"),\n\n        InlineTimingFunctionEditor = require("InlineTimingFunctionEditor").InlineTimingFunctionEditor,\n        TimingFunctionUtils        = require("TimingFunctionUtils"),\n        Localized                  = require("text!Localized.css");\n\n    \n    // Functions\n\n\n    /**\n     * Prepare hostEditor for an InlineTimingFunctionEditor at pos if possible.\n     * Return editor context if so; otherwise null.\n     *\n     * @param {Editor} hostEditor\n     * @param {{line:Number, ch:Number}} pos\n     * @return {timingFunction:{?string}, reason:{?string}, start:{?TextMarker}, end:{?TextMarker}}\n     */\n    function prepareEditorForProvider(hostEditor, pos) {\n        var cursorLine, sel, startPos, endPos, startBookmark, endBookmark, currentMatch,\n            cm = hostEditor._codeMirror;\n\n        sel = hostEditor.getSelection();\n        if (sel.start.line !== sel.end.line) {\n            return {timingFunction: null, reason: null};\n        }\n        \n        cursorLine = hostEditor.document.getLine(pos.line);\n        \n        // code runs several matches complicated patterns, multiple times, so\n        // first do a quick, simple check to see make sure we may have a match\n        if (!cursorLine.match(/cubic-bezier|linear|ease|step/)) {\n            return {timingFunction: null, reason: null};\n        }\n\n        currentMatch = TimingFunctionUtils.timingFunctionMatch(cursorLine, false);\n        if (!currentMatch) {\n            return {timingFunction: null, reason: Strings.ERROR_TIMINGQUICKEDIT_INVALIDSYNTAX};\n        }\n        \n        // check for subsequent matches, and use first match after pos\n        var lineOffset = 0,\n            matchLength = ((currentMatch.originalString && currentMatch.originalString.length) || currentMatch[0].length);\n        while (pos.ch > (currentMatch.index + matchLength + lineOffset)) {\n            var restOfLine = cursorLine.substring(currentMatch.index + matchLength + lineOffset),\n                newMatch = TimingFunctionUtils.timingFunctionMatch(restOfLine, false);\n\n            if (newMatch) {\n                lineOffset += (currentMatch.index + matchLength);\n                currentMatch = $.extend(true, [], newMatch);\n            } else {\n                break;\n            }\n        }\n\n        currentMatch.lineOffset = lineOffset;\n\n        startPos = {line: pos.line, ch: lineOffset + currentMatch.index};\n        endPos   = {line: pos.line, ch: lineOffset + currentMatch.index + matchLength};\n        \n        startBookmark = cm.setBookmark(startPos);\n        endBookmark   = cm.setBookmark(endPos);\n        \n        // Adjust selection to the match so that the inline editor won\'t\n        // get dismissed while we\'re updating the timing function.\n        hostEditor.setSelection(startPos, endPos);\n        \n        return {\n            timingFunction: currentMatch,\n            start: startBookmark,\n            end: endBookmark\n        };\n    }\n    \n    /**\n     * Registered as an inline editor provider: creates an InlineTimingFunctionEditor\n     * when the cursor is on a timing function value.\n     *\n     * @param {!Editor} hostEditor\n     * @param {!{line:Number, ch:Number}} pos\n     * @return {?$.Promise} synchronously resolved with an InlineWidget, or\n     *         {string} if timing function with invalid syntax is detected at pos, or\n     *         null if there\'s no timing function at pos.\n     */\n    function inlineTimingFunctionEditorProvider(hostEditor, pos) {\n        var context = prepareEditorForProvider(hostEditor, pos),\n            inlineTimingFunctionEditor,\n            result;\n        \n        if (!context.timingFunction) {\n            return context.reason || null;\n        } else {\n            inlineTimingFunctionEditor = new InlineTimingFunctionEditor(context.timingFunction, context.start, context.end);\n            inlineTimingFunctionEditor.load(hostEditor);\n    \n            result = new $.Deferred();\n            result.resolve(inlineTimingFunctionEditor);\n            return result.promise();\n        }\n    }\n    \n    /**\n     * Initialization code\n     */\n    function init() {\n        // Load our stylesheet\n        ExtensionUtils.loadStyleSheet(module, "main.less");\n        ExtensionUtils.addEmbeddedStyleSheet(Mustache.render(Localized, Strings));\n    \n        EditorManager.registerInlineEditProvider(inlineTimingFunctionEditorProvider);\n    }\n\n    init();\n\n    \n    // for unit tests only\n    exports.inlineTimingFunctionEditorProvider = inlineTimingFunctionEditorProvider;\n});\n\n//# sourceURL=/main.js');

//# sourceMappingURL=main.js
//# sourceMappingURL=main.js.map