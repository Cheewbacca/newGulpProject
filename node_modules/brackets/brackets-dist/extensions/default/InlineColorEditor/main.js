eval('// TinyColor v1.1.1\n// https://github.com/bgrins/TinyColor\n// 2014-12-20, Brian Grinstead, MIT License\n!function(){function inputToRGB(color){var rgb={r:0,g:0,b:0},a=1,ok=!1,format=!1;return"string"==typeof color&&(color=stringInputToObject(color)),"object"==typeof color&&(color.hasOwnProperty("r")&&color.hasOwnProperty("g")&&color.hasOwnProperty("b")?(rgb=rgbToRgb(color.r,color.g,color.b),ok=!0,format="%"===String(color.r).substr(-1)?"prgb":"rgb"):color.hasOwnProperty("h")&&color.hasOwnProperty("s")&&color.hasOwnProperty("v")?(color.s=convertToPercentage(color.s),color.v=convertToPercentage(color.v),rgb=hsvToRgb(color.h,color.s,color.v),ok=!0,format="hsv"):color.hasOwnProperty("h")&&color.hasOwnProperty("s")&&color.hasOwnProperty("l")&&(color.s=convertToPercentage(color.s),color.l=convertToPercentage(color.l),rgb=hslToRgb(color.h,color.s,color.l),ok=!0,format="hsl"),color.hasOwnProperty("a")&&(a=color.a)),a=boundAlpha(a),{ok:ok,format:color.format||format,r:mathMin(255,mathMax(rgb.r,0)),g:mathMin(255,mathMax(rgb.g,0)),b:mathMin(255,mathMax(rgb.b,0)),a:a}}function rgbToRgb(r,g,b){return{r:255*bound01(r,255),g:255*bound01(g,255),b:255*bound01(b,255)}}function rgbToHsl(r,g,b){r=bound01(r,255),g=bound01(g,255),b=bound01(b,255);var h,s,max=mathMax(r,g,b),min=mathMin(r,g,b),l=(max+min)/2;if(max==min)h=s=0;else{var d=max-min;switch(s=l>.5?d/(2-max-min):d/(max+min),max){case r:h=(g-b)/d+(b>g?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4}h/=6}return{h:h,s:s,l:l}}function hslToRgb(h,s,l){function hue2rgb(p,q,t){return 0>t&&(t+=1),t>1&&(t-=1),1/6>t?p+6*(q-p)*t:.5>t?q:2/3>t?p+(q-p)*(2/3-t)*6:p}var r,g,b;if(h=bound01(h,360),s=bound01(s,100),l=bound01(l,100),0===s)r=g=b=l;else{var q=.5>l?l*(1+s):l+s-l*s,p=2*l-q;r=hue2rgb(p,q,h+1/3),g=hue2rgb(p,q,h),b=hue2rgb(p,q,h-1/3)}return{r:255*r,g:255*g,b:255*b}}function rgbToHsv(r,g,b){r=bound01(r,255),g=bound01(g,255),b=bound01(b,255);var h,s,max=mathMax(r,g,b),min=mathMin(r,g,b),v=max,d=max-min;if(s=0===max?0:d/max,max==min)h=0;else{switch(max){case r:h=(g-b)/d+(b>g?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4}h/=6}return{h:h,s:s,v:v}}function hsvToRgb(h,s,v){h=6*bound01(h,360),s=bound01(s,100),v=bound01(v,100);var i=math.floor(h),f=h-i,p=v*(1-s),q=v*(1-f*s),t=v*(1-(1-f)*s),mod=i%6,r=[v,q,p,p,t,v][mod],g=[t,v,v,q,p,p][mod],b=[p,p,t,v,v,q][mod];return{r:255*r,g:255*g,b:255*b}}function rgbToHex(r,g,b,allow3Char){var hex=[pad2(mathRound(r).toString(16)),pad2(mathRound(g).toString(16)),pad2(mathRound(b).toString(16))];return allow3Char&&hex[0].charAt(0)==hex[0].charAt(1)&&hex[1].charAt(0)==hex[1].charAt(1)&&hex[2].charAt(0)==hex[2].charAt(1)?hex[0].charAt(0)+hex[1].charAt(0)+hex[2].charAt(0):hex.join("")}function rgbaToHex(r,g,b,a){var hex=[pad2(convertDecimalToHex(a)),pad2(mathRound(r).toString(16)),pad2(mathRound(g).toString(16)),pad2(mathRound(b).toString(16))];return hex.join("")}function desaturate(color,amount){amount=0===amount?0:amount||10;var hsl=tinycolor(color).toHsl();return hsl.s-=amount/100,hsl.s=clamp01(hsl.s),tinycolor(hsl)}function saturate(color,amount){amount=0===amount?0:amount||10;var hsl=tinycolor(color).toHsl();return hsl.s+=amount/100,hsl.s=clamp01(hsl.s),tinycolor(hsl)}function greyscale(color){return tinycolor(color).desaturate(100)}function lighten(color,amount){amount=0===amount?0:amount||10;var hsl=tinycolor(color).toHsl();return hsl.l+=amount/100,hsl.l=clamp01(hsl.l),tinycolor(hsl)}function brighten(color,amount){amount=0===amount?0:amount||10;var rgb=tinycolor(color).toRgb();return rgb.r=mathMax(0,mathMin(255,rgb.r-mathRound(255*-(amount/100)))),rgb.g=mathMax(0,mathMin(255,rgb.g-mathRound(255*-(amount/100)))),rgb.b=mathMax(0,mathMin(255,rgb.b-mathRound(255*-(amount/100)))),tinycolor(rgb)}function darken(color,amount){amount=0===amount?0:amount||10;var hsl=tinycolor(color).toHsl();return hsl.l-=amount/100,hsl.l=clamp01(hsl.l),tinycolor(hsl)}function spin(color,amount){var hsl=tinycolor(color).toHsl(),hue=(mathRound(hsl.h)+amount)%360;return hsl.h=0>hue?360+hue:hue,tinycolor(hsl)}function complement(color){var hsl=tinycolor(color).toHsl();return hsl.h=(hsl.h+180)%360,tinycolor(hsl)}function triad(color){var hsl=tinycolor(color).toHsl(),h=hsl.h;return[tinycolor(color),tinycolor({h:(h+120)%360,s:hsl.s,l:hsl.l}),tinycolor({h:(h+240)%360,s:hsl.s,l:hsl.l})]}function tetrad(color){var hsl=tinycolor(color).toHsl(),h=hsl.h;return[tinycolor(color),tinycolor({h:(h+90)%360,s:hsl.s,l:hsl.l}),tinycolor({h:(h+180)%360,s:hsl.s,l:hsl.l}),tinycolor({h:(h+270)%360,s:hsl.s,l:hsl.l})]}function splitcomplement(color){var hsl=tinycolor(color).toHsl(),h=hsl.h;return[tinycolor(color),tinycolor({h:(h+72)%360,s:hsl.s,l:hsl.l}),tinycolor({h:(h+216)%360,s:hsl.s,l:hsl.l})]}function analogous(color,results,slices){results=results||6,slices=slices||30;var hsl=tinycolor(color).toHsl(),part=360/slices,ret=[tinycolor(color)];for(hsl.h=(hsl.h-(part*results>>1)+720)%360;--results;)hsl.h=(hsl.h+part)%360,ret.push(tinycolor(hsl));return ret}function monochromatic(color,results){results=results||6;for(var hsv=tinycolor(color).toHsv(),h=hsv.h,s=hsv.s,v=hsv.v,ret=[],modification=1/results;results--;)ret.push(tinycolor({h:h,s:s,v:v})),v=(v+modification)%1;return ret}function flip(o){var flipped={};for(var i in o)o.hasOwnProperty(i)&&(flipped[o[i]]=i);return flipped}function boundAlpha(a){return a=parseFloat(a),(isNaN(a)||0>a||a>1)&&(a=1),a}function bound01(n,max){isOnePointZero(n)&&(n="100%");var processPercent=isPercentage(n);return n=mathMin(max,mathMax(0,parseFloat(n))),processPercent&&(n=parseInt(n*max,10)/100),math.abs(n-max)<1e-6?1:n%max/parseFloat(max)}function clamp01(val){return mathMin(1,mathMax(0,val))}function parseIntFromHex(val){return parseInt(val,16)}function isOnePointZero(n){return"string"==typeof n&&-1!=n.indexOf(".")&&1===parseFloat(n)}function isPercentage(n){return"string"==typeof n&&-1!=n.indexOf("%")}function pad2(c){return 1==c.length?"0"+c:""+c}function convertToPercentage(n){return 1>=n&&(n=100*n+"%"),n}function convertDecimalToHex(d){return Math.round(255*parseFloat(d)).toString(16)}function convertHexToDecimal(h){return parseIntFromHex(h)/255}function stringInputToObject(color){color=color.replace(trimLeft,"").replace(trimRight,"").toLowerCase();var named=!1;if(names[color])color=names[color],named=!0;else if("transparent"==color)return{r:0,g:0,b:0,a:0,format:"name"};var match;return(match=matchers.rgb.exec(color))?{r:match[1],g:match[2],b:match[3]}:(match=matchers.rgba.exec(color))?{r:match[1],g:match[2],b:match[3],a:match[4]}:(match=matchers.hsl.exec(color))?{h:match[1],s:match[2],l:match[3]}:(match=matchers.hsla.exec(color))?{h:match[1],s:match[2],l:match[3],a:match[4]}:(match=matchers.hsv.exec(color))?{h:match[1],s:match[2],v:match[3]}:(match=matchers.hsva.exec(color))?{h:match[1],s:match[2],v:match[3],a:match[4]}:(match=matchers.hex8.exec(color))?{a:convertHexToDecimal(match[1]),r:parseIntFromHex(match[2]),g:parseIntFromHex(match[3]),b:parseIntFromHex(match[4]),format:named?"name":"hex8"}:(match=matchers.hex6.exec(color))?{r:parseIntFromHex(match[1]),g:parseIntFromHex(match[2]),b:parseIntFromHex(match[3]),format:named?"name":"hex"}:(match=matchers.hex3.exec(color))?{r:parseIntFromHex(match[1]+""+match[1]),g:parseIntFromHex(match[2]+""+match[2]),b:parseIntFromHex(match[3]+""+match[3]),format:named?"name":"hex"}:!1}var trimLeft=/^[\\s,#]+/,trimRight=/\\s+$/,tinyCounter=0,math=Math,mathRound=math.round,mathMin=math.min,mathMax=math.max,mathRandom=math.random,tinycolor=function tinycolor(color,opts){if(color=color?color:"",opts=opts||{},color instanceof tinycolor)return color;if(!(this instanceof tinycolor))return new tinycolor(color,opts);var rgb=inputToRGB(color);this._originalInput=color,this._r=rgb.r,this._g=rgb.g,this._b=rgb.b,this._a=rgb.a,this._roundA=mathRound(100*this._a)/100,this._format=opts.format||rgb.format,this._gradientType=opts.gradientType,this._r<1&&(this._r=mathRound(this._r)),this._g<1&&(this._g=mathRound(this._g)),this._b<1&&(this._b=mathRound(this._b)),this._ok=rgb.ok,this._tc_id=tinyCounter++};tinycolor.prototype={isDark:function(){return this.getBrightness()<128},isLight:function(){return!this.isDark()},isValid:function(){return this._ok},getOriginalInput:function(){return this._originalInput},getFormat:function(){return this._format},getAlpha:function(){return this._a},getBrightness:function(){var rgb=this.toRgb();return(299*rgb.r+587*rgb.g+114*rgb.b)/1e3},setAlpha:function(value){return this._a=boundAlpha(value),this._roundA=mathRound(100*this._a)/100,this},toHsv:function(){var hsv=rgbToHsv(this._r,this._g,this._b);return{h:360*hsv.h,s:hsv.s,v:hsv.v,a:this._a}},toHsvString:function(){var hsv=rgbToHsv(this._r,this._g,this._b),h=mathRound(360*hsv.h),s=mathRound(100*hsv.s),v=mathRound(100*hsv.v);return 1==this._a?"hsv("+h+", "+s+"%, "+v+"%)":"hsva("+h+", "+s+"%, "+v+"%, "+this._roundA+")"},toHsl:function(){var hsl=rgbToHsl(this._r,this._g,this._b);return{h:360*hsl.h,s:hsl.s,l:hsl.l,a:this._a}},toHslString:function(){var hsl=rgbToHsl(this._r,this._g,this._b),h=mathRound(360*hsl.h),s=mathRound(100*hsl.s),l=mathRound(100*hsl.l);return 1==this._a?"hsl("+h+", "+s+"%, "+l+"%)":"hsla("+h+", "+s+"%, "+l+"%, "+this._roundA+")"},toHex:function(allow3Char){return rgbToHex(this._r,this._g,this._b,allow3Char)},toHexString:function(allow3Char){return"#"+this.toHex(allow3Char)},toHex8:function(){return rgbaToHex(this._r,this._g,this._b,this._a)},toHex8String:function(){return"#"+this.toHex8()},toRgb:function(){return{r:mathRound(this._r),g:mathRound(this._g),b:mathRound(this._b),a:this._a}},toRgbString:function(){return 1==this._a?"rgb("+mathRound(this._r)+", "+mathRound(this._g)+", "+mathRound(this._b)+")":"rgba("+mathRound(this._r)+", "+mathRound(this._g)+", "+mathRound(this._b)+", "+this._roundA+")"},toPercentageRgb:function(){return{r:mathRound(100*bound01(this._r,255))+"%",g:mathRound(100*bound01(this._g,255))+"%",b:mathRound(100*bound01(this._b,255))+"%",a:this._a}},toPercentageRgbString:function(){return 1==this._a?"rgb("+mathRound(100*bound01(this._r,255))+"%, "+mathRound(100*bound01(this._g,255))+"%, "+mathRound(100*bound01(this._b,255))+"%)":"rgba("+mathRound(100*bound01(this._r,255))+"%, "+mathRound(100*bound01(this._g,255))+"%, "+mathRound(100*bound01(this._b,255))+"%, "+this._roundA+")"},toName:function(){return 0===this._a?"transparent":this._a<1?!1:hexNames[rgbToHex(this._r,this._g,this._b,!0)]||!1},toFilter:function(secondColor){var hex8String="#"+rgbaToHex(this._r,this._g,this._b,this._a),secondHex8String=hex8String,gradientType=this._gradientType?"GradientType = 1, ":"";if(secondColor){var s=tinycolor(secondColor);secondHex8String=s.toHex8String()}return"progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")"},toString:function(format){var formatSet=!!format;format=format||this._format;var formattedString=!1,hasAlpha=this._a<1&&this._a>=0,needsAlphaFormat=!formatSet&&hasAlpha&&("hex"===format||"hex6"===format||"hex3"===format||"name"===format);return needsAlphaFormat?"name"===format&&0===this._a?this.toName():this.toRgbString():("rgb"===format&&(formattedString=this.toRgbString()),"prgb"===format&&(formattedString=this.toPercentageRgbString()),("hex"===format||"hex6"===format)&&(formattedString=this.toHexString()),"hex3"===format&&(formattedString=this.toHexString(!0)),"hex8"===format&&(formattedString=this.toHex8String()),"name"===format&&(formattedString=this.toName()),"hsl"===format&&(formattedString=this.toHslString()),"hsv"===format&&(formattedString=this.toHsvString()),formattedString||this.toHexString())},_applyModification:function(fn,args){var color=fn.apply(null,[this].concat([].slice.call(args)));return this._r=color._r,this._g=color._g,this._b=color._b,this.setAlpha(color._a),this},lighten:function(){return this._applyModification(lighten,arguments)},brighten:function(){return this._applyModification(brighten,arguments)},darken:function(){return this._applyModification(darken,arguments)},desaturate:function(){return this._applyModification(desaturate,arguments)},saturate:function(){return this._applyModification(saturate,arguments)},greyscale:function(){return this._applyModification(greyscale,arguments)},spin:function(){return this._applyModification(spin,arguments)},_applyCombination:function(fn,args){return fn.apply(null,[this].concat([].slice.call(args)))},analogous:function(){return this._applyCombination(analogous,arguments)},complement:function(){return this._applyCombination(complement,arguments)},monochromatic:function(){return this._applyCombination(monochromatic,arguments)},splitcomplement:function(){return this._applyCombination(splitcomplement,arguments)},triad:function(){return this._applyCombination(triad,arguments)},tetrad:function(){return this._applyCombination(tetrad,arguments)}},tinycolor.fromRatio=function(color,opts){if("object"==typeof color){var newColor={};for(var i in color)color.hasOwnProperty(i)&&(newColor[i]="a"===i?color[i]:convertToPercentage(color[i]));color=newColor}return tinycolor(color,opts)},tinycolor.equals=function(color1,color2){return color1&&color2?tinycolor(color1).toRgbString()==tinycolor(color2).toRgbString():!1},tinycolor.random=function(){return tinycolor.fromRatio({r:mathRandom(),g:mathRandom(),b:mathRandom()})},tinycolor.mix=function(color1,color2,amount){amount=0===amount?0:amount||50;var w1,rgb1=tinycolor(color1).toRgb(),rgb2=tinycolor(color2).toRgb(),p=amount/100,w=2*p-1,a=rgb2.a-rgb1.a;w1=w*a==-1?w:(w+a)/(1+w*a),w1=(w1+1)/2;var w2=1-w1,rgba={r:rgb2.r*w1+rgb1.r*w2,g:rgb2.g*w1+rgb1.g*w2,b:rgb2.b*w1+rgb1.b*w2,a:rgb2.a*p+rgb1.a*(1-p)};return tinycolor(rgba)},tinycolor.readability=function(color1,color2){var c1=tinycolor(color1),c2=tinycolor(color2),rgb1=c1.toRgb(),rgb2=c2.toRgb(),brightnessA=c1.getBrightness(),brightnessB=c2.getBrightness(),colorDiff=Math.max(rgb1.r,rgb2.r)-Math.min(rgb1.r,rgb2.r)+Math.max(rgb1.g,rgb2.g)-Math.min(rgb1.g,rgb2.g)+Math.max(rgb1.b,rgb2.b)-Math.min(rgb1.b,rgb2.b);return{brightness:Math.abs(brightnessA-brightnessB),color:colorDiff}},tinycolor.isReadable=function(color1,color2){var readability=tinycolor.readability(color1,color2);return readability.brightness>125&&readability.color>500},tinycolor.mostReadable=function(baseColor,colorList){for(var bestColor=null,bestScore=0,bestIsReadable=!1,i=0;i<colorList.length;i++){var readability=tinycolor.readability(baseColor,colorList[i]),readable=readability.brightness>125&&readability.color>500,score=3*(readability.brightness/125)+readability.color/500;(readable&&!bestIsReadable||readable&&bestIsReadable&&score>bestScore||!readable&&!bestIsReadable&&score>bestScore)&&(bestIsReadable=readable,bestScore=score,bestColor=tinycolor(colorList[i]))}return bestColor};var names=tinycolor.names={aliceblue:"f0f8ff",antiquewhite:"faebd7",aqua:"0ff",aquamarine:"7fffd4",azure:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"000",blanchedalmond:"ffebcd",blue:"00f",blueviolet:"8a2be2",brown:"a52a2a",burlywood:"deb887",burntsienna:"ea7e5d",cadetblue:"5f9ea0",chartreuse:"7fff00",chocolate:"d2691e",coral:"ff7f50",cornflowerblue:"6495ed",cornsilk:"fff8dc",crimson:"dc143c",cyan:"0ff",darkblue:"00008b",darkcyan:"008b8b",darkgoldenrod:"b8860b",darkgray:"a9a9a9",darkgreen:"006400",darkgrey:"a9a9a9",darkkhaki:"bdb76b",darkmagenta:"8b008b",darkolivegreen:"556b2f",darkorange:"ff8c00",darkorchid:"9932cc",darkred:"8b0000",darksalmon:"e9967a",darkseagreen:"8fbc8f",darkslateblue:"483d8b",darkslategray:"2f4f4f",darkslategrey:"2f4f4f",darkturquoise:"00ced1",darkviolet:"9400d3",deeppink:"ff1493",deepskyblue:"00bfff",dimgray:"696969",dimgrey:"696969",dodgerblue:"1e90ff",firebrick:"b22222",floralwhite:"fffaf0",forestgreen:"228b22",fuchsia:"f0f",gainsboro:"dcdcdc",ghostwhite:"f8f8ff",gold:"ffd700",goldenrod:"daa520",gray:"808080",green:"008000",greenyellow:"adff2f",grey:"808080",honeydew:"f0fff0",hotpink:"ff69b4",indianred:"cd5c5c",indigo:"4b0082",ivory:"fffff0",khaki:"f0e68c",lavender:"e6e6fa",lavenderblush:"fff0f5",lawngreen:"7cfc00",lemonchiffon:"fffacd",lightblue:"add8e6",lightcoral:"f08080",lightcyan:"e0ffff",lightgoldenrodyellow:"fafad2",lightgray:"d3d3d3",lightgreen:"90ee90",lightgrey:"d3d3d3",lightpink:"ffb6c1",lightsalmon:"ffa07a",lightseagreen:"20b2aa",lightskyblue:"87cefa",lightslategray:"789",lightslategrey:"789",lightsteelblue:"b0c4de",lightyellow:"ffffe0",lime:"0f0",limegreen:"32cd32",linen:"faf0e6",magenta:"f0f",maroon:"800000",mediumaquamarine:"66cdaa",mediumblue:"0000cd",mediumorchid:"ba55d3",mediumpurple:"9370db",mediumseagreen:"3cb371",mediumslateblue:"7b68ee",mediumspringgreen:"00fa9a",mediumturquoise:"48d1cc",mediumvioletred:"c71585",midnightblue:"191970",mintcream:"f5fffa",mistyrose:"ffe4e1",moccasin:"ffe4b5",navajowhite:"ffdead",navy:"000080",oldlace:"fdf5e6",olive:"808000",olivedrab:"6b8e23",orange:"ffa500",orangered:"ff4500",orchid:"da70d6",palegoldenrod:"eee8aa",palegreen:"98fb98",paleturquoise:"afeeee",palevioletred:"db7093",papayawhip:"ffefd5",peachpuff:"ffdab9",peru:"cd853f",pink:"ffc0cb",plum:"dda0dd",powderblue:"b0e0e6",purple:"800080",rebeccapurple:"663399",red:"f00",rosybrown:"bc8f8f",royalblue:"4169e1",saddlebrown:"8b4513",salmon:"fa8072",sandybrown:"f4a460",seagreen:"2e8b57",seashell:"fff5ee",sienna:"a0522d",silver:"c0c0c0",skyblue:"87ceeb",slateblue:"6a5acd",slategray:"708090",slategrey:"708090",snow:"fffafa",springgreen:"00ff7f",steelblue:"4682b4",tan:"d2b48c",teal:"008080",thistle:"d8bfd8",tomato:"ff6347",turquoise:"40e0d0",violet:"ee82ee",wheat:"f5deb3",white:"fff",whitesmoke:"f5f5f5",yellow:"ff0",yellowgreen:"9acd32"},hexNames=tinycolor.hexNames=flip(names),matchers=function(){var CSS_INTEGER="[-\\\\+]?\\\\d+%?",CSS_NUMBER="[-\\\\+]?\\\\d*\\\\.\\\\d+%?",CSS_UNIT="(?:"+CSS_NUMBER+")|(?:"+CSS_INTEGER+")",PERMISSIVE_MATCH3="[\\\\s|\\\\(]+("+CSS_UNIT+")[,|\\\\s]+("+CSS_UNIT+")[,|\\\\s]+("+CSS_UNIT+")\\\\s*\\\\)?",PERMISSIVE_MATCH4="[\\\\s|\\\\(]+("+CSS_UNIT+")[,|\\\\s]+("+CSS_UNIT+")[,|\\\\s]+("+CSS_UNIT+")[,|\\\\s]+("+CSS_UNIT+")\\\\s*\\\\)?";return{rgb:new RegExp("rgb"+PERMISSIVE_MATCH3),rgba:new RegExp("rgba"+PERMISSIVE_MATCH4),hsl:new RegExp("hsl"+PERMISSIVE_MATCH3),hsla:new RegExp("hsla"+PERMISSIVE_MATCH4),hsv:new RegExp("hsv"+PERMISSIVE_MATCH3),hsva:new RegExp("hsva"+PERMISSIVE_MATCH4),hex3:/^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex6:/^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,hex8:/^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/}}();"undefined"!=typeof module&&module.exports?module.exports=tinycolor:"function"==typeof define&&define.amd?define(\'thirdparty/tinycolor-min\',[],function(){return tinycolor}):window.tinycolor=tinycolor}();\n\n//# sourceURL=/thirdparty/tinycolor-min.js'),eval("/**\n * @license RequireJS text 2.0.10 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/requirejs/text for details\n */\n/*jslint regexp: true */\n/*global require, XMLHttpRequest, ActiveXObject,\n  define, window, process, Packages,\n  java, location, Components, FileUtils */\n\ndefine('text',['module'], function (module) {\n    'use strict';\n\n    var text, fs, Cc, Ci, xpcIsWindows,\n        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],\n        xmlRegExp = /^\\s*<\\?xml(\\s)+version=[\\'\\\"](\\d)*.(\\d)*[\\'\\\"](\\s)*\\?>/im,\n        bodyRegExp = /<body[^>]*>\\s*([\\s\\S]+)\\s*<\\/body>/im,\n        hasLocation = typeof location !== 'undefined' && location.href,\n        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\\:/, ''),\n        defaultHostName = hasLocation && location.hostname,\n        defaultPort = hasLocation && (location.port || undefined),\n        buildMap = {},\n        masterConfig = (module.config && module.config()) || {};\n\n    text = {\n        version: '2.0.10',\n\n        strip: function (content) {\n            //Strips <?xml ...?> declarations so that external SVG and XML\n            //documents can be added to a document without worry. Also, if the string\n            //is an HTML document, only the part inside the body tag is returned.\n            if (content) {\n                content = content.replace(xmlRegExp, \"\");\n                var matches = content.match(bodyRegExp);\n                if (matches) {\n                    content = matches[1];\n                }\n            } else {\n                content = \"\";\n            }\n            return content;\n        },\n\n        jsEscape: function (content) {\n            return content.replace(/(['\\\\])/g, '\\\\$1')\n                .replace(/[\\f]/g, \"\\\\f\")\n                .replace(/[\\b]/g, \"\\\\b\")\n                .replace(/[\\n]/g, \"\\\\n\")\n                .replace(/[\\t]/g, \"\\\\t\")\n                .replace(/[\\r]/g, \"\\\\r\")\n                .replace(/[\\u2028]/g, \"\\\\u2028\")\n                .replace(/[\\u2029]/g, \"\\\\u2029\");\n        },\n\n        createXhr: masterConfig.createXhr || function () {\n            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.\n            var xhr, i, progId;\n            if (typeof XMLHttpRequest !== \"undefined\") {\n                return new XMLHttpRequest();\n            } else if (typeof ActiveXObject !== \"undefined\") {\n                for (i = 0; i < 3; i += 1) {\n                    progId = progIds[i];\n                    try {\n                        xhr = new ActiveXObject(progId);\n                    } catch (e) {}\n\n                    if (xhr) {\n                        progIds = [progId];  // so faster next time\n                        break;\n                    }\n                }\n            }\n\n            return xhr;\n        },\n\n        /**\n         * Parses a resource name into its component parts. Resource names\n         * look like: module/name.ext!strip, where the !strip part is\n         * optional.\n         * @param {String} name the resource name\n         * @returns {Object} with properties \"moduleName\", \"ext\" and \"strip\"\n         * where strip is a boolean.\n         */\n        parseName: function (name) {\n            var modName, ext, temp,\n                strip = false,\n                index = name.indexOf(\".\"),\n                isRelative = name.indexOf('./') === 0 ||\n                             name.indexOf('../') === 0;\n\n            if (index !== -1 && (!isRelative || index > 1)) {\n                modName = name.substring(0, index);\n                ext = name.substring(index + 1, name.length);\n            } else {\n                modName = name;\n            }\n\n            temp = ext || modName;\n            index = temp.indexOf(\"!\");\n            if (index !== -1) {\n                //Pull off the strip arg.\n                strip = temp.substring(index + 1) === \"strip\";\n                temp = temp.substring(0, index);\n                if (ext) {\n                    ext = temp;\n                } else {\n                    modName = temp;\n                }\n            }\n\n            return {\n                moduleName: modName,\n                ext: ext,\n                strip: strip\n            };\n        },\n\n        xdRegExp: /^((\\w+)\\:)?\\/\\/([^\\/\\\\]+)/,\n\n        /**\n         * Is an URL on another domain. Only works for browser use, returns\n         * false in non-browser environments. Only used to know if an\n         * optimized .js version of a text resource should be loaded\n         * instead.\n         * @param {String} url\n         * @returns Boolean\n         */\n        useXhr: function (url, protocol, hostname, port) {\n            var uProtocol, uHostName, uPort,\n                match = text.xdRegExp.exec(url);\n            if (!match) {\n                return true;\n            }\n            uProtocol = match[2];\n            uHostName = match[3];\n\n            uHostName = uHostName.split(':');\n            uPort = uHostName[1];\n            uHostName = uHostName[0];\n\n            return (!uProtocol || uProtocol === protocol) &&\n                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&\n                   ((!uPort && !uHostName) || uPort === port);\n        },\n\n        finishLoad: function (name, strip, content, onLoad) {\n            content = strip ? text.strip(content) : content;\n            if (masterConfig.isBuild) {\n                buildMap[name] = content;\n            }\n            onLoad(content);\n        },\n\n        load: function (name, req, onLoad, config) {\n            //Name has format: some.module.filext!strip\n            //The strip part is optional.\n            //if strip is present, then that means only get the string contents\n            //inside a body tag in an HTML string. For XML/SVG content it means\n            //removing the <?xml ...?> declarations so the content can be inserted\n            //into the current doc without problems.\n\n            // Do not bother with the work if a build and text will\n            // not be inlined.\n            if (config.isBuild && !config.inlineText) {\n                onLoad();\n                return;\n            }\n\n            masterConfig.isBuild = config.isBuild;\n\n            var parsed = text.parseName(name),\n                nonStripName = parsed.moduleName +\n                    (parsed.ext ? '.' + parsed.ext : ''),\n                url = req.toUrl(nonStripName),\n                useXhr = (masterConfig.useXhr) ||\n                         text.useXhr;\n\n            // Do not load if it is an empty: url\n            if (url.indexOf('empty:') === 0) {\n                onLoad();\n                return;\n            }\n\n            //Load the text. Use XHR if possible and in a browser.\n            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {\n                text.get(url, function (content) {\n                    text.finishLoad(name, parsed.strip, content, onLoad);\n                }, function (err) {\n                    if (onLoad.error) {\n                        onLoad.error(err);\n                    }\n                });\n            } else {\n                //Need to fetch the resource across domains. Assume\n                //the resource has been optimized into a JS module. Fetch\n                //by the module name + extension, but do not include the\n                //!strip part to avoid file system issues.\n                req([nonStripName], function (content) {\n                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,\n                                    parsed.strip, content, onLoad);\n                });\n            }\n        },\n\n        write: function (pluginName, moduleName, write, config) {\n            if (buildMap.hasOwnProperty(moduleName)) {\n                var content = text.jsEscape(buildMap[moduleName]);\n                write.asModule(pluginName + \"!\" + moduleName,\n                               \"define(function () { return '\" +\n                                   content +\n                               \"';});\\n\");\n            }\n        },\n\n        writeFile: function (pluginName, moduleName, req, write, config) {\n            var parsed = text.parseName(moduleName),\n                extPart = parsed.ext ? '.' + parsed.ext : '',\n                nonStripName = parsed.moduleName + extPart,\n                //Use a '.js' file name so that it indicates it is a\n                //script that can be loaded across domains.\n                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';\n\n            //Leverage own load() method to load plugin value, but only\n            //write out values that do not have the strip argument,\n            //to avoid any potential issues with ! in file names.\n            text.load(nonStripName, req, function (value) {\n                //Use own write() method to construct full module value.\n                //But need to create shell that translates writeFile's\n                //write() to the right interface.\n                var textWrite = function (contents) {\n                    return write(fileName, contents);\n                };\n                textWrite.asModule = function (moduleName, contents) {\n                    return write.asModule(moduleName, fileName, contents);\n                };\n\n                text.write(pluginName, nonStripName, textWrite, config);\n            }, config);\n        }\n    };\n\n    if (masterConfig.env === 'node' || (!masterConfig.env &&\n            typeof process !== \"undefined\" &&\n            process.versions &&\n            !!process.versions.node &&\n            !process.versions['node-webkit'])) {\n        //Using special require.nodeRequire, something added by r.js.\n        fs = require.nodeRequire('fs');\n\n        text.get = function (url, callback, errback) {\n            try {\n                var file = fs.readFileSync(url, 'utf8');\n                //Remove BOM (Byte Mark Order) from utf8 files if it is there.\n                if (file.indexOf('\\uFEFF') === 0) {\n                    file = file.substring(1);\n                }\n                callback(file);\n            } catch (e) {\n                errback(e);\n            }\n        };\n    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&\n            text.createXhr())) {\n        text.get = function (url, callback, errback, headers) {\n            var xhr = text.createXhr(), header;\n            xhr.open('GET', url, true);\n\n            //Allow plugins direct access to xhr headers\n            if (headers) {\n                for (header in headers) {\n                    if (headers.hasOwnProperty(header)) {\n                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);\n                    }\n                }\n            }\n\n            //Allow overrides specified in config\n            if (masterConfig.onXhr) {\n                masterConfig.onXhr(xhr, url);\n            }\n\n            xhr.onreadystatechange = function (evt) {\n                var status, err;\n                //Do not explicitly handle errors, those should be\n                //visible via console output in the browser.\n                if (xhr.readyState === 4) {\n                    status = xhr.status;\n                    if (status > 399 && status < 600) {\n                        //An http 4xx or 5xx error. Signal an error.\n                        err = new Error(url + ' HTTP status: ' + status);\n                        err.xhr = xhr;\n                        errback(err);\n                    } else {\n                        callback(xhr.responseText);\n                    }\n\n                    if (masterConfig.onXhrComplete) {\n                        masterConfig.onXhrComplete(xhr, url);\n                    }\n                }\n            };\n            xhr.send(null);\n        };\n    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&\n            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {\n        //Why Java, why is this so awkward?\n        text.get = function (url, callback) {\n            var stringBuffer, line,\n                encoding = \"utf-8\",\n                file = new java.io.File(url),\n                lineSeparator = java.lang.System.getProperty(\"line.separator\"),\n                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),\n                content = '';\n            try {\n                stringBuffer = new java.lang.StringBuffer();\n                line = input.readLine();\n\n                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324\n                // http://www.unicode.org/faq/utf_bom.html\n\n                // Note that when we use utf-8, the BOM should appear as \"EF BB BF\", but it doesn't due to this bug in the JDK:\n                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058\n                if (line && line.length() && line.charAt(0) === 0xfeff) {\n                    // Eat the BOM, since we've already found the encoding on this file,\n                    // and we plan to concatenating this buffer with others; the BOM should\n                    // only appear at the top of a file.\n                    line = line.substring(1);\n                }\n\n                if (line !== null) {\n                    stringBuffer.append(line);\n                }\n\n                while ((line = input.readLine()) !== null) {\n                    stringBuffer.append(lineSeparator);\n                    stringBuffer.append(line);\n                }\n                //Make sure we return a JavaScript string and not a Java string.\n                content = String(stringBuffer.toString()); //String\n            } finally {\n                input.close();\n            }\n            callback(content);\n        };\n    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&\n            typeof Components !== 'undefined' && Components.classes &&\n            Components.interfaces)) {\n        //Avert your gaze!\n        Cc = Components.classes,\n        Ci = Components.interfaces;\n        Components.utils['import']('resource://gre/modules/FileUtils.jsm');\n        xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);\n\n        text.get = function (url, callback) {\n            var inStream, convertStream, fileObj,\n                readData = {};\n\n            if (xpcIsWindows) {\n                url = url.replace(/\\//g, '\\\\');\n            }\n\n            fileObj = new FileUtils.File(url);\n\n            //XPCOM, you so crazy\n            try {\n                inStream = Cc['@mozilla.org/network/file-input-stream;1']\n                           .createInstance(Ci.nsIFileInputStream);\n                inStream.init(fileObj, 1, 0, false);\n\n                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']\n                                .createInstance(Ci.nsIConverterInputStream);\n                convertStream.init(inStream, \"utf-8\", inStream.available(),\n                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);\n\n                convertStream.readString(inStream.available(), readData);\n                convertStream.close();\n                inStream.close();\n                callback(readData.value);\n            } catch (e) {\n                throw new Error((fileObj && fileObj.path || '') + ': ' + e);\n            }\n        };\n    }\n    return text;\n});\n\n//# sourceURL=/var/src/brackets/brackets-src/src/thirdparty/text/text.js"),eval('define(\'text!ColorEditorTemplate.html\',[],function () { return \'\\n<div tabindex="-1" class="color-editor">\\n  <section>\\n    <div class="sliders">\\n      <div class="color-selection-field">\\n        <div class="saturation-gradient gradient-overlay"></div>\\n        <div class="luminosity-gradient gradient-overlay"></div>\\n        <div tabindex="0" class="selector-base">\\n          <div class="selector"></div>\\n        </div>\\n      </div>\\n      <div class="hue-slider slider">\\n        <div tabindex="0" class="selector-base">\\n          <div class="selector"></div>\\n        </div>\\n      </div>\\n      <div class="opacity-slider slider">\\n        <div class="opacity-gradient gradient-overlay"></div>\\n        <div tabindex="0" class="selector-base">\\n          <div class="selector"></div>\\n        </div>\\n      </div>\\n    </div>\\n    <footer>\\n      <input class="color-value" />\\n      <ul class="button-bar">\\n        <li class="selected" title="{{COLOR_EDITOR_RGBA_BUTTON_TIP}}"><a href="#" tabindex="0" class="rgba">RGBa</a></li>\\n        <li title="{{COLOR_EDITOR_HEX_BUTTON_TIP}}"><a href="#" tabindex="0" class="hex">Hex</a></li>\\n        <li title="{{COLOR_EDITOR_HSLA_BUTTON_TIP}}"><a href="#" tabindex="0" class="hsla">HSLa</a></li>\\n      </ul>\\n    </footer>\\n  </section>\\n  <aside>\\n    <header>\\n      <div class="large-swatches">\\n        <div class="current-color large-swatch" title="{{COLOR_EDITOR_CURRENT_COLOR_SWATCH_TIP}}"></div>\\n        <div class="original-color large-swatch" title="{{COLOR_EDITOR_ORIGINAL_COLOR_SWATCH_TIP}}"></div>\\n      </div>\\n    </header>\\n    <ul class="swatches"></ul>\\n  </aside>\\n</div>\';});\n\n//# sourceURL=/text!ColorEditorTemplate.html'),eval('/*\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\n *  \n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the "Software"), \n * to deal in the Software without restriction, including without limitation \n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \n * and/or sell copies of the Software, and to permit persons to whom the \n * Software is furnished to do so, subject to the following conditions:\n *  \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *  \n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \n * DEALINGS IN THE SOFTWARE.\n * \n */\n\n/*jslint vars: true, plusplus: true, nomen: true, regexp: true, maxerr: 50 */\n/*global define, brackets, $, window, Mustache */\n\ndefine(\'ColorEditor\',[\'require\',\'exports\',\'module\',\'thirdparty/tinycolor-min\',\'text!ColorEditorTemplate.html\'],function (require, exports, module) {\n    "use strict";\n    \n    var KeyEvent           = brackets.getModule("utils/KeyEvent"),\n        PreferencesManager = brackets.getModule("preferences/PreferencesManager"),\n        StringUtils        = brackets.getModule("utils/StringUtils"),\n        Strings            = brackets.getModule("strings"),\n        tinycolor          = require("thirdparty/tinycolor-min");\n    \n    /** Mustache template that forms the bare DOM structure of the UI */\n    var ColorEditorTemplate = require("text!ColorEditorTemplate.html");\n    \n    /**\n     * @const @type {number}\n     */\n    var STEP_MULTIPLIER = 5;\n    \n    /**\n     * Color picker control; may be used standalone or within an InlineColorEditor inline widget.\n     * @param {!jQuery} $parent  DOM node into which to append the root of the color picker UI\n     * @param {!string} color  Initially selected color\n     * @param {!function(string)} callback  Called whenever selected color changes\n     * @param {!Array.<{value:string, count:number}>} swatches  Quick-access color swatches to include in UI\n     */\n    function ColorEditor($parent, color, callback, swatches) {\n        // Create the DOM structure, filling in localized strings via Mustache\n        this.$element = $(Mustache.render(ColorEditorTemplate, Strings));\n        $parent.append(this.$element);\n        \n        this._callback = callback;\n\n        this._handleKeydown = this._handleKeydown.bind(this);\n        this._handleOpacityKeydown = this._handleOpacityKeydown.bind(this);\n        this._handleHslKeydown = this._handleHslKeydown.bind(this);\n        this._handleHueKeydown = this._handleHueKeydown.bind(this);\n        this._handleSelectionKeydown = this._handleSelectionKeydown.bind(this);\n        this._handleOpacityDrag = this._handleOpacityDrag.bind(this);\n        this._handleHueDrag = this._handleHueDrag.bind(this);\n        this._handleSelectionFieldDrag = this._handleSelectionFieldDrag.bind(this);\n\n        this._color = tinycolor(color);\n        this._originalColor = color;\n        this._redoColor = null;\n        this._isUpperCase = PreferencesManager.get("uppercaseColors");\n        PreferencesManager.on("change", "uppercaseColors", function () {\n            this._isUpperCase = PreferencesManager.get("uppercaseColors");\n        }.bind(this));\n        \n        this.$colorValue = this.$element.find(".color-value");\n        this.$buttonList = this.$element.find("ul.button-bar");\n        this.$rgbaButton = this.$element.find(".rgba");\n        this.$hexButton = this.$element.find(".hex");\n        this.$hslButton = this.$element.find(".hsla");\n        this.$currentColor = this.$element.find(".current-color");\n        this.$originalColor = this.$element.find(".original-color");\n        this.$selection = this.$element.find(".color-selection-field");\n        this.$selectionBase = this.$element.find(".color-selection-field .selector-base");\n        this.$hueBase = this.$element.find(".hue-slider .selector-base");\n        this.$opacityGradient = this.$element.find(".opacity-gradient");\n        this.$hueSlider = this.$element.find(".hue-slider");\n        this.$hueSelector = this.$element.find(".hue-slider .selector-base");\n        this.$opacitySlider = this.$element.find(".opacity-slider");\n        this.$opacitySelector = this.$element.find(".opacity-slider .selector-base");\n        this.$swatches = this.$element.find(".swatches");\n        \n        // Create quick-access color swatches\n        this._addSwatches(swatches);\n        \n        // Attach event listeners to main UI elements\n        this._addListeners();\n        \n        // Initially selected color\n        this.$originalColor.css("background-color", this._originalColor);\n        this._commitColor(color);\n    }\n\n    /**\n     * A string or tinycolor object representing the currently selected color\n     * TODO (#2201): type is unpredictable\n     * @type {tinycolor|string}\n     */\n    ColorEditor.prototype._color = null;\n    \n    /**\n     * An HSV representation of the currently selected color.\n     * TODO (#2201): type of _hsv.s/.v is unpredictable\n     * @type {!{h:number, s:number|string, v:number|string, a:number}}\n     */\n    ColorEditor.prototype._hsv = tinycolor("rgba(0,0,0,1)").toHsv();\n    \n    /**\n     * Color that was selected before undo(), if undo was the last change made. Else null.\n     * @type {?string}\n     */\n    ColorEditor.prototype._redoColor = null;\n    \n    /**\n     * Initial value the color picker was opened with\n     * @type {!string}\n     */\n    ColorEditor.prototype._originalColor = null;\n    \n    \n    /** Returns the root DOM node of the ColorPicker UI */\n    ColorEditor.prototype.getRootElement = function () {\n        return this.$element;\n    };\n        \n    /** Attach event listeners for main UI elements */\n    ColorEditor.prototype._addListeners = function () {\n        this._bindColorFormatToRadioButton("rgba");\n        this._bindColorFormatToRadioButton("hex");\n        this._bindColorFormatToRadioButton("hsla");\n        \n        this._bindInputHandlers();\n        \n        this._bindOriginalColorButton();\n        \n        this._registerDragHandler(this.$selection, this._handleSelectionFieldDrag);\n        this._registerDragHandler(this.$hueSlider, this._handleHueDrag);\n        this._registerDragHandler(this.$opacitySlider, this._handleOpacityDrag);\n        this._bindKeyHandler(this.$selectionBase, this._handleSelectionKeydown);\n        this._bindKeyHandler(this.$hueBase, this._handleHueKeydown);\n        this._bindKeyHandler(this.$opacitySelector, this._handleOpacityKeydown);\n        this._bindKeyHandler(this.$hslButton, this._handleHslKeydown);\n        \n        // General key handler gets bubbling events from any focusable part of widget\n        this._bindKeyHandler(this.$element, this._handleKeydown);\n    };\n\n    /**\n     * Update all UI elements to reflect the selected color (_color and _hsv). It is usually\n     * incorrect to call this directly; use _commitColor() or setColorAsHsv() instead.\n     */\n    ColorEditor.prototype._synchronize = function () {\n        var colorValue  = this.getColor().getOriginalInput(),\n            colorObject = tinycolor(colorValue),\n            hueColor    = "hsl(" + this._hsv.h + ", 100%, 50%)";\n        \n        this._updateColorTypeRadioButtons(colorObject.getFormat());\n        this.$colorValue.val(colorValue);\n        this.$currentColor.css("background-color", colorValue);\n        this.$selection.css("background-color", hueColor);\n        this.$hueBase.css("background-color", hueColor);\n        \n        // Update gradients in color square & opacity slider\n        this.$selectionBase.css("background-color", colorObject.toHexString());\n        this.$opacityGradient.css("background-image", "-webkit-gradient(linear, 0% 0%, 0% 100%, from(" + hueColor + "), to(transparent))");\n        \n        // Update slider thumb positions\n        this.$hueSelector.css("bottom", (this._hsv.h / 360 * 100) + "%");\n        this.$opacitySelector.css("bottom", (this._hsv.a * 100) + "%");\n        if (!isNaN(this._hsv.s)) {      // TODO (#2201): type of _hsv.s/.v is unpredictable\n            this._hsv.s = (this._hsv.s * 100) + "%";\n        }\n        if (!isNaN(this._hsv.v)) {\n            this._hsv.v = (this._hsv.v * 100) + "%";\n        }\n        this.$selectionBase.css({\n            left: this._hsv.s,\n            bottom: this._hsv.v\n        });\n    };\n\n    /**\n     * Focus the main color square\'s thumb.\n     * @return {boolean} True if we focused the square, false otherwise.\n     */\n    ColorEditor.prototype.focus = function () {\n        if (!this.$selectionBase.is(":focus")) {\n            this.$selectionBase.focus();\n            return true;\n        }\n        return false;\n    };\n    \n    /**\n     * Remove any preference listeners before destroying the editor.\n     */\n    ColorEditor.prototype.destroy = function () {\n        PreferencesManager.off("change", "uppercaseColors");\n    };\n\n    /**\n     * @return {tinycolor|string} The currently selected color (TODO (#2201): type is unpredictable).\n     */\n    ColorEditor.prototype.getColor = function () {\n        return this._color;\n    };\n\n    /** Update the format button bar\'s selection */\n    ColorEditor.prototype._updateColorTypeRadioButtons = function (format) {\n        this.$buttonList.find("li").removeClass("selected");\n        switch (format) {\n        case "rgb":\n            this.$buttonList.find(".rgba").parent().addClass("selected");\n            break;\n        case "hex":\n        case "name":\n            this.$buttonList.find(".hex").parent().addClass("selected");\n            break;\n        case "hsl":\n            this.$buttonList.find(".hsla").parent().addClass("selected");\n            break;\n        }\n    };\n\n    /** Add event listeners to the format button bar */\n    ColorEditor.prototype._bindColorFormatToRadioButton = function (buttonClass, propertyName, value) {\n        var handler,\n            self = this;\n        handler = function (event) {\n            var newFormat   = $(event.currentTarget).html().toLowerCase().replace("%", "p"),\n                newColor    = self.getColor().toString(),\n                colorObject = tinycolor(newColor);\n\n            switch (newFormat) {\n            case "hsla":\n                newColor = colorObject.toHslString();\n                break;\n            case "rgba":\n                newColor = colorObject.toRgbString();\n                break;\n            case "prgba":\n                newColor = colorObject.toPercentageRgbString();\n                break;\n            case "hex":\n                newColor = colorObject.toHexString();\n                self._hsv.a = 1;\n                break;\n            }\n\n            // We need to run this again whenever RGB/HSL/Hex conversions\n            // are performed to preserve the case\n            newColor = self._isUpperCase ? newColor.toUpperCase() : newColor;\n            self._commitColor(newColor, false);\n        };\n        this.$element.find("." + buttonClass).click(handler);\n    };\n\n    /** Add event listener to the "original color value" swatch */\n    ColorEditor.prototype._bindOriginalColorButton = function () {\n        var self = this;\n        this.$originalColor.click(function (event) {\n            self._commitColor(self._originalColor, true);\n        });\n    };\n\n    /**\n     * Convert percentage values in an RGB color into normal RGB values in the range of 0 - 255.\n     * If the original color is already in non-percentage format, does nothing.\n     * @param {string} color The color to be converted to non-percentage RGB color string.\n     * @return {string} an RGB color string in the normal format using non-percentage values\n     */\n    ColorEditor.prototype._convertToNormalRGB = function (color) {\n        var matches = color.match(/^rgb.*?([0-9]+)\\%.*?([0-9]+)\\%.*?([0-9]+)\\%/i);\n        if (matches) {\n            var i, percentStr, value;\n            for (i = 0; i < 3; i++) {\n                percentStr = matches[i + 1];\n                value = Math.round(255 * Number(percentStr) / 100);\n                if (!isNaN(value)) {\n                    color = color.replace(percentStr + "%", value);\n                }\n            }\n        }\n        return color;\n    };\n    \n    /**\n     * Normalize the given color string into the format used by tinycolor, by adding a space \n     * after commas.\n     * @param {string} color The color to be corrected if it looks like an RGB or HSL color.\n     * @return {string} a normalized color string.\n     */\n    ColorEditor.prototype._normalizeColorString = function (color) {\n        var normalizedColor = color;\n                    \n        // Convert 6-digit hex to 3-digit hex as TinyColor (#ffaacc -> #fac)\n        if (color.match(/^#[0-9a-fA-F]{6}/)) {\n            return tinycolor(color).toString();\n        }\n        if (color.match(/^(rgb|hsl)/i)) {\n            normalizedColor = normalizedColor.replace(/,\\s*/g, ", ");\n            normalizedColor = normalizedColor.replace(/\\(\\s+/, "(");\n            normalizedColor = normalizedColor.replace(/\\s+\\)/, ")");\n        }\n        return normalizedColor;\n    };\n\n    /** Handle changes in text field */\n    ColorEditor.prototype._handleTextFieldInput = function (losingFocus) {\n        var newColor    = $.trim(this.$colorValue.val()),\n            newColorObj = tinycolor(newColor),\n            newColorOk  = newColorObj.isValid();\n\n        // TinyColor will auto correct an incomplete rgb or hsl value into a valid color value.\n        // eg. rgb(0,0,0 -> rgb(0, 0, 0) \n        // We want to avoid having TinyColor do this, because we don\'t want to sync the color\n        // to the UI if it\'s incomplete. To accomplish this, we first normalize the original\n        // color string into the format TinyColor would generate, and then compare it to what\n        // TinyColor actually generates to see if it\'s different. If so, then we assume the color\n        // was incomplete to begin with.\n        if (newColorOk) {\n            newColorOk = (newColorObj.toString() === this._normalizeColorString(newColor));\n        }\n                \n        // Restore to the previous valid color if the new color is invalid or incomplete.\n        if (losingFocus && !newColorOk) {\n            newColor = this.getColor().toString();\n        }\n        \n        // Sync only if we have a valid color or we\'re restoring the previous valid color.\n        if (losingFocus || newColorOk) {\n            this._commitColor(newColor, true);\n        }\n    };\n                    \n    ColorEditor.prototype._bindInputHandlers = function () {\n        var self = this;\n                    \n        this.$colorValue.bind("input", function (event) {\n            self._handleTextFieldInput(false);\n        });\n\n        this.$colorValue.bind("change", function (event) {\n            self._handleTextFieldInput(true);\n        });\n    };\n\n    /**\n     * Populate the UI with the given color swatches and add listeners so they\'re selectable.\n     * @param {!Array.<{value:string, count:number}>} swatches\n     */\n    ColorEditor.prototype._addSwatches = function (swatches) {\n        var self = this;\n \n        // Create swatches\n        swatches.forEach(function (swatch) {\n            var stringFormat = (swatch.count > 1) ? Strings.COLOR_EDITOR_USED_COLOR_TIP_PLURAL : Strings.COLOR_EDITOR_USED_COLOR_TIP_SINGULAR,\n                usedColorTip = StringUtils.format(stringFormat, swatch.value, swatch.count);\n            self.$swatches.append("<li tabindex=\'0\'><div class=\'swatch-bg\'><div class=\'swatch\' style=\'background-color: " +\n                    swatch.value + ";\' title=\'" + usedColorTip + "\'></div></div> <span class=\'value\'" + " title=\'" +\n                    usedColorTip + "\'>" + swatch.value + "</span></li>");\n        });\n\n        // Add key & click listeners to each\n        this.$swatches.find("li").keydown(function (event) {\n            if (event.keyCode === KeyEvent.DOM_VK_RETURN ||\n                    event.keyCode === KeyEvent.DOM_VK_ENTER ||\n                    event.keyCode === KeyEvent.DOM_VK_SPACE) {\n                // Enter/Space is same as clicking on swatch\n                self._commitColor($(event.currentTarget).find(".value").html());\n            } else if (event.keyCode === KeyEvent.DOM_VK_TAB) {\n                // Tab on last swatch loops back to color square\n                if (!event.shiftKey && $(this).next("li").length === 0) {\n                    self.$selectionBase.focus();\n                    return false;\n                }\n            }\n        });\n\n        this.$swatches.find("li").click(function (event) {\n            self._commitColor($(event.currentTarget).find(".value").html());\n        });\n    };\n\n    /**\n     * Checks whether colorVal is a valid color\n     * @param {!string} colorVal\n     * @return {boolean} Whether colorVal is valid\n     */\n    ColorEditor.prototype.isValidColor = function (colorVal) {\n        return tinycolor(colorVal).isValid();\n    };\n\n    /**\n     * Sets _hsv and _color based on an HSV input, and updates the UI. Attempts to preserve\n     * the previous color format.\n     * @param {!{h:number=, s:number=, v:number=}} hsv  Any missing values use the previous color\'s values.\n     */\n    ColorEditor.prototype.setColorAsHsv = function (hsv) {\n        var colorVal, newColor,\n            oldFormat = tinycolor(this.getColor()).getFormat();\n        \n        // Set our state to the new color\n        $.extend(this._hsv, hsv);\n        newColor = tinycolor(this._hsv);\n        \n        switch (oldFormat) {\n        case "hsl":\n            colorVal = newColor.toHslString();\n            break;\n        case "rgb":\n            colorVal = newColor.toRgbString();\n            break;\n        case "prgb":\n            colorVal = newColor.toPercentageRgbString();\n            break;\n        case "hex":\n        case "name":\n            colorVal = this._hsv.a < 1 ? newColor.toRgbString() : newColor.toHexString();\n            break;\n        }\n        colorVal = this._isUpperCase ? colorVal.toUpperCase() : colorVal;\n        this._commitColor(colorVal, false);\n    };\n\n    /**\n     * Sets _color (and optionally _hsv) based on a string input, and updates the UI. The string\'s\n     * format determines the new selected color\'s format.\n     * @param {!string} colorVal\n     * @param {boolean=} resetHsv  Pass false ONLY if hsv set already been modified to match colorVal. Default: true.\n     */\n    ColorEditor.prototype._commitColor = function (colorVal, resetHsv) {\n        if (resetHsv === undefined) {\n            resetHsv = true;\n        }\n        this._callback(colorVal);\n        this._color = tinycolor(colorVal);\n\n        if (resetHsv) {\n            this._hsv = this._color.toHsv();\n        }\n\n        this._redoColor = null;  // if we had undone, this new value blows away the redo history\n        this._synchronize();\n    };\n\n    /**\n     * Sets _color and _hsv based on a string input, and updates the UI. The string\'s\n     * format determines the new selected color\'s format.\n     * @param {!string} colorVal\n     */\n    ColorEditor.prototype.setColorFromString = function (colorVal) {\n        this._commitColor(colorVal, true);  // TODO (#2204): make this less entangled with setColorAsHsv()\n    };\n    \n    /** Converts a mouse coordinate to be relative to zeroPos, and clips to [0, maxOffset] */\n    function _getNewOffset(pos, zeroPos, maxOffset) {\n        var offset = pos - zeroPos;\n        offset = Math.min(maxOffset, Math.max(0, offset));\n        return offset;\n    }\n    \n    /** Dragging color square\'s thumb */\n    ColorEditor.prototype._handleSelectionFieldDrag = function (event) {\n        var height  = this.$selection.height(),\n            width   = this.$selection.width(),\n            xOffset = _getNewOffset(event.clientX, this.$selection.offset().left, width),\n            yOffset = _getNewOffset(event.clientY, this.$selection.offset().top, height),\n            hsv     = {};\n        hsv.s = xOffset / width;\n        hsv.v = 1 - yOffset / height;\n        this.setColorAsHsv(hsv, false);\n        if (!this.$selection.find(".selector-base").is(":focus")) {\n            this.$selection.find(".selector-base").focus();\n        }\n    };\n\n    /** Dragging hue slider thumb */\n    ColorEditor.prototype._handleHueDrag = function (event) {\n        var height = this.$hueSlider.height(),\n            offset = _getNewOffset(event.clientY, this.$hueSlider.offset().top, height),\n            hsv    = {};\n        hsv.h = (1 - offset / height) * 360;\n        this.setColorAsHsv(hsv, false);\n        if (!this.$hueSlider.find(".selector-base").is(":focus")) {\n            this.$hueSlider.find(".selector-base").focus();\n        }\n    };\n\n    /** Dragging opacity slider thumb */\n    ColorEditor.prototype._handleOpacityDrag = function (event) {\n        var height = this.$opacitySlider.height(),\n            offset = _getNewOffset(event.clientY, this.$opacitySlider.offset().top, height),\n            hsv    = {};\n        hsv.a = 1 - (offset / height);\n        this.setColorAsHsv(hsv, false);\n        if (!this.$opacitySlider.find(".selector-base").is(":focus")) {\n            this.$opacitySlider.find(".selector-base").focus();\n        }\n    };\n\n    /**\n     * Helper for attaching drag-related mouse listeners to an element. It\'s up to\n     * \'handler\' to actually move the element as mouse is dragged.\n     * @param {!function(jQuery.event)} handler  Called whenever drag position changes\n     */\n    ColorEditor.prototype._registerDragHandler = function ($element, handler) {\n        var mouseupHandler = function (event) {\n            $(window).unbind("mousemove", handler);\n            $(window).unbind("mouseup", mouseupHandler);\n        };\n        $element.mousedown(function (event) {\n            $(window).bind("mousemove", handler);\n            $(window).bind("mouseup", mouseupHandler);\n        });\n        $element.mousedown(handler);  // run drag-update handler on initial mousedown too\n    };\n    \n    /**\n     * Handles undo gestures while color picker has focus. We don\'t want to let CodeMirror\'s\n     * usual undo logic run since it will destroy our marker.\n     */\n    ColorEditor.prototype.undo = function () {\n        if (this._originalColor.toString() !== this._color.toString()) {\n            var curColor = this._color.toString();\n            this._commitColor(this._originalColor, true);\n            this._redoColor = curColor;\n        }\n    };\n\n    /** Similarly, handle redo gestures while color picker has focus. */\n    ColorEditor.prototype.redo = function () {\n        if (this._redoColor) {\n            this._commitColor(this._redoColor, true);\n            this._redoColor = null;\n        }\n    };\n\n    /** \n     * Global handler for keys in the color editor. Catches undo/redo keys and traps\n     * arrow keys that would be handled by the scroller.\n     */\n    ColorEditor.prototype._handleKeydown = function (event) {\n        var hasCtrl = (brackets.platform === "win") ? (event.ctrlKey) : (event.metaKey);\n        if (hasCtrl) {\n            switch (event.keyCode) {\n            case KeyEvent.DOM_VK_Z:\n                if (event.shiftKey) {\n                    this.redo();\n                } else {\n                    this.undo();\n                }\n                return false;\n            case KeyEvent.DOM_VK_Y:\n                this.redo();\n                return false;\n            }\n        } else {\n            if (event.keyCode === KeyEvent.DOM_VK_LEFT ||\n                    event.keyCode === KeyEvent.DOM_VK_RIGHT ||\n                    event.keyCode === KeyEvent.DOM_VK_UP ||\n                    event.keyCode === KeyEvent.DOM_VK_DOWN) {\n                // Prevent arrow keys that weren\'t handled by a child control \n                // from being handled by a parent, either through bubbling or \n                // through default native behavior. There isn\'t a good general\n                // way to tell if the target would handle this event by default,\n                // so we look to see if the target is a text input control.\n                var preventDefault = false,\n                    $target = $(event.target);\n                    \n                // If the input has no "type" attribute, it defaults to text. So we\n                // have to check for both possibilities.\n                if ($target.is("input:not([type])") || $target.is("input[type=text]")) {\n                    // Text input control. In WebKit, if the cursor gets to the start\n                    // or end of a text field and can\'t move any further, the default \n                    // action doesn\'t take place in the text field, so the event is handled\n                    // by the outer scroller. We have to prevent in that case too.\n                    if ($target[0].selectionStart === $target[0].selectionEnd &&\n                            ((event.keyCode === KeyEvent.DOM_VK_LEFT && $target[0].selectionStart === 0) ||\n                             (event.keyCode === KeyEvent.DOM_VK_RIGHT && $target[0].selectionEnd === $target.val().length))) {\n                        preventDefault = true;\n                    }\n                } else {\n                    // Not a text input control, so we want to prevent default.\n                    preventDefault = true;\n                }\n\n                if (preventDefault) {\n                    event.stopPropagation();\n                    return false; // equivalent to event.preventDefault()\n                }\n            }\n        }\n    };\n\n    ColorEditor.prototype._handleHslKeydown = function (event) {\n        if (event.keyCode === KeyEvent.DOM_VK_TAB) {\n            // If we\'re the last focusable element (no color swatches), Tab wraps around to color square\n            if (!event.shiftKey) {\n                if (this.$swatches.children().length === 0) {\n                    this.$selectionBase.focus();\n                    return false;\n                }\n            }\n        }\n    };\n\n    /** Key events on the color square\'s thumb */\n    ColorEditor.prototype._handleSelectionKeydown = function (event) {\n        var hsv = {},\n            step = 1.5,\n            xOffset,\n            yOffset,\n            adjustedOffset;\n\n        switch (event.keyCode) {\n        case KeyEvent.DOM_VK_LEFT:\n        case KeyEvent.DOM_VK_RIGHT:\n            step = event.shiftKey ? step * STEP_MULTIPLIER : step;\n            xOffset = Number($.trim(this.$selectionBase[0].style.left.replace("%", "")));\n            adjustedOffset = (event.keyCode === KeyEvent.DOM_VK_LEFT) ? (xOffset - step) : (xOffset + step);\n            xOffset = Math.min(100, Math.max(0, adjustedOffset));\n            hsv.s = xOffset / 100;\n            this.setColorAsHsv(hsv, false);\n            return false;\n        case KeyEvent.DOM_VK_DOWN:\n        case KeyEvent.DOM_VK_UP:\n            step = event.shiftKey ? step * STEP_MULTIPLIER : step;\n            yOffset = Number($.trim(this.$selectionBase[0].style.bottom.replace("%", "")));\n            adjustedOffset = (event.keyCode === KeyEvent.DOM_VK_DOWN) ? (yOffset - step) : (yOffset + step);\n            yOffset = Math.min(100, Math.max(0, adjustedOffset));\n            hsv.v = yOffset / 100;\n            this.setColorAsHsv(hsv, false);\n            return false;\n        case KeyEvent.DOM_VK_TAB:\n            // Shift+Tab loops back to last focusable element: last swatch if any; format button bar if not\n            if (event.shiftKey) {\n                if (this.$swatches.children().length === 0) {\n                    this.$hslButton.focus();\n                } else {\n                    this.$swatches.find("li:last").focus();\n                }\n                return false;\n            }\n            break;\n        }\n    };\n\n    /** Key events on the hue slider thumb */\n    ColorEditor.prototype._handleHueKeydown = function (event) {\n        var hsv = {},\n            hue = Number(this._hsv.h),\n            step = 3.6;\n\n        switch (event.keyCode) {\n        case KeyEvent.DOM_VK_DOWN:\n            step = event.shiftKey ? step * STEP_MULTIPLIER : step;\n            hsv.h = (hue - step) <= 0 ? 360 - step : hue - step;\n            this.setColorAsHsv(hsv, false);\n            return false;\n        case KeyEvent.DOM_VK_UP:\n            step = event.shiftKey ? step * STEP_MULTIPLIER : step;\n            hsv.h = (hue + step) >= 360 ? step : hue + step;\n            this.setColorAsHsv(hsv, false);\n            return false;\n        }\n    };\n\n    /** Key events on the opacity slider thumb */\n    ColorEditor.prototype._handleOpacityKeydown = function (event) {\n        var alpha = this._hsv.a,\n            hsv = {},\n            step = 0.01;\n\n        switch (event.keyCode) {\n        case KeyEvent.DOM_VK_DOWN:\n            step = event.shiftKey ? step * STEP_MULTIPLIER : step;\n            if (alpha > 0) {\n                hsv.a = (alpha - step) <= 0 ? 0 : alpha - step;\n                this.setColorAsHsv(hsv);\n            }\n            return false;\n        case KeyEvent.DOM_VK_UP:\n            step = event.shiftKey ? step * STEP_MULTIPLIER : step;\n            if (alpha < 100) {\n                hsv.a = (alpha + step) >= 1 ? 1 : alpha + step;\n                this.setColorAsHsv(hsv);\n            }\n            return false;\n        }\n    };\n\n    ColorEditor.prototype._bindKeyHandler = function ($element, handler) {\n        $element.bind("keydown", handler);\n    };\n\n    // Prevent clicks on some UI elements (color selection field, slider and large swatch) from taking focus\n    $(window.document).on("mousedown", ".color-selection-field, .slider, .large-swatch", function (e) {\n        e.preventDefault();\n    });\n\n    exports.ColorEditor = ColorEditor;\n});\n\n//# sourceURL=/ColorEditor.js'),eval("/*\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\n *  \n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"), \n * to deal in the Software without restriction, including without limitation \n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \n * and/or sell copies of the Software, and to permit persons to whom the \n * Software is furnished to do so, subject to the following conditions:\n *  \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *  \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \n * DEALINGS IN THE SOFTWARE.\n * \n */\n\n/*jslint vars: true, plusplus: true, nomen: true, regexp: true, maxerr: 50 */\n/*global define, brackets, $ */\n\ndefine('InlineColorEditor',['require','exports','module','ColorEditor'],function (require, exports, module) {\n    \"use strict\";\n    \n    var InlineWidget         = brackets.getModule(\"editor/InlineWidget\").InlineWidget,\n        ColorEditor          = require(\"ColorEditor\").ColorEditor,\n        ColorUtils           = brackets.getModule(\"utils/ColorUtils\");\n        \n\n    /** @const @type {number} */\n    var MAX_USED_COLORS = 7;\n    \n    /** @type {number} Global var used to provide a unique ID for each color editor instance's _origin field. */\n    var lastOriginId = 1;\n    \n    /**\n     * Inline widget containing a ColorEditor control\n     * @param {!string} color  Initially selected color\n     * @param {!CodeMirror.TextMarker} marker\n     */\n    function InlineColorEditor(color, marker) {\n        this._color = color;\n        this._marker = marker;\n        this._isOwnChange = false;\n        this._isHostChange = false;\n        this._origin = \"+InlineColorEditor_\" + (lastOriginId++);\n\n        this._handleColorChange = this._handleColorChange.bind(this);\n        this._handleHostDocumentChange = this._handleHostDocumentChange.bind(this);\n        \n        InlineWidget.call(this);\n    }\n    \n    InlineColorEditor.prototype = Object.create(InlineWidget.prototype);\n    InlineColorEditor.prototype.constructor = InlineColorEditor;\n    InlineColorEditor.prototype.parentClass = InlineWidget.prototype;\n    \n    /** @type {!ColorPicker} ColorPicker instance */\n    InlineColorEditor.prototype.colorEditor = null;\n    \n    /** @type {!string} Current value of the color picker control */\n    InlineColorEditor.prototype._color = null;\n    \n    /**\n     * Range of code we're attached to; _marker.find() may by null if sync is lost.\n     * @type {!CodeMirror.TextMarker}\n     */\n    InlineColorEditor.prototype._marker = null;\n    \n    /** @type {boolean} True while we're syncing a color picker change into the code editor */\n    InlineColorEditor.prototype._isOwnChange = null;\n    \n    /** @type {boolean} True while we're syncing a code editor change into the color picker */\n    InlineColorEditor.prototype._isHostChange = null;\n    \n    /** @type {number} ID used to identify edits coming from this inline widget for undo batching */\n    InlineColorEditor.prototype._origin = null;\n    \n    \n    /**\n     * Returns the current text range of the color we're attached to, or null if\n     * we've lost sync with what's in the code.\n     * @return {?{start:{line:number, ch:number}, end:{line:number, ch:number}}}\n     */\n    InlineColorEditor.prototype.getCurrentRange = function () {\n        var pos, start, end;\n        \n        pos = this._marker && this._marker.find();\n\n        start = pos && pos.from;\n        if (!start) {\n            return null;\n        }\n        \n        end = pos.to;\n        if (!end) {\n            end = {line: start.line};\n        }\n        \n        // Even if we think we have a good range end, we want to run the\n        // regexp match to see if there's a valid match that extends past the marker.\n        // This can happen if the user deletes the end of the existing color and then\n        // types some more.\n        \n        var line = this.hostEditor.document.getLine(start.line),\n            matches = line.substr(start.ch).match(ColorUtils.COLOR_REGEX);\n        \n        // Note that end.ch is exclusive, so we don't need to add 1 before comparing to\n        // the matched length here.\n        if (matches && (end.ch === undefined || end.ch - start.ch < matches[0].length)) {\n            end.ch = start.ch + matches[0].length;\n            this._marker.clear();\n            this._marker = this.hostEditor._codeMirror.markText(start, end);\n        }\n        \n        if (end.ch === undefined) {\n            // We were unable to resync the marker.\n            return null;\n        } else {\n            return {start: start, end: end};\n        }\n    };\n        \n    /**\n     * When the color picker's selected color changes, update text in code editor\n     * @param {!string} colorString\n     */\n    InlineColorEditor.prototype._handleColorChange = function (colorString) {\n        var self = this;\n        if (colorString !== this._color) {\n            var range = this.getCurrentRange();\n            if (!range) {\n                return;\n            }\n\n            // Don't push the change back into the host editor if it came from the host editor.\n            if (!this._isHostChange) {\n                var endPos = {\n                        line: range.start.line,\n                        ch: range.start.ch + colorString.length\n                    };\n                this._isOwnChange = true;\n                this.hostEditor.document.batchOperation(function () {\n                    // Replace old color in code with the picker's color, and select it\n                    self.hostEditor.setSelection(range.start, range.end); // workaround for #2805\n                    self.hostEditor.document.replaceRange(colorString, range.start, range.end, self._origin);\n                    self.hostEditor.setSelection(range.start, endPos);\n                    if (self._marker) {\n                        self._marker.clear();\n                        self._marker = self.hostEditor._codeMirror.markText(range.start, endPos);\n                    }\n                });\n                this._isOwnChange = false;\n            }\n            \n            this._color = colorString;\n        }\n    };\n    \n    /**\n     * @override\n     * @param {!Editor} hostEditor\n     */\n    InlineColorEditor.prototype.load = function (hostEditor) {\n        InlineColorEditor.prototype.parentClass.load.apply(this, arguments);\n        \n        // Create color picker control\n        var allColorsInDoc = this.hostEditor.document.getText().match(ColorUtils.COLOR_REGEX);\n        var swatchInfo = this._collateColors(allColorsInDoc, MAX_USED_COLORS);\n        this.colorEditor = new ColorEditor(this.$htmlContent, this._color, this._handleColorChange, swatchInfo);\n    };\n\n    /**\n     * @override\n     * Perform sizing & focus once we've been added to Editor's DOM\n     */\n    InlineColorEditor.prototype.onAdded = function () {\n        InlineColorEditor.prototype.parentClass.onAdded.apply(this, arguments);\n        \n        var doc = this.hostEditor.document;\n        doc.addRef();\n        doc.on(\"change\", this._handleHostDocumentChange);\n        \n        this.hostEditor.setInlineWidgetHeight(this, this.colorEditor.getRootElement().outerHeight(), true);\n        \n        this.colorEditor.focus();\n    };\n    \n    /**\n     * @override\n     * Called whenever the inline widget is closed, whether automatically or explicitly\n     */\n    InlineColorEditor.prototype.onClosed = function () {\n        InlineColorEditor.prototype.parentClass.onClosed.apply(this, arguments);\n\n        if (this._marker) {\n            this._marker.clear();\n        }\n\n        var doc = this.hostEditor.document;\n        doc.off(\"change\", this._handleHostDocumentChange);\n        doc.releaseRef();\n        this.colorEditor.destroy();\n    };\n\n    /** Comparator to sort by which colors are used the most */\n    function _colorSort(a, b) {\n        if (a.count === b.count) {\n            return 0;\n        }\n        if (a.count > b.count) {\n            return -1;\n        }\n        if (a.count < b.count) {\n            return 1;\n        }\n    }\n\n    /**\n     * Counts how many times each color in originalArray occurs (ignoring case) and\n     * retuns the top 'maxLength' number of unique colors.\n     * @param {!Array.<string>} originalArray\n     * @param {number} maxLength\n     * @return {!Array.<{value:string, count:number}>}\n     */\n    InlineColorEditor.prototype._collateColors = function (originalArray, maxLength) {\n        // Maps from lowercase color name to swatch info (user-case color name & occurrence count)\n        /* @type {Object.<string, {value:string, count:number}>} */\n        var colorInfo = {};\n        \n        // Count how many times each color is used\n        originalArray.forEach(function (originalColor) {\n            var key = originalColor.toLowerCase();\n            if (colorInfo[key]) {\n                colorInfo[key].count++;\n            } else {\n                colorInfo[key] = { value: originalColor, count: 1 };\n            }\n        });\n        \n        // Convert to an array\n        var uniqueColors = $.map(colorInfo, function (info) {\n            return info;\n        });\n        \n        // Sort by most-used and return the top N\n        uniqueColors.sort(_colorSort);\n        return uniqueColors.slice(0, maxLength);\n    };\n    \n    /**\n     * When text in the code editor changes, update color picker to reflect it\n     */\n    InlineColorEditor.prototype._handleHostDocumentChange = function () {\n        // Don't push the change into the color editor if it came from the color editor.\n        if (this._isOwnChange) {\n            return;\n        }\n        \n        var range = this.getCurrentRange();\n        if (range) {\n            var newColor = this.hostEditor.document.getRange(range.start, range.end);\n            if (newColor !== this._color) {\n                if (this.colorEditor.isValidColor(newColor)) { // only update the editor if the color string is valid\n                    this._isHostChange = true;\n                    this.colorEditor.setColorFromString(newColor);\n                    this._isHostChange = false;\n                }\n            }\n        } else {\n            // The edit caused our range to become invalid. Close the editor.\n            this.close();\n        }\n    };\n\n    exports.InlineColorEditor = InlineColorEditor;\n});\n\n//# sourceURL=/InlineColorEditor.js"),eval('/*\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\n *  \n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the "Software"), \n * to deal in the Software without restriction, including without limitation \n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \n * and/or sell copies of the Software, and to permit persons to whom the \n * Software is furnished to do so, subject to the following conditions:\n *  \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *  \n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \n * DEALINGS IN THE SOFTWARE.\n * \n */\n\n/*jslint vars: true, plusplus: true, nomen: true, regexp: true, maxerr: 50 */\n/*global define, brackets, $ */\n\ndefine(\'main\',[\'require\',\'exports\',\'module\',\'InlineColorEditor\'],function (require, exports, module) {\n    "use strict";\n    \n    var EditorManager       = brackets.getModule("editor/EditorManager"),\n        ExtensionUtils      = brackets.getModule("utils/ExtensionUtils"),\n        InlineColorEditor   = require("InlineColorEditor").InlineColorEditor,\n        ColorUtils          = brackets.getModule("utils/ColorUtils");\n    \n    \n    /**\n     * Prepare hostEditor for an InlineColorEditor at pos if possible. Return\n     * editor context if so; otherwise null.\n     *\n     * @param {Editor} hostEditor\n     * @param {{line:Number, ch:Number}} pos\n     * @return {?{color:String, marker:TextMarker}}\n     */\n    function prepareEditorForProvider(hostEditor, pos) {\n        var colorRegEx, cursorLine, match, sel, start, end, endPos, marker;\n        \n        sel = hostEditor.getSelection();\n        if (sel.start.line !== sel.end.line) {\n            return null;\n        }\n        \n        colorRegEx = new RegExp(ColorUtils.COLOR_REGEX);\n        cursorLine = hostEditor.document.getLine(pos.line);\n        \n        // Loop through each match of colorRegEx and stop when the one that contains pos is found.\n        do {\n            match = colorRegEx.exec(cursorLine);\n            if (match) {\n                start = match.index;\n                end = start + match[0].length;\n            }\n        } while (match && (pos.ch < start || pos.ch > end));\n        \n        if (!match) {\n            return null;\n        }\n        \n        // Adjust pos to the beginning of the match so that the inline editor won\'t get \n        // dismissed while we\'re updating the color with the new values from user\'s inline editing.\n        pos.ch = start;\n        endPos = {line: pos.line, ch: end};\n        \n        marker = hostEditor._codeMirror.markText(pos, endPos);\n        hostEditor.setSelection(pos, endPos);\n        \n        return {\n            color: match[0],\n            marker: marker\n        };\n    }\n    \n    /**\n     * Registered as an inline editor provider: creates an InlineEditorColor when the cursor\n     * is on a color value (in any flavor of code).\n     *\n     * @param {!Editor} hostEditor\n     * @param {!{line:Number, ch:Number}} pos\n     * @return {?$.Promise} synchronously resolved with an InlineWidget, or null if there\'s\n     *      no color at pos.\n     */\n    function inlineColorEditorProvider(hostEditor, pos) {\n        var context = prepareEditorForProvider(hostEditor, pos),\n            inlineColorEditor,\n            result;\n        \n        if (!context) {\n            return null;\n        } else {\n            inlineColorEditor = new InlineColorEditor(context.color, context.marker);\n            inlineColorEditor.load(hostEditor);\n    \n            result = new $.Deferred();\n            result.resolve(inlineColorEditor);\n            return result.promise();\n        }\n    }\n    \n    \n    // Initialize extension\n    ExtensionUtils.loadStyleSheet(module, "css/main.less");\n    \n    EditorManager.registerInlineEditProvider(inlineColorEditorProvider);\n    \n    // for use by other InlineColorEditors\n    exports.prepareEditorForProvider = prepareEditorForProvider;\n    \n    // for unit tests only\n    exports.inlineColorEditorProvider = inlineColorEditorProvider;\n});\n\n//# sourceURL=/main.js');

//# sourceMappingURL=main.js
//# sourceMappingURL=main.js.map