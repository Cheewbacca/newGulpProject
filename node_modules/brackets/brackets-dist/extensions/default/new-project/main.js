eval('/**\n * @license RequireJS i18n 2.0.2 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/requirejs/i18n for details\n */\n/*jslint regexp: true */\n/*global require: false, navigator: false, define: false */\n\n/**\n * This plugin handles i18n! prefixed modules. It does the following:\n *\n * 1) A regular module can have a dependency on an i18n bundle, but the regular\n * module does not want to specify what locale to load. So it just specifies\n * the top-level bundle, like "i18n!nls/colors".\n *\n * This plugin will load the i18n bundle at nls/colors, see that it is a root/master\n * bundle since it does not have a locale in its name. It will then try to find\n * the best match locale available in that master bundle, then request all the\n * locale pieces for that best match locale. For instance, if the locale is "en-us",\n * then the plugin will ask for the "en-us", "en" and "root" bundles to be loaded\n * (but only if they are specified on the master bundle).\n *\n * Once all the bundles for the locale pieces load, then it mixes in all those\n * locale pieces into each other, then finally sets the context.defined value\n * for the nls/colors bundle to be that mixed in locale.\n *\n * 2) A regular module specifies a specific locale to load. For instance,\n * i18n!nls/fr-fr/colors. In this case, the plugin needs to load the master bundle\n * first, at nls/colors, then figure out what the best match locale is for fr-fr,\n * since maybe only fr or just root is defined for that locale. Once that best\n * fit is found, all of its locale pieces need to have their bundles loaded.\n *\n * Once all the bundles for the locale pieces load, then it mixes in all those\n * locale pieces into each other, then finally sets the context.defined value\n * for the nls/fr-fr/colors bundle to be that mixed in locale.\n */\n(function () {\n    \'use strict\';\n\n    //regexp for reconstructing the master bundle name from parts of the regexp match\n    //nlsRegExp.exec("foo/bar/baz/nls/en-ca/foo") gives:\n    //["foo/bar/baz/nls/en-ca/foo", "foo/bar/baz/nls/", "/", "/", "en-ca", "foo"]\n    //nlsRegExp.exec("foo/bar/baz/nls/foo") gives:\n    //["foo/bar/baz/nls/foo", "foo/bar/baz/nls/", "/", "/", "foo", ""]\n    //so, if match[5] is blank, it means this is the top bundle definition.\n    var nlsRegExp = /(^.*(^|\\/)nls(\\/|$))([^\\/]*)\\/?([^\\/]*)/;\n\n    //Helper function to avoid repeating code. Lots of arguments in the\n    //desire to stay functional and support RequireJS contexts without having\n    //to know about the RequireJS contexts.\n    function addPart(locale, master, needed, toLoad, prefix, suffix) {\n        if (master[locale]) {\n            needed.push(locale);\n            if (master[locale] === true || master[locale] === 1) {\n                toLoad.push(prefix + locale + \'/\' + suffix);\n            }\n        }\n    }\n\n    function addIfExists(req, locale, toLoad, prefix, suffix) {\n        var fullName = prefix + locale + \'/\' + suffix;\n        if (require._fileExists(req.toUrl(fullName + \'.js\'))) {\n            toLoad.push(fullName);\n        }\n    }\n\n    /**\n     * Simple function to mix in properties from source into target,\n     * but only if target does not already have a property of the same name.\n     * This is not robust in IE for transferring methods that match\n     * Object.prototype names, but the uses of mixin here seem unlikely to\n     * trigger a problem related to that.\n     */\n    function mixin(target, source, force) {\n        var prop;\n        for (prop in source) {\n            if (source.hasOwnProperty(prop) && (!target.hasOwnProperty(prop) || force)) {\n                target[prop] = source[prop];\n            } else if (typeof source[prop] === \'object\') {\n                mixin(target[prop], source[prop], force);\n            }\n        }\n    }\n\n    define(\'i18n\',[\'module\'], function (module) {\n        var masterConfig = module.config ? module.config() : {};\n\n        return {\n            version: \'2.0.1+\',\n            /**\n             * Called when a dependency needs to be loaded.\n             */\n            load: function (name, req, onLoad, config) {\n                config = config || {};\n\n                if (config.locale) {\n                    masterConfig.locale = config.locale;\n                }\n\n                var masterName,\n                    match = nlsRegExp.exec(name),\n                    prefix = match[1],\n                    locale = match[4],\n                    suffix = match[5],\n                    parts = locale.split("-"),\n                    toLoad = [],\n                    value = {},\n                    i, part, current = "";\n\n                //If match[5] is blank, it means this is the top bundle definition,\n                //so it does not have to be handled. Locale-specific requests\n                //will have a match[4] value but no match[5]\n                if (match[5]) {\n                    //locale-specific bundle\n                    prefix = match[1];\n                    masterName = prefix + suffix;\n                } else {\n                    //Top-level bundle.\n                    masterName = name;\n                    suffix = match[4];\n                    locale = masterConfig.locale;\n                    if (!locale) {\n                        locale = masterConfig.locale =\n                            typeof navigator === "undefined" ? "root" :\n                            (navigator.language ||\n                             navigator.userLanguage || "root").toLowerCase();\n                    }\n                    parts = locale.split("-");\n                }\n\n                if (config.isBuild) {\n                    //Check for existence of all locale possible files and\n                    //require them if exist.\n                    toLoad.push(masterName);\n                    addIfExists(req, "root", toLoad, prefix, suffix);\n                    for (i = 0; i < parts.length; i++) {\n                        part = parts[i];\n                        current += (current ? "-" : "") + part;\n                        addIfExists(req, current, toLoad, prefix, suffix);\n                    }\n\n                    req(toLoad, function () {\n                        onLoad();\n                    });\n                } else {\n                    //First, fetch the master bundle, it knows what locales are available.\n                    req([masterName], function (master) {\n                        //Figure out the best fit\n                        var needed = [],\n                            part;\n\n                        //Always allow for root, then do the rest of the locale parts.\n                        addPart("root", master, needed, toLoad, prefix, suffix);\n                        for (i = 0; i < parts.length; i++) {\n                            part = parts[i];\n                            current += (current ? "-" : "") + part;\n                            addPart(current, master, needed, toLoad, prefix, suffix);\n                        }\n\n                        //Load all the parts missing.\n                        req(toLoad, function () {\n                            var i, partBundle, part;\n                            for (i = needed.length - 1; i > -1 && needed[i]; i--) {\n                                part = needed[i];\n                                partBundle = master[part];\n                                if (partBundle === true || partBundle === 1) {\n                                    partBundle = req(prefix + part + \'/\' + suffix);\n                                }\n                                mixin(value, partBundle);\n                            }\n\n                            //All done, notify the loader.\n                            onLoad(value);\n                        });\n                    });\n                }\n            }\n        };\n    });\n}());\n\n//# sourceURL=/var/src/brackets/brackets-src/src/thirdparty/i18n/i18n.js'),eval('/*\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\n *  \n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the "Software"), \n * to deal in the Software without restriction, including without limitation \n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \n * and/or sell copies of the Software, and to permit persons to whom the \n * Software is furnished to do so, subject to the following conditions:\n *  \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *  \n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \n * DEALINGS IN THE SOFTWARE.\n * \n */\n\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\n/*global define */\n\ndefine(\'nls/strings\',[\'require\',\'exports\',\'module\'],function (require, exports, module) {\n    \n    \'use strict\';\n    \n    // Code that needs to display user strings should call require("strings") to load\n    // strings.js. This file will dynamically load strings.js for the specified by bracketes.locale.\n    // \n    // Translations for other locales should be placed in nls/<locale<optional country code>>/strings.js\n    // Localization is provided via the i18n plugin.\n    // All other bundles for languages need to add a prefix to the exports below so i18n can find them.\n    // TODO: dynamically populate the local prefix list below?\n    module.exports = {\n        root: true,\n        "fr": true,\n        "de": true,\n        "it": true\n    };\n});\n\n//# sourceURL=/nls/strings.js'),eval('/*\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\n *  \n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the "Software"), \n * to deal in the Software without restriction, including without limitation \n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \n * and/or sell copies of the Software, and to permit persons to whom the \n * Software is furnished to do so, subject to the following conditions:\n *  \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *  \n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \n * DEALINGS IN THE SOFTWARE.\n * \n */\n\n// English - root strings\n\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\n/*global define */\n\ndefine(\'nls/root/strings\',{\n    "MY_DOCUMENTS"                      : "My Documents",\n    "DOCUMENTS"                         : "Documents",\n    "MENU_TITLE"                        : "New Project…",\n    "NEW_PROJECT_BASE_NAME"             : "Untitled-",\n    "CHANGE"                            : "Change…",\n    "PROJECT_DIRECTORY_lABEL"           : "Parent Folder:",\n    "CHOOSE_TEMPLATE_LABEL"             : "Template:",\n    "PROJECT_NAME_LABEL"                : "Name:",\n    "DIALOG_TITLE"                      : "Create New Project",\n    "NO_TEMPLATE_OPTION_LABEL"          : "None (Empty Project)",\n    "ERROR_NOT_A_DIRECTORY"             : "Unable to write to {1} because it is not a valid directory, the volume is offline or does not exist.",\n    "ERROR_DIRECTORY_ALREADY_EXISTS"    : "Unable to create the project directory {1} because it already exists.",\n    "ERROR_UNABLE_TO_WRITE_DIRECTORY"   : "unable to write to {1} (Error {0})",\n    "INVALID_PROJECT_NAME"              : "Invalid Project Name",\n    "INVALID_PROJECT_NAME_MESSAGE"      : "Project names cannot contain the following characters: /?*:;{}<>\\\\| or use any system reserved words.",\n    "ONE_OR_MORE_TEMPLATE_FILES_FAILED" : "Unable to copy all template files to the destination folder. One or more copy operations failed."\n});\n\n//# sourceURL=/nls/root/strings.js'),eval("/*\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\n *  \n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"), \n * to deal in the Software without restriction, including without limitation \n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \n * and/or sell copies of the Software, and to permit persons to whom the \n * Software is furnished to do so, subject to the following conditions:\n *  \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *  \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \n * DEALINGS IN THE SOFTWARE.\n * \n */\n \n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\n/*global define */\n\n/**\n * This file provides the interface to user visible strings in Brackets. Code that needs\n * to display strings should should load this module by calling var Strings = require(\"strings\").\n * The i18n plugin will dynamically load the strings for the right locale and populate\n * the exports variable. See src\\nls\\strings.js for the master file of English strings.\n */\ndefine('strings',['require','exports','module','i18n!nls/strings'],function (require, exports, module) {\n    \"use strict\";\n\n    module.exports = require(\"i18n!nls/strings\");\n\n});\n//# sourceURL=/strings.js"),eval("/**\n * @license RequireJS text 2.0.10 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/requirejs/text for details\n */\n/*jslint regexp: true */\n/*global require, XMLHttpRequest, ActiveXObject,\n  define, window, process, Packages,\n  java, location, Components, FileUtils */\n\ndefine('text',['module'], function (module) {\n    'use strict';\n\n    var text, fs, Cc, Ci, xpcIsWindows,\n        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],\n        xmlRegExp = /^\\s*<\\?xml(\\s)+version=[\\'\\\"](\\d)*.(\\d)*[\\'\\\"](\\s)*\\?>/im,\n        bodyRegExp = /<body[^>]*>\\s*([\\s\\S]+)\\s*<\\/body>/im,\n        hasLocation = typeof location !== 'undefined' && location.href,\n        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\\:/, ''),\n        defaultHostName = hasLocation && location.hostname,\n        defaultPort = hasLocation && (location.port || undefined),\n        buildMap = {},\n        masterConfig = (module.config && module.config()) || {};\n\n    text = {\n        version: '2.0.10',\n\n        strip: function (content) {\n            //Strips <?xml ...?> declarations so that external SVG and XML\n            //documents can be added to a document without worry. Also, if the string\n            //is an HTML document, only the part inside the body tag is returned.\n            if (content) {\n                content = content.replace(xmlRegExp, \"\");\n                var matches = content.match(bodyRegExp);\n                if (matches) {\n                    content = matches[1];\n                }\n            } else {\n                content = \"\";\n            }\n            return content;\n        },\n\n        jsEscape: function (content) {\n            return content.replace(/(['\\\\])/g, '\\\\$1')\n                .replace(/[\\f]/g, \"\\\\f\")\n                .replace(/[\\b]/g, \"\\\\b\")\n                .replace(/[\\n]/g, \"\\\\n\")\n                .replace(/[\\t]/g, \"\\\\t\")\n                .replace(/[\\r]/g, \"\\\\r\")\n                .replace(/[\\u2028]/g, \"\\\\u2028\")\n                .replace(/[\\u2029]/g, \"\\\\u2029\");\n        },\n\n        createXhr: masterConfig.createXhr || function () {\n            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.\n            var xhr, i, progId;\n            if (typeof XMLHttpRequest !== \"undefined\") {\n                return new XMLHttpRequest();\n            } else if (typeof ActiveXObject !== \"undefined\") {\n                for (i = 0; i < 3; i += 1) {\n                    progId = progIds[i];\n                    try {\n                        xhr = new ActiveXObject(progId);\n                    } catch (e) {}\n\n                    if (xhr) {\n                        progIds = [progId];  // so faster next time\n                        break;\n                    }\n                }\n            }\n\n            return xhr;\n        },\n\n        /**\n         * Parses a resource name into its component parts. Resource names\n         * look like: module/name.ext!strip, where the !strip part is\n         * optional.\n         * @param {String} name the resource name\n         * @returns {Object} with properties \"moduleName\", \"ext\" and \"strip\"\n         * where strip is a boolean.\n         */\n        parseName: function (name) {\n            var modName, ext, temp,\n                strip = false,\n                index = name.indexOf(\".\"),\n                isRelative = name.indexOf('./') === 0 ||\n                             name.indexOf('../') === 0;\n\n            if (index !== -1 && (!isRelative || index > 1)) {\n                modName = name.substring(0, index);\n                ext = name.substring(index + 1, name.length);\n            } else {\n                modName = name;\n            }\n\n            temp = ext || modName;\n            index = temp.indexOf(\"!\");\n            if (index !== -1) {\n                //Pull off the strip arg.\n                strip = temp.substring(index + 1) === \"strip\";\n                temp = temp.substring(0, index);\n                if (ext) {\n                    ext = temp;\n                } else {\n                    modName = temp;\n                }\n            }\n\n            return {\n                moduleName: modName,\n                ext: ext,\n                strip: strip\n            };\n        },\n\n        xdRegExp: /^((\\w+)\\:)?\\/\\/([^\\/\\\\]+)/,\n\n        /**\n         * Is an URL on another domain. Only works for browser use, returns\n         * false in non-browser environments. Only used to know if an\n         * optimized .js version of a text resource should be loaded\n         * instead.\n         * @param {String} url\n         * @returns Boolean\n         */\n        useXhr: function (url, protocol, hostname, port) {\n            var uProtocol, uHostName, uPort,\n                match = text.xdRegExp.exec(url);\n            if (!match) {\n                return true;\n            }\n            uProtocol = match[2];\n            uHostName = match[3];\n\n            uHostName = uHostName.split(':');\n            uPort = uHostName[1];\n            uHostName = uHostName[0];\n\n            return (!uProtocol || uProtocol === protocol) &&\n                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&\n                   ((!uPort && !uHostName) || uPort === port);\n        },\n\n        finishLoad: function (name, strip, content, onLoad) {\n            content = strip ? text.strip(content) : content;\n            if (masterConfig.isBuild) {\n                buildMap[name] = content;\n            }\n            onLoad(content);\n        },\n\n        load: function (name, req, onLoad, config) {\n            //Name has format: some.module.filext!strip\n            //The strip part is optional.\n            //if strip is present, then that means only get the string contents\n            //inside a body tag in an HTML string. For XML/SVG content it means\n            //removing the <?xml ...?> declarations so the content can be inserted\n            //into the current doc without problems.\n\n            // Do not bother with the work if a build and text will\n            // not be inlined.\n            if (config.isBuild && !config.inlineText) {\n                onLoad();\n                return;\n            }\n\n            masterConfig.isBuild = config.isBuild;\n\n            var parsed = text.parseName(name),\n                nonStripName = parsed.moduleName +\n                    (parsed.ext ? '.' + parsed.ext : ''),\n                url = req.toUrl(nonStripName),\n                useXhr = (masterConfig.useXhr) ||\n                         text.useXhr;\n\n            // Do not load if it is an empty: url\n            if (url.indexOf('empty:') === 0) {\n                onLoad();\n                return;\n            }\n\n            //Load the text. Use XHR if possible and in a browser.\n            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {\n                text.get(url, function (content) {\n                    text.finishLoad(name, parsed.strip, content, onLoad);\n                }, function (err) {\n                    if (onLoad.error) {\n                        onLoad.error(err);\n                    }\n                });\n            } else {\n                //Need to fetch the resource across domains. Assume\n                //the resource has been optimized into a JS module. Fetch\n                //by the module name + extension, but do not include the\n                //!strip part to avoid file system issues.\n                req([nonStripName], function (content) {\n                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,\n                                    parsed.strip, content, onLoad);\n                });\n            }\n        },\n\n        write: function (pluginName, moduleName, write, config) {\n            if (buildMap.hasOwnProperty(moduleName)) {\n                var content = text.jsEscape(buildMap[moduleName]);\n                write.asModule(pluginName + \"!\" + moduleName,\n                               \"define(function () { return '\" +\n                                   content +\n                               \"';});\\n\");\n            }\n        },\n\n        writeFile: function (pluginName, moduleName, req, write, config) {\n            var parsed = text.parseName(moduleName),\n                extPart = parsed.ext ? '.' + parsed.ext : '',\n                nonStripName = parsed.moduleName + extPart,\n                //Use a '.js' file name so that it indicates it is a\n                //script that can be loaded across domains.\n                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';\n\n            //Leverage own load() method to load plugin value, but only\n            //write out values that do not have the strip argument,\n            //to avoid any potential issues with ! in file names.\n            text.load(nonStripName, req, function (value) {\n                //Use own write() method to construct full module value.\n                //But need to create shell that translates writeFile's\n                //write() to the right interface.\n                var textWrite = function (contents) {\n                    return write(fileName, contents);\n                };\n                textWrite.asModule = function (moduleName, contents) {\n                    return write.asModule(moduleName, fileName, contents);\n                };\n\n                text.write(pluginName, nonStripName, textWrite, config);\n            }, config);\n        }\n    };\n\n    if (masterConfig.env === 'node' || (!masterConfig.env &&\n            typeof process !== \"undefined\" &&\n            process.versions &&\n            !!process.versions.node &&\n            !process.versions['node-webkit'])) {\n        //Using special require.nodeRequire, something added by r.js.\n        fs = require.nodeRequire('fs');\n\n        text.get = function (url, callback, errback) {\n            try {\n                var file = fs.readFileSync(url, 'utf8');\n                //Remove BOM (Byte Mark Order) from utf8 files if it is there.\n                if (file.indexOf('\\uFEFF') === 0) {\n                    file = file.substring(1);\n                }\n                callback(file);\n            } catch (e) {\n                errback(e);\n            }\n        };\n    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&\n            text.createXhr())) {\n        text.get = function (url, callback, errback, headers) {\n            var xhr = text.createXhr(), header;\n            xhr.open('GET', url, true);\n\n            //Allow plugins direct access to xhr headers\n            if (headers) {\n                for (header in headers) {\n                    if (headers.hasOwnProperty(header)) {\n                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);\n                    }\n                }\n            }\n\n            //Allow overrides specified in config\n            if (masterConfig.onXhr) {\n                masterConfig.onXhr(xhr, url);\n            }\n\n            xhr.onreadystatechange = function (evt) {\n                var status, err;\n                //Do not explicitly handle errors, those should be\n                //visible via console output in the browser.\n                if (xhr.readyState === 4) {\n                    status = xhr.status;\n                    if (status > 399 && status < 600) {\n                        //An http 4xx or 5xx error. Signal an error.\n                        err = new Error(url + ' HTTP status: ' + status);\n                        err.xhr = xhr;\n                        errback(err);\n                    } else {\n                        callback(xhr.responseText);\n                    }\n\n                    if (masterConfig.onXhrComplete) {\n                        masterConfig.onXhrComplete(xhr, url);\n                    }\n                }\n            };\n            xhr.send(null);\n        };\n    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&\n            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {\n        //Why Java, why is this so awkward?\n        text.get = function (url, callback) {\n            var stringBuffer, line,\n                encoding = \"utf-8\",\n                file = new java.io.File(url),\n                lineSeparator = java.lang.System.getProperty(\"line.separator\"),\n                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),\n                content = '';\n            try {\n                stringBuffer = new java.lang.StringBuffer();\n                line = input.readLine();\n\n                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324\n                // http://www.unicode.org/faq/utf_bom.html\n\n                // Note that when we use utf-8, the BOM should appear as \"EF BB BF\", but it doesn't due to this bug in the JDK:\n                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058\n                if (line && line.length() && line.charAt(0) === 0xfeff) {\n                    // Eat the BOM, since we've already found the encoding on this file,\n                    // and we plan to concatenating this buffer with others; the BOM should\n                    // only appear at the top of a file.\n                    line = line.substring(1);\n                }\n\n                if (line !== null) {\n                    stringBuffer.append(line);\n                }\n\n                while ((line = input.readLine()) !== null) {\n                    stringBuffer.append(lineSeparator);\n                    stringBuffer.append(line);\n                }\n                //Make sure we return a JavaScript string and not a Java string.\n                content = String(stringBuffer.toString()); //String\n            } finally {\n                input.close();\n            }\n            callback(content);\n        };\n    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&\n            typeof Components !== 'undefined' && Components.classes &&\n            Components.interfaces)) {\n        //Avert your gaze!\n        Cc = Components.classes,\n        Ci = Components.interfaces;\n        Components.utils['import']('resource://gre/modules/FileUtils.jsm');\n        xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);\n\n        text.get = function (url, callback) {\n            var inStream, convertStream, fileObj,\n                readData = {};\n\n            if (xpcIsWindows) {\n                url = url.replace(/\\//g, '\\\\');\n            }\n\n            fileObj = new FileUtils.File(url);\n\n            //XPCOM, you so crazy\n            try {\n                inStream = Cc['@mozilla.org/network/file-input-stream;1']\n                           .createInstance(Ci.nsIFileInputStream);\n                inStream.init(fileObj, 1, 0, false);\n\n                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']\n                                .createInstance(Ci.nsIConverterInputStream);\n                convertStream.init(inStream, \"utf-8\", inStream.available(),\n                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);\n\n                convertStream.readString(inStream.available(), readData);\n                convertStream.close();\n                inStream.close();\n                callback(readData.value);\n            } catch (e) {\n                throw new Error((fileObj && fileObj.path || '') + ': ' + e);\n            }\n        };\n    }\n    return text;\n});\n\n//# sourceURL=/var/src/brackets/brackets-src/src/thirdparty/text/text.js"),eval('define(\'text!htmlContent/New-Project-Dialog.html\',[],function () { return \'<div class="new-project-dialog modal">\\n    <div class="modal-header">\\n        <h1 class="dialog-title">{{ExtensionStrings.DIALOG_TITLE}}</h1>\\n    </div>\\n    <div class="modal-body">\\n        <div class="field-container input-field">\\n            <p class="npd-half-layout">\\n                <label class="npd-label" for="project-name">{{ExtensionStrings.PROJECT_NAME_LABEL}}</label>\\n                <input type="text" placeholder="{{NEXT_NEW_PROJECT_NAME}}" id="project-name"/>\\n            </p>\\n            <p class="npd-half-layout">\\n                <label id="template-part" class="npd-label">{{ExtensionStrings.CHOOSE_TEMPLATE_LABEL}} <span>(in templateFiles Folder)</span></label>\\n                <select id="project-template" required>\\n                    <option id="none">{{ExtensionStrings.NO_TEMPLATE_OPTION_LABEL}}</option>\\n                </select>                \\n            </p>\\n        </div>\\n        <div class="field-container input-field">\\n            <label class="npd-label" for="project-directory">{{ExtensionStrings.PROJECT_DIRECTORY_lABEL}}</label>\\n            <input type="text" value="{{PROJECT_DIRECTORY}}" id="project-directory" readonly/>\\n            <button id="change-directory" class="dialog-button btn">{{ExtensionStrings.CHANGE}}</button>\\n        </div>    \\n    </div>\\n    <div class="modal-footer">\\n        <button class="dialog-button btn" data-button-id="cancel">{{Strings.CANCEL}}</button>\\n        <button class="dialog-button btn primary" data-button-id="ok">{{Strings.OK}}</button>\\n    </div>\\n</div>\\n\';});\n\n//# sourceURL=/text!htmlContent/New-Project-Dialog.html'),eval('/*\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\n *  \n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the "Software"), \n * to deal in the Software without restriction, including without limitation \n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \n * and/or sell copies of the Software, and to permit persons to whom the \n * Software is furnished to do so, subject to the following conditions:\n *  \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *  \n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \n * DEALINGS IN THE SOFTWARE.\n * \n */\n\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\n/*global define, brackets, window, $, Mustache, navigator */\n\ndefine(\'main\',[\'require\',\'exports\',\'module\',\'strings\',\'text!htmlContent/New-Project-Dialog.html\'],function (require, exports, module) {\n    "use strict";\n    \n    // Brackets modules\n    var ProjectManager              = brackets.getModule("project/ProjectManager"),\n        PreferencesManager          = brackets.getModule("preferences/PreferencesManager"),\n        Commands                    = brackets.getModule("command/Commands"),\n        CommandManager              = brackets.getModule("command/CommandManager"),\n        ExtensionUtils              = brackets.getModule("utils/ExtensionUtils"),\n        Strings                     = brackets.getModule("strings"),\n        StringUtils                 = brackets.getModule("utils/StringUtils"),\n        Menus                       = brackets.getModule("command/Menus"),\n        FileUtils                   = brackets.getModule("file/FileUtils"),\n        DefaultDialogs              = brackets.getModule("widgets/DefaultDialogs"),\n        Dialogs                     = brackets.getModule("widgets/Dialogs"),\n        FileSystem                  = brackets.getModule("filesystem/FileSystem"),\n        ExtensionStrings            = require("strings"),\n        NewProjectDialogTemplate    = require("text!htmlContent/New-Project-Dialog.html");\n    \n    var MODULE_NAME                     = "BracketsNewProjectExtension";\n    \n    \n    /** @const {string} New Project command ID */\n    var FILE_NEW_PROJECT                = "file.newProject";\n    \n    var COPY_TEMPLATE_FILES_FAILED      = -9000,\n        CREATE_PARENT_DIRECTORY_ERROR   = -9001;\n    \n    var STATUS_SUCCEEDED                = 1,\n        STATUS_FAILED                   = 0;\n    \n    /** @const {string} Template Config File Name */\n    var TEMPLATE_CONFIG_FILENAME        = "template.json",\n        TARGET_INITIAL_FILENAME         = "index.html",\n        USER_TEMPLATE_FOLDERNAME        = "BracketsProjectTemplates";\n    \n    var _id                             = 0;\n    \n    var _illegalFilenamesRegEx = /^(\\.+|com[1-9]|lpt[1-9]|nul|con|prn|aux)$/i;\n    \n    var _module = module;\n    \n    var _documentsDir = brackets.app.getUserDocumentsDirectory();\n    \n    var _prefs = PreferencesManager.getExtensionPrefs(MODULE_NAME);\n\n    function convertUnixPathToWindowsPath(path) {\n        if (brackets.platform === "win") {\n            path = path.replace(new RegExp(/\\//g), "\\\\");\n        }\n        return path;\n    }\n    \n    function convertWindowsPathToUnixPath(path) {\n        return FileUtils.convertWindowsPathToUnixPath(path);\n    }\n    \n    function cannonicalizeDirectoryPath(path) {\n        if (path && path.length) {\n            var lastChar = path[path.length - 1];\n            if (lastChar !== "/") {\n                path += "/";\n            }\n        }\n        return path;\n    }\n    \n    function getParentDirectory(path) {\n        if (path && path.length) {\n            var lastChar = path[path.length - 1];\n            if (lastChar !== "/") {\n                path = FileUtils.getDirectoryPath(path);\n            } else {\n                path = FileUtils.getDirectoryPath(path.slice(0, -1));\n            }\n        }\n        return path;\n    }\n    \n    function getFilenameFromPath(path) {\n        return FileUtils.getBaseName(path);\n    }\n    \n    function getTemplateFilesFolder() {\n        return FileUtils.getNativeModuleDirectoryPath(_module) + "/templateFiles";\n    }\n    \n    function getUserTemplateFilesFolder() {\n        return _prefs.get("userTemplatesFolder");\n    }\n    \n    function showProjectErrorMessage(err, folder) {\n        var message;\n        if (err === COPY_TEMPLATE_FILES_FAILED) {\n            message = ExtensionStrings.ONE_OR_MORE_TEMPLATE_FILES_FAILED;\n        } else if (err === CREATE_PARENT_DIRECTORY_ERROR) {\n            message = ExtensionStrings.ERROR_NOT_A_DIRECTORY;\n        } else if (err === brackets.fs.ERR_FILE_EXISTS) {\n            message = ExtensionStrings.ERROR_DIRECTORY_ALREADY_EXISTS;\n        } else {\n            message = ExtensionStrings.ERROR_UNABLE_TO_WRITE_DIRECTORY;\n        }\n        \n        Dialogs.showModalDialog(\n            DefaultDialogs.DIALOG_ID_ERROR,\n            ExtensionStrings.DIALOG_TITLE,\n            StringUtils.format(message, err, convertUnixPathToWindowsPath(folder))\n        );\n    }\n    \n    function validateProjectName(projectName) {\n        // Validate file name\n        // Checks for valid Windows filenames:\n        // See http://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx\n        if ((projectName.search(/[\\/?*:;\\{\\}<>\\\\|]+/) !== -1) || projectName.match(_illegalFilenamesRegEx)) {\n            Dialogs.showModalDialog(\n                DefaultDialogs.DIALOG_ID_ERROR,\n                ExtensionStrings.INVALID_PROJECT_NAME,\n                ExtensionStrings.INVALID_PROJECT_NAME_MESSAGE\n            );\n            return false;\n        }\n        return true;\n    }\n    \n    function copyFile(destination, inFile) {\n        var promise = new $.Deferred(),\n            outFile = cannonicalizeDirectoryPath(destination) + getFilenameFromPath(inFile);\n        brackets.fs.stat(outFile, function (err, stats) {\n            if (err === brackets.fs.ERR_NOT_FOUND) {\n                brackets.fs.copyFile(inFile, outFile, function (err) {\n                    if (err === brackets.fs.NO_ERROR) {\n                        promise.resolve();\n                    } else {\n                        // unable to write file\n                        promise.reject(err);\n                    }\n                });\n            } else if (err === brackets.fs.NO_ERROR) {\n                if (stats.isDirectory()) {\n                    promise.reject(brackets.fs.ERR_CANT_WRITE);\n                } else {\n                    promise.reject(brackets.fs.ERR_FILE_EXISTS);\n                }\n            } else {\n                promise.reject(err);\n            }\n        });\n    \n        return promise;\n    }\n\n\n    function copyDirectory(destination, source) {\n        var i,\n            completeCount = 0,\n            errorCount = 0,\n            promise = new $.Deferred();\n        \n        if (!source || !destination) {\n            return promise.resolve(0);\n        }\n            \n        brackets.fs.readdir(source, function (err, fileList) {\n            if (err === brackets.fs.NO_ERROR) {\n                // exclude the template config file\n                var newProjectConfigFileIndex = fileList.indexOf(TEMPLATE_CONFIG_FILENAME);\n                if (newProjectConfigFileIndex >= 0) {\n                    fileList = fileList.slice(0, newProjectConfigFileIndex).concat(fileList.slice(newProjectConfigFileIndex, -1));\n                }\n                var failHandler = function () {\n                    ++errorCount;\n                };\n                var alwaysHandler = function () {\n                    if (++completeCount === fileList.length) {\n                        promise.resolve(errorCount);\n                    }\n                };\n                \n                var doCopy = function (destination, source) {\n                    brackets.fs.stat(source, function (err, stats) {\n                        if (stats.isFile()) {\n                            copyFile(destination, source)\n                                .fail(failHandler)\n                                .always(alwaysHandler);\n                        } else if (stats.isDirectory()) {\n                            destination = cannonicalizeDirectoryPath(destination) + getFilenameFromPath(source);\n                            brackets.fs.makedir(destination, 777, function (err) {\n                                if (err === brackets.fs.NO_ERROR) {\n                                    copyDirectory(destination, source)\n                                        .fail(failHandler)\n                                        .always(alwaysHandler);\n                                } else {\n                                    ++errorCount;\n                                }\n                            });\n                        }\n                    });\n                };\n                \n                for (i = 0; i < fileList.length; i++) {\n                    doCopy(destination, cannonicalizeDirectoryPath(source) + fileList[i]);\n                }\n\n                // avoid race condition on empty folder                \n                if (fileList.length === 0) {\n                    promise.resolve(0);\n                }\n                \n            } else if (err === brackets.fs.ERR_NOT_FOUND) {\n                // No template folder is ok. Nothing to copy..\n                promise.resolve(0);\n            } else {\n                promise.reject(err);\n            }\n        });\n        \n        return promise;\n    }\n    \n    function copyTemplateFiles(destination, templateDetails) {\n        return copyDirectory(destination, templateDetails.dir);\n    }\n\n    function createProjectFolder(projectFolder, templateDetails) {\n        var promise = new $.Deferred();\n        brackets.fs.makedir(projectFolder, 777, function (err) {\n            if (err === brackets.fs.NO_ERROR) {\n                copyTemplateFiles(projectFolder, templateDetails)\n                    .done(function (errorCount) {\n                        if (errorCount && errorCount > 0) {\n                            showProjectErrorMessage(COPY_TEMPLATE_FILES_FAILED, projectFolder);\n                            promise.reject();\n                        } else {\n                            promise.resolve();\n                        }\n                    })\n                    .fail(function (err) {\n                        showProjectErrorMessage(err, projectFolder);\n                        promise.reject(err);\n                    });\n                \n            } else {\n                showProjectErrorMessage(err, projectFolder);\n                promise.reject(err);\n            }\n        });\n        return promise;\n    }\n    \n    \n    function createNewProject(projectFolder, templateDetails, opts) {\n        var parentFolder = getParentDirectory(projectFolder),\n            promise = new $.Deferred();\n        \n        brackets.fs.stat(parentFolder, function (err, stats) {\n            if (err === brackets.fs.NO_ERROR && stats.isDirectory()) {\n                createProjectFolder(projectFolder, templateDetails)\n                    .done(function () {\n                        promise.resolve();\n                    })\n                    .fail(function () {\n                        promise.reject();\n                    });\n            } else {\n                showProjectErrorMessage(CREATE_PARENT_DIRECTORY_ERROR, parentFolder);\n                promise.reject();\n            }\n        });\n        return promise;\n    }\n    \n    function doOpenProjectFile(destination, filename, opts) {\n        var fullpath = cannonicalizeDirectoryPath(destination) + filename;\n        brackets.fs.stat(fullpath, function (err, stats) {\n            if (err === brackets.fs.NO_ERROR && stats.isFile()) {\n                CommandManager.execute(Commands.FILE_ADD_TO_WORKING_SET, { fullPath: fullpath });\n            }\n        });\n    }\n    \n    function openStarterFile(destination, opts) {\n        if (opts.hasOwnProperty("starterFilename")) {\n            doOpenProjectFile(destination, opts.starterFilename, opts);\n        } else {\n            doOpenProjectFile(destination, TARGET_INITIAL_FILENAME, opts);\n        }\n    }\n    \n    function addTemplateFromDirectoryEntry($templateSelect, templateFolder, templateName) {\n        var sourceFolder = cannonicalizeDirectoryPath(templateFolder) + templateName;\n        var addTemplateDirectory = function (err, stats) {\n            if (stats.isDirectory()) {\n                $templateSelect.append("<option id=\\"Template_" + (_id++).toString() + "\\" source=\\"" + sourceFolder + "\\">" + templateName + "</option>");\n            }\n        };\n        brackets.fs.stat(sourceFolder, addTemplateDirectory);\n    }\n    \n    function initProjectTemplatesFromFolder($templateSelect, templateFolder) {\n        var i,\n            result = $.Deferred();\n        \n        brackets.fs.readdir(templateFolder, function (err, fileList) {\n            if (err === brackets.fs.NO_ERROR) {\n                \n                for (i = 0; i < fileList.length; i++) {\n                    addTemplateFromDirectoryEntry($templateSelect, templateFolder, fileList[i]);\n                }\n            }\n            \n            result.resolve();\n        });\n        \n        return result;\n    }\n    \n    function initProjectTemplates($templateSelect) {\n        var result = $.Deferred();\n        initProjectTemplatesFromFolder($templateSelect, getTemplateFilesFolder())\n            .always(function () {\n                initProjectTemplatesFromFolder($templateSelect, getUserTemplateFilesFolder())\n                    .always(function () {\n                        result.resolve();\n                    });\n            });\n        \n        return result;\n    }\n    \n    function getProjectTemplateOptions(templateDetails) {\n        var opts = {},\n            result = new $.Deferred(),\n            templateConfigFilename = cannonicalizeDirectoryPath(templateDetails.dir) + TEMPLATE_CONFIG_FILENAME;\n    \n        brackets.fs.stat(templateConfigFilename, function (err) {\n            if (err !== brackets.fs.NO_ERROR) {\n                result.resolve(opts);\n            } else {\n                brackets.fs.readFile(templateConfigFilename, "utf8", function (err, data) {\n                    if (err === brackets.fs.NO_ERROR) {\n                        opts = $.extend({}, opts, JSON.parse(data));\n                    }\n                    result.resolve(opts);\n                });\n            }\n        });\n        \n        return result;\n    }\n    \n    function _makeid() {\n        var i,\n            id = "",\n            possible = "0123456789";\n\n        for (i = 0; i < 5; i++) {\n            id += possible.charAt(Math.floor(Math.random() * possible.length));\n        }\n\n        return id;\n    }\n    \n    function getNewProjectName(folder, startingOrdinal, depth) {\n        var result = new $.Deferred(),\n            projectFolder = convertUnixPathToWindowsPath(folder),\n            projectName = ExtensionStrings.NEW_PROJECT_BASE_NAME + startingOrdinal.toString(),\n            destination = cannonicalizeDirectoryPath(projectFolder) + projectName;\n       \n        brackets.fs.stat(destination, function (err) {\n            if (err === brackets.fs.ERR_NOT_FOUND) {\n                result.resolve({status: STATUS_SUCCEEDED,\n                                newProjectName: projectName,\n                                ordinal: startingOrdinal});\n            } else if (err !== brackets.fs.NO_ERROR) {\n                // Unknown File system error so just give up and try a random numbered project\n                startingOrdinal = _makeid();\n                result.resolve({status: STATUS_FAILED,\n                                reason: "unknown-error",\n                                newProjectName: ExtensionStrings.NEW_PROJECT_BASE_NAME + startingOrdinal,\n                                ordinal: startingOrdinal});\n            } else if (depth && depth > 100) {\n                // Depth \n                startingOrdinal = _makeid();\n                result.resolve({status: STATUS_FAILED,\n                                reason: "max-try-limit-hit",\n                                newProjectName: ExtensionStrings.NEW_PROJECT_BASE_NAME + startingOrdinal,\n                                ordinal: startingOrdinal});\n            } else {\n                getNewProjectName(folder, startingOrdinal + 1, depth ? depth + 1 : 1).done(function (data) {\n                    result.resolve(data);\n                });\n            }\n        });\n        \n        return result;\n    }\n    \n    function handleNewProject(commandData) {\n        var $dlg,\n            $OkBtn,\n            $changeProjectDirectoryBtn,\n            $projectDirectoryInput,\n            $projectNameInput,\n            $templateSelect,\n            newProjectOrdinal = _prefs.get("newProjectOrdinal") || 1,\n            newProjectFolder = _prefs.get("newProjectsFolder") || _documentsDir;\n\n\n        getNewProjectName(newProjectFolder, newProjectOrdinal).done(function (data) {\n        \n            var defaultProjectName = data.newProjectName;\n\n            var context = {\n                Strings: Strings,\n                ExtensionStrings: ExtensionStrings,\n                PROJECT_DIRECTORY: convertUnixPathToWindowsPath(newProjectFolder),\n                NEXT_NEW_PROJECT_NAME: defaultProjectName\n            };\n\n            var getSelectedTemplateDetails = function () {\n                var index = $templateSelect[0].selectedIndex,\n                    $el = $templateSelect.children("option").eq(index),\n                    templateDir = $el ? $el.attr("source") || "" : "",\n                    templateName = ($el && $el.length === 1) ? $el[0].innerText || "" : "";\n                return { name: templateName, dir: templateDir };\n            };\n            \n            var dialog = Dialogs.showModalDialogUsingTemplate(Mustache.render(NewProjectDialogTemplate, context));\n\n            dialog.done(function (buttonId) {\n                if (buttonId === "ok") {\n                    var projectFolder = convertWindowsPathToUnixPath($projectDirectoryInput.val()),\n                        projectName = $projectNameInput.val(),\n                        destination = cannonicalizeDirectoryPath(projectFolder) + ((projectName.length > 0) ? projectName : defaultProjectName),\n                        templateDetails = getSelectedTemplateDetails();\n                    \n                    getProjectTemplateOptions(templateDetails).done(function (opts) {\n                        createNewProject(destination, templateDetails, opts).done(function () {\n                            ProjectManager.openProject(destination).done(function () {\n                                openStarterFile(destination, opts);\n                            });\n                            if (projectName === defaultProjectName && data.status === STATUS_SUCCEEDED) {\n                                _prefs.set("newProjectOrdinal", ++data.ordinal);\n                            }\n                        });\n                    });\n                }\n            });\n\n            $dlg = dialog.getElement();\n            $OkBtn = $dlg.find(".dialog-button[data-button-id=\'ok\']");\n            $changeProjectDirectoryBtn = $("#change-directory", $dlg);\n            $projectDirectoryInput = $("#project-directory", $dlg);\n            $projectNameInput = $("#project-name", $dlg);\n            $templateSelect = $("#project-template", $dlg);\n\n            $changeProjectDirectoryBtn.click(function (e) {\n                FileSystem.showOpenDialog(false, true, Strings.CHOOSE_FOLDER, newProjectFolder, null,\n                    function (error, files) {\n                        if (!error && files && files.length > 0 && files[0].length > 0) {\n                            newProjectFolder = files[0];\n                            $projectDirectoryInput.val(convertUnixPathToWindowsPath(newProjectFolder));\n                            _prefs.set("newProjectsFolder", newProjectFolder);\n                        }\n                    });\n\n                e.preventDefault();\n                e.stopPropagation();\n            });\n\n            $OkBtn.click(function (e) {\n                if (!validateProjectName($projectNameInput.val())) {\n                    e.preventDefault();\n                    e.stopPropagation();\n                }\n\n            });\n\n            initProjectTemplates($templateSelect);\n        });\n        \n    }\n\n    function getDefaultTemplateFolder() {\n        return cannonicalizeDirectoryPath(_documentsDir) + USER_TEMPLATE_FOLDERNAME;\n    }\n    \n    _prefs.definePreference("newProjectsFolder", "string", "");\n    _prefs.definePreference("userTemplatesFolder", "string", getDefaultTemplateFolder());\n    _prefs.definePreference("newProjectOrdinal", "number", 1);\n    \n    ExtensionUtils.loadStyleSheet(module, "styles/styles.css");\n    \n    CommandManager.register(ExtensionStrings.MENU_TITLE, FILE_NEW_PROJECT, handleNewProject);\n    var menu = Menus.getMenu(Menus.AppMenuBar.FILE_MENU);\n    menu.addMenuItem(FILE_NEW_PROJECT, undefined, Menus.AFTER, Commands.FILE_NEW_UNTITLED);\n});\n\n//# sourceURL=/main.js');

//# sourceMappingURL=main.js
//# sourceMappingURL=main.js.map