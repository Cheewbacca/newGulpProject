{"version":3,"file":"main.js","sources":["Prefs.js","foldhelpers/foldgutter.js","foldhelpers/foldcode.js","foldhelpers/indentFold.js","main.js"],"names":["eval"],"mappings":"AAAAA,KAAA,grNCAAA,KAAA,6wgBCAAA,KDEA,0pVEFAA,KAAA,imFAEAA,KCFA","sourcesContent":["eval(\"/**\\n * Wrapper around brackets pref system to ensure preferences are stored in in one single object instead of using multiple keys.\\n * This is to make it easy for the user who edits their preferences file to easily manage the potentially numerous lines of preferences generated by the persisting code-folding state.\\n * @author Patrick Oladimeji\\n * @date 3/22/14 20:39:53 PM\\n */\\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\\n/*global define, brackets*/\\ndefine(\\'Prefs\\',[\\'require\\',\\'exports\\',\\'module\\'],function (require, exports, module) {\\n    \\\"use strict\\\";\\n    \\n    var ProjectManager              = brackets.getModule(\\\"project/ProjectManager\\\"),\\n        PreferencesManager          = brackets.getModule(\\\"preferences/PreferencesManager\\\"),\\n        prefs                       = PreferencesManager.getExtensionPrefs(\\\"code-folding\\\"),\\n        FOLDS_PREF_KEY              = \\\"code-folding.folds\\\",\\n        // preference key strings are here for now since they are not used in any UI\\n        ENABLE_CODE_FOLDING         = \\\"Enable code folding\\\",\\n        MIN_FOLD_SIZE               = \\\"Minimum fold size\\\",\\n        MIN_FOLD_SIZE_HELP          = \\\"Minimum number of lines to allow in a foldable range\\\",\\n        SAVE_FOLD_STATES            = \\\"Save fold states\\\",\\n        SAVE_FOLD_STATES_HELP       = \\\"Save fold states to disk when editor is closed and restore the folds when reopened\\\",\\n        ALWAYS_USE_INDENT_FOLD      = \\\"Always use indent fold\\\",\\n        ALWAYS_USE_INDENT_FOLD_HELP = \\\"Fall back to using level of indentation as a folding guideline if no range finder is found for the current mode.\\\",\\n        HIDE_FOLD_BUTTONS           = \\\"Hide fold triangles\\\",\\n        HIDE_FOLD_BUTTONS_HELP      = \\\"Hide fold triangles unless the mouse is over the gutter\\\",\\n        MAX_FOLD_LEVEL              = \\\"Max fold level\\\",\\n        MAX_FOLD_LEVEL_HELP         = \\\"Used to limit the number of nested folds to find and collapse when View -> Collapse All is called or Alt is held down when collapsing. Should improve performance for large files.\\\";\\n\\n    //default preference values\\n    prefs.definePreference(\\\"enabled\\\", \\\"boolean\\\", true,\\n                           {name: ENABLE_CODE_FOLDING, description: ENABLE_CODE_FOLDING});\\n    prefs.definePreference(\\\"minFoldSize\\\", \\\"number\\\", 2,\\n                           {name: MIN_FOLD_SIZE, description: MIN_FOLD_SIZE_HELP});\\n    prefs.definePreference(\\\"saveFoldStates\\\", \\\"boolean\\\", true,\\n                           {name: SAVE_FOLD_STATES, description: SAVE_FOLD_STATES_HELP});\\n    prefs.definePreference(\\\"alwaysUseIndentFold\\\", \\\"boolean\\\", false,\\n                           {name: ALWAYS_USE_INDENT_FOLD, description: ALWAYS_USE_INDENT_FOLD_HELP});\\n    prefs.definePreference(\\\"hideUntilMouseover\\\", \\\"boolean\\\", false,\\n                           {name: HIDE_FOLD_BUTTONS, description: HIDE_FOLD_BUTTONS_HELP});\\n    prefs.definePreference(\\\"maxFoldLevel\\\", \\\"number\\\", 2,\\n                           {name: MAX_FOLD_LEVEL, description: MAX_FOLD_LEVEL_HELP});\\n    \\n    PreferencesManager.stateManager.definePreference(FOLDS_PREF_KEY, \\\"object\\\", {});\\n\\n    /**\\n      * Simplifies the fold ranges into an array of pairs of numbers.\\n      * @param {!Object} folds the raw fold ranges indexed by line numbers\\n      * @return {Object} an object whose keys are line numbers and the values are array\\n      * of two 2-element arrays. First array contains [from.line, from.ch] and the second contains [to.line, to.ch]\\n      */\\n    function simplify(folds) {\\n        if (!folds) {\\n            return;\\n        }\\n        var res = {}, range;\\n        Object.keys(folds).forEach(function (line) {\\n            range = folds[line];\\n            res[line] = Array.isArray(range) ? range : [[range.from.line, range.from.ch], [range.to.line, range.to.ch]];\\n        });\\n        return res;\\n    }\\n\\n    /**\\n      * Inflates the fold ranges stored as simplified numeric arrays. The inflation converts the data into\\n      * objects whose keys are line numbers and whose values are objects in the format {from: {line, ch}, to: {line, ch}}.\\n      * @param {Object}  folds the simplified fold ranges\\n      * @return {Object} the converted fold ranges\\n      */\\n    function inflate(folds) {\\n        if (!folds) {\\n            return;\\n        }\\n         //transform the folds into objects with from and to properties\\n        var ranges = {}, obj;\\n        Object.keys(folds).forEach(function (line) {\\n            obj = folds[line];\\n            ranges[line] = {from: {line: obj[0][0], ch: obj[0][1]}, to: {line: obj[1][0], ch: obj[1][1]}};\\n        });\\n\\n        return ranges;\\n    }\\n    \\n    /**\\n     * Returns a \\'context\\' object for getting/setting project-specific view state preferences.\\n     * Similar to code in MultiRangeInlineEditor._getPrefsContext()...\\n     */\\n    function getViewStateContext() {\\n        var projectRoot = ProjectManager.getProjectRoot();  // note: null during unit tests!\\n        return { location : { scope: \\\"user\\\",\\n                              layer: \\\"project\\\",\\n                              layerID: projectRoot && projectRoot.fullPath } };\\n    }\\n\\n    /**\\n      * Gets the line folds saved for the specified path.\\n      * @param {string} path the document path\\n      * @return {Object} the line folds for the document at the specified path\\n      */\\n    function getFolds(path) {\\n        var context = getViewStateContext();\\n        var folds = PreferencesManager.getViewState(FOLDS_PREF_KEY, context);\\n        return inflate(folds[path]);\\n    }\\n\\n    /**\\n      * Saves the line folds for the specified path\\n      * @param {!string} path the path to the document\\n      * @param {Object} folds the fold ranges to save for the current document\\n      */\\n    function setFolds(path, folds) {\\n        var context = getViewStateContext();\\n        var allFolds = PreferencesManager.getViewState(FOLDS_PREF_KEY, context);\\n        allFolds[path] = simplify(folds);\\n        PreferencesManager.setViewState(FOLDS_PREF_KEY, allFolds, context);\\n    }\\n\\n    /**\\n      * Get the code folding setting with the specified key from the store\\n      * @param {!string} key The key for the setting to retrieve\\n      * @return {string} the setting with the specified key\\n      */\\n    function getSetting(key) {\\n        return prefs.get(key);\\n    }\\n\\n    /**\\n      * Clears all the saved line folds for all documents.\\n      */\\n    function clearAllFolds() {\\n        PreferencesManager.setViewState(FOLDS_PREF_KEY, {});\\n    }\\n\\n    module.exports.getFolds = getFolds;\\n    module.exports.setFolds = setFolds;\\n    module.exports.getSetting = getSetting;\\n    module.exports.clearAllFolds = clearAllFolds;\\n    module.exports.prefsObject = prefs;\\n});\\n\\n//# sourceURL=/Prefs.js\");\n\n","eval(\"// CodeMirror, copyright (c) by Marijn Haverbeke and others\\n// Distributed under an MIT license: http://codemirror.net/LICENSE\\n// Based on http://codemirror.net/addon/fold/foldgutter.js\\n// Modified by Patrick Oladimeji for Brackets\\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\\n/*global define, brackets, document, window, $*/\\ndefine(\\'foldhelpers/foldgutter\\',[\\'require\\',\\'exports\\',\\'module\\',\\'Prefs\\'],function (require, exports, module) {\\n    \\\"use strict\\\";\\n    var CodeMirror      = brackets.getModule(\\\"thirdparty/CodeMirror2/lib/codemirror\\\"),\\n        prefs           = require(\\\"Prefs\\\");\\n\\n    function State(options) {\\n        this.options = options;\\n        this.from = this.to = 0;\\n    }\\n\\n    function parseOptions(opts) {\\n        if (opts === true) { opts = {}; }\\n        if (!opts.gutter) { opts.gutter = \\\"CodeMirror-foldgutter\\\"; }\\n        if (!opts.indicatorOpen) { opts.indicatorOpen = \\\"CodeMirror-foldgutter-open\\\"; }\\n        if (!opts.indicatorFolded) { opts.indicatorFolded = \\\"CodeMirror-foldgutter-folded\\\"; }\\n        return opts;\\n    }\\n\\n    /**\\n      * Utility for creating fold markers in fold gutter\\n      * @param {string} spec the className for the marker\\n      * @return {HTMLElement} a htmlelement representing the fold marker\\n      */\\n    function marker(spec) {\\n        var elt = document.createElement(\\\"div\\\");\\n        elt.className = spec;\\n        return elt;\\n    }\\n\\n    /**\\n     * Checks whether or not a marker is a code-folding marker\\n     * @param   {Object}   m a CodeMirror TextMarker object\\n     * @returns {boolean} true if the marker is a codefolding range marker or false otherwise\\n     */\\n    function isFold(m) {\\n        return m.__isFold;\\n    }\\n\\n    /**\\n      * Updates the gutter markers for the specified range\\n      * @param {!CodeMirror} cm the CodeMirror instance for the active editor\\n      * @param {!number} from the starting line for the update\\n      * @param {!number} to the ending line for the update\\n      */\\n    function updateFoldInfo(cm, from, to) {\\n        var minFoldSize = prefs.getSetting(\\\"minFoldSize\\\") || 2;\\n        var opts = cm.state.foldGutter.options;\\n        var fade = prefs.getSetting(\\\"hideUntilMouseover\\\");\\n        var $gutter = $(cm.getGutterElement());\\n        var i = from;\\n\\n        function clear(m) {\\n            return m.clear();\\n        }\\n\\n        /**\\n          * @private\\n          * helper function to check if the given line is in a folded region in the editor.\\n          * @param {number} line the\\n          * @return {Object} the range that hides the specified line or undefine if the line is not hidden\\n          */\\n        function _isCurrentlyFolded(line) {\\n            var keys = Object.keys(cm._lineFolds), i = 0, range;\\n            while (i < keys.length) {\\n                range = cm._lineFolds[keys[i]];\\n                if (range.from.line < line && range.to.line >= line) {\\n                    return range;\\n                }\\n                i++;\\n            }\\n        }\\n\\n        /**\\n            This case is needed when unfolding a region that does not cause the viewport to change.\\n            For instance in a file with about 15 lines, if some code regions are folded and unfolded, the\\n            viewport change event isn\\'t fired by CodeMirror. The setTimeout is a workaround to trigger the\\n            gutter update after the viewport has been drawn.\\n        */\\n        if (i === to) {\\n            window.setTimeout(function () {\\n                var vp = cm.getViewport();\\n                updateFoldInfo(cm, vp.from, vp.to);\\n            }, 200);\\n        }\\n\\n        while (i < to) {\\n            var sr = _isCurrentlyFolded(i), // surrounding range for the current line if one exists\\n                range;\\n            var mark = marker(\\\"CodeMirror-foldgutter-blank\\\");\\n            var pos = CodeMirror.Pos(i),\\n                func = opts.rangeFinder || CodeMirror.fold.auto;\\n            // don\\'t look inside collapsed ranges\\n            if (sr) {\\n                i = sr.to.line + 1;\\n            } else {\\n                range = cm._lineFolds[i] || (func && func(cm, pos));\\n                if (!fade || (fade && $gutter.is(\\\":hover\\\"))) {\\n                    if (cm.isFolded(i)) {\\n                        // expand fold if invalid\\n                        if (range) {\\n                            mark = marker(opts.indicatorFolded);\\n                        } else {\\n                            cm.findMarksAt(pos).filter(isFold)\\n                                .forEach(clear);\\n                        }\\n                    } else {\\n                        if (range && range.to.line - range.from.line >= minFoldSize) {\\n                            mark = marker(opts.indicatorOpen);\\n                        }\\n                    }\\n                }\\n                cm.setGutterMarker(i, opts.gutter, mark);\\n                i++;\\n            }\\n        }\\n    }\\n\\n    /**\\n      * Updates the fold information in the viewport for the specified range\\n      * @param {CodeMirror} cm the instance of the CodeMirror object\\n      * @param {?number} from the starting line number for the update\\n      * @param {?number} to the end line number for the update\\n      */\\n    function updateInViewport(cm, from, to) {\\n        var vp = cm.getViewport(), state = cm.state.foldGutter;\\n        from = isNaN(from) ? vp.from : from;\\n        to = isNaN(to) ? vp.to : to;\\n\\n        if (!state) { return; }\\n        cm.operation(function () {\\n            updateFoldInfo(cm, from, to);\\n        });\\n        state.from = from;\\n        state.to = to;\\n    }\\n\\n    /**\\n      * Clears the code folding gutter\\n      * @param {!CodeMirror} cm the CodeMirror instance for the active  editor\\n      */\\n    function clearGutter(cm) {\\n        var opts = cm.state.foldGutter.options;\\n        cm.clearGutter(opts.gutter);\\n        var blank = marker(\\\"CodeMirror-foldgutter-blank\\\");\\n        var vp = cm.getViewport();\\n        cm.operation(function () {\\n            cm.eachLine(vp.from, vp.to, function (line) {\\n                cm.setGutterMarker(line.lineNo(), opts.gutter, blank);\\n            });\\n        });\\n    }\\n\\n    /**\\n     * Synchronises the code folding states in the CM doc to cm._lineFolds cache.\\n     * When an undo operation is done, if folded code fragments are restored, then\\n     * we need to update cm._lineFolds with the fragments\\n     * @param {Object}   cm       cm the CodeMirror instance for the active  editor\\n     * @param {Object}   from     starting position in the doc to sync the fold states from\\n     * @param {[[Type]]} lineAdded a number to show how many lines where added to the document\\n     */\\n    function syncDocToFoldsCache(cm, from, lineAdded) {\\n        var minFoldSize = prefs.getSetting(\\\"minFoldSize\\\") || 2;\\n        var opts = cm.state.foldGutter.options || {};\\n        var rf = opts.rangeFinder || CodeMirror.fold.auto;\\n        var i, pos, folds, fold, range;\\n        if (lineAdded <= 0) {\\n            return;\\n        }\\n\\n        for (i = from; i <= from + lineAdded; i = i + 1) {\\n            pos = CodeMirror.Pos(i);\\n            folds = cm.doc.findMarksAt(pos).filter(isFold);\\n            fold = folds.length ? fold = folds[0] : undefined;\\n            if (fold) {\\n                range = rf(cm, CodeMirror.Pos(i));\\n                if (range && range.to.line - range.from.line >= minFoldSize) {\\n                    cm._lineFolds[i] = range;\\n                    i = range.to.line;\\n                } else {\\n                    delete cm._lineFolds[i];\\n                }\\n            }\\n        }\\n\\n    }\\n\\n    /**\\n      * Updates the line folds cache usually when the document changes.\\n      * The following cases are accounted for:\\n      * 1.  When the change does not add a new line to the document we check if the line being modified\\n      *     is folded. If that is the case, changes to this line might affect the range stored in the cache\\n      *     so we update the range.\\n      * 2.  If lines have been added, we need to update the records for all lines in the folds cache\\n      *     which are greater than the line position at which we are adding the new line(s). When existing\\n      *     folds exist above the addition we keep the original position in the cache.\\n      * 3.  If lines are being removed, we need to update the records for all lines in the folds cache which are\\n      *     greater than the line position at which we are removing the new lines, while making sure to\\n      *     not include any folded lines in the cache that are part of the removed chunk.\\n      * @param {!CodeMirror} cm        the CodeMirror instance for the active editor\\n      * @param {!number}     from      the line number designating the start position of the change\\n      * @param {!number}     linesDiff a number to show how many lines where removed or added to the document.\\n      *                                This value is negative for deletions and positive for additions.\\n      */\\n    function updateFoldsCache(cm, from, linesDiff) {\\n        var range;\\n        var minFoldSize = prefs.getSetting(\\\"minFoldSize\\\") || 2;\\n        var foldedLines = Object.keys(cm._lineFolds).map(function (d) {\\n            return +d;\\n        });\\n        var opts = cm.state.foldGutter.options || {};\\n        var rf = opts.rangeFinder || CodeMirror.fold.auto;\\n\\n        if (linesDiff === 0) {\\n            if (foldedLines.indexOf(from) >= 0) {\\n                range = rf(cm, CodeMirror.Pos(from));\\n                if (range && range.to.line - range.from.line >= minFoldSize) {\\n                    cm._lineFolds[from] = range;\\n                } else {\\n                    delete cm._lineFolds[from];\\n                }\\n            }\\n        } else if (foldedLines.length) {\\n            var newFolds = {};\\n            foldedLines.forEach(function (line) {\\n                range = cm._lineFolds[line];\\n                // for removed lines we want to check lines that lie outside the deleted range\\n                if (linesDiff < 0) {\\n                    if (line < from) {\\n                        newFolds[line] = range;\\n                    } else if (line >= from + Math.abs(linesDiff)) {\\n                        range = rf(cm, CodeMirror.Pos(line + linesDiff));\\n                        newFolds[line + linesDiff] = range;\\n                    }\\n                } else {\\n                    if (line < from) {\\n                        newFolds[line] = range;\\n                    } else {\\n                        range = rf(cm, CodeMirror.Pos(line + linesDiff));\\n                        newFolds[line + linesDiff] = range;\\n                    }\\n                }\\n            });\\n            cm._lineFolds = newFolds;\\n        }\\n    }\\n\\n    /**\\n      * Triggered when the content of the document changes. When the entire content of the document\\n      * is changed - e.g., changes made from a different editor, the same lineFolds are kept only if\\n      * they are still valid in the context of the new document content.\\n      * @param {!CodeMirror} cm the CodeMirror instance for the active editor\\n      * @param {!Object} changeObj detailed information about the change that occurred in the document\\n      */\\n    function onChange(cm, changeObj) {\\n        if (changeObj.origin === \\\"setValue\\\") {//text content has changed outside of brackets\\n            var folds = cm.getValidFolds(cm._lineFolds);\\n            cm._lineFolds = folds;\\n            Object.keys(folds).forEach(function (line) {\\n                cm.foldCode(+line);\\n            });\\n        } else {\\n            var state = cm.state.foldGutter;\\n            var lineChanges = changeObj.text.length - changeObj.removed.length;\\n            // for undo actions that add new line(s) to the document first update the folds cache as normal\\n            // and then update the folds cache with any line folds that exist in the new lines\\n            if (changeObj.origin === \\\"undo\\\" && lineChanges > 0) {\\n                updateFoldsCache(cm, changeObj.from.line, lineChanges);\\n                syncDocToFoldsCache(cm, changeObj.from.line, lineChanges);\\n            } else {\\n                updateFoldsCache(cm, changeObj.from.line, lineChanges);\\n            }\\n            if (lineChanges !== 0) {\\n                updateFoldInfo(cm, Math.max(0, changeObj.from.line + lineChanges), Math.max(0, changeObj.from.line + lineChanges) + 1);\\n            }\\n            state.from = changeObj.from.line;\\n            state.to = 0;\\n            window.clearTimeout(state.changeUpdate);\\n            state.changeUpdate = window.setTimeout(function () {\\n                updateInViewport(cm);\\n            }, 600);\\n        }\\n    }\\n\\n    /**\\n      * Triggered on viewport changes e.g., user scrolls or resizes the viewport.\\n      * @param {!CodeMirror} cm the CodeMirror instance for the active editor\\n      */\\n    function onViewportChange(cm) {\\n        var state = cm.state.foldGutter;\\n        window.clearTimeout(state.changeUpdate);\\n        state.changeUpdate = window.setTimeout(function () {\\n            var vp = cm.getViewport();\\n            if (state.from === state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {\\n                updateInViewport(cm);\\n            } else {\\n                cm.operation(function () {\\n                    if (vp.from < state.from) {\\n                        updateFoldInfo(cm, vp.from, state.from);\\n                        state.from = vp.from;\\n                    }\\n                    if (vp.to > state.to) {\\n                        updateFoldInfo(cm, state.to, vp.to);\\n                        state.to = vp.to;\\n                    } else {\\n                        updateFoldInfo(cm, vp.from, vp.to);\\n                        state.to = vp.to;\\n                        state.from = vp.from;\\n                    }\\n                });\\n            }\\n        }, 400);\\n    }\\n\\n    /**\\n      * Triggered when a code segment is folded.\\n      * @param {!CodeMirror} cm the CodeMirror instance for the active editor\\n      * @param {!Object} from  the ch and line position that designates the start of the region\\n      * @param {!Object} to the ch and line position that designates the end of the region\\n      */\\n    function onFold(cm, from, to) {\\n        var state = cm.state.foldGutter, line = from.line;\\n        if (line >= state.from && line < state.to) {\\n            updateFoldInfo(cm, line, line + 1);\\n        }\\n    }\\n\\n    /**\\n      * Triggered when a folded code segment is unfolded.\\n      * @param {!CodeMirror} cm the CodeMirror instance for the active editor\\n      * @param {!{line:number, ch:number}} from  the ch and line position that designates the start of the region\\n      * @param {!{line:number, ch:number}} to the ch and line position that designates the end of the region\\n      */\\n    function onUnFold(cm, from, to) {\\n        var state = cm.state.foldGutter, line = from.line;\\n        var vp = cm.getViewport();\\n        if (line >= state.from && line < state.to) {\\n            updateFoldInfo(cm, line, Math.min(vp.to, to.line));\\n        }\\n    }\\n\\n    /**\\n      * Initialises the fold gutter and registers event handlers for changes to document, viewport\\n      * and user interactions.\\n      */\\n    function init() {\\n        CodeMirror.defineOption(\\\"foldGutter\\\", false, function (cm, val, old) {\\n            if (old && old !== CodeMirror.Init) {\\n                cm.clearGutter(cm.state.foldGutter.options.gutter);\\n                cm.state.foldGutter = null;\\n                cm.off(\\\"gutterClick\\\", old.onGutterClick);\\n                cm.off(\\\"change\\\", onChange);\\n                cm.off(\\\"viewportChange\\\", onViewportChange);\\n                cm.off(\\\"fold\\\", onFold);\\n                cm.off(\\\"unfold\\\", onUnFold);\\n                cm.off(\\\"swapDoc\\\", updateInViewport);\\n            }\\n            if (val) {\\n                cm.state.foldGutter = new State(parseOptions(val));\\n                updateInViewport(cm);\\n                cm.on(\\\"gutterClick\\\", val.onGutterClick);\\n                cm.on(\\\"change\\\", onChange);\\n                cm.on(\\\"viewportChange\\\", onViewportChange);\\n                cm.on(\\\"fold\\\", onFold);\\n                cm.on(\\\"unfold\\\", onUnFold);\\n                cm.on(\\\"swapDoc\\\", updateInViewport);\\n            }\\n        });\\n    }\\n\\n    exports.init = init;\\n    exports.clearGutter = clearGutter;\\n    exports.updateInViewport = updateInViewport;\\n\\n});\\n\\n//# sourceURL=/foldhelpers/foldgutter.js\");\n\n","eval(\"// CodeMirror, copyright (c) by Marijn Haverbeke and others\\n// Distributed under an MIT license: http://codemirror.net/LICENSE\\n// Based on http://codemirror.net/addon/fold/foldcode.js\\n// Modified by Patrick Oladimeji for Brackets\\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\\n/*global define, brackets, document*/\\ndefine(\\'foldhelpers/foldcode\\',[\\'require\\',\\'exports\\',\\'module\\',\\'Prefs\\'],function (require, exports, module) {\\n    \\\"use strict\\\";\\n    var CodeMirror          = brackets.getModule(\\\"thirdparty/CodeMirror2/lib/codemirror\\\"),\\n        prefs               = require(\\\"Prefs\\\");\\n\\n    /**\\n      * Performs the folding and unfolding of code regions.\\n      * @param {CodeMirror} cm the CodeMirror instance\\n      * @param {number| Object} pos\\n      */\\n    function doFold(cm, pos, options, force) {\\n        options = options || {};\\n        force = force || \\\"fold\\\";\\n        if (typeof pos === \\\"number\\\") {\\n            pos = CodeMirror.Pos(pos, 0);\\n        }\\n\\n        var finder = options.rangeFinder || CodeMirror.fold.auto,\\n            range,\\n            widget,\\n            textRange;\\n\\n        function getRange(allowFolded) {\\n            var range = options.range || finder(cm, pos);\\n            if (!range || range.to.line - range.from.line < prefs.getSetting(\\\"minFoldSize\\\")) {\\n                return null;\\n            }\\n            var marks = cm.findMarksAt(range.from),\\n                i,\\n                lastMark,\\n                foldMarks;\\n            for (i = 0; i < marks.length; ++i) {\\n                if (marks[i].__isFold && force !== \\\"fold\\\") {\\n                    if (!allowFolded) {\\n                        return null;\\n                    }\\n                    range.cleared = true;\\n                    marks[i].clear();\\n                }\\n            }\\n            //check for overlapping folds\\n            if (marks && marks.length) {\\n                foldMarks = marks.filter(function (d) {\\n                    return d.__isFold;\\n                });\\n                if (foldMarks && foldMarks.length) {\\n                    lastMark = foldMarks[foldMarks.length - 1].find();\\n                    if (lastMark && range.from.line <= lastMark.to.line && lastMark.to.line < range.to.line) {\\n                        return null;\\n                    }\\n                }\\n            }\\n            return range;\\n        }\\n\\n        function makeWidget() {\\n            var widget = document.createElement(\\\"span\\\");\\n            widget.className = \\\"CodeMirror-foldmarker\\\";\\n            return widget;\\n        }\\n\\n        range = getRange(true);\\n        if (options.scanUp) {\\n            while (!range && pos.line > cm.firstLine()) {\\n                pos = CodeMirror.Pos(pos.line - 1, 0);\\n                range = getRange(false);\\n            }\\n        }\\n        if (!range || range.cleared || force === \\\"unfold\\\" || range.to.line - range.from.line < prefs.getSetting(\\\"minFoldSize\\\")) {\\n            if (range) { range.cleared = false; }\\n            return;\\n        }\\n\\n        widget = makeWidget();\\n        textRange = cm.markText(range.from, range.to, {\\n            replacedWith: widget,\\n            clearOnEnter: true,\\n            __isFold: true\\n        });\\n\\n        CodeMirror.on(widget, \\\"mousedown\\\", function (e) {\\n            textRange.clear();\\n            e.preventDefault();\\n        });\\n\\n        textRange.on(\\\"clear\\\", function (from, to) {\\n            delete cm._lineFolds[from.line];\\n            CodeMirror.signal(cm, \\\"unfold\\\", cm, from, to);\\n        });\\n\\n        if (force === \\\"fold\\\") {\\n            delete range.cleared;\\n            cm._lineFolds[pos.line] = range;\\n        } else {\\n            delete cm._lineFolds[pos.line];\\n        }\\n\\n        CodeMirror.signal(cm, force, cm, range.from, range.to);\\n        return range;\\n    }\\n\\n    /**\\n        Initialises extensions and helpers on the CodeMirror object\\n    */\\n    function init() {\\n        CodeMirror.defineExtension(\\\"foldCode\\\", function (pos, options, force) {\\n            return doFold(this, pos, options, force);\\n        });\\n\\n        CodeMirror.defineExtension(\\\"unfoldCode\\\", function (pos, options) {\\n            return doFold(this, pos, options, \\\"unfold\\\");\\n        });\\n\\n        CodeMirror.defineExtension(\\\"isFolded\\\", function (line) {\\n            return this._lineFolds && this._lineFolds[line];\\n        });\\n\\n        /**\\n          * Checks the validity of the ranges passed in the parameter and returns the foldranges\\n          * that are still valid in the current document\\n          * @param {object} folds the dictionary of lines in the current document that should be folded\\n          * @returns {object} valid folds found in those passed in parameter\\n          */\\n        CodeMirror.defineExtension(\\\"getValidFolds\\\", function (folds) {\\n            var keys, rf = CodeMirror.fold.auto, cm = this, result = {}, range, cachedRange;\\n            if (folds && (keys = Object.keys(folds)).length) {\\n                keys.forEach(function (lineNumber) {\\n                    lineNumber = +lineNumber;\\n                    if (lineNumber >= cm.firstLine() && lineNumber <= cm.lastLine()) {\\n                        range = rf(cm, CodeMirror.Pos(lineNumber));\\n                        cachedRange = folds[lineNumber];\\n                        if (range && cachedRange && range.from.line === cachedRange.from.line &&\\n                                range.to.line === cachedRange.to.line) {\\n                            cm.foldCode(lineNumber, {range: folds[lineNumber]}, \\\"fold\\\");\\n                            result[lineNumber] = folds[lineNumber];\\n                        }\\n                    }\\n                });\\n            }\\n            return result;\\n        });\\n\\n        /**\\n          * Utility function to fold the region at the current cursor position in  a document\\n          * @param {CodeMirror} cm the CodeMirror instance\\n          * @param {?options} options extra options to pass to the fold function\\n          */\\n        CodeMirror.commands.fold = function (cm, options) {\\n            cm.foldCode(cm.getCursor(), options, \\\"fold\\\");\\n        };\\n\\n        /**\\n          * Utility function to unfold the region at the current cursor position in  a document\\n          * @param {CodeMirror} cm the CodeMirror instance\\n          * @param {?options} options extra options to pass to the fold function\\n          */\\n        CodeMirror.commands.unfold = function (cm, options) {\\n            cm.foldCode(cm.getCursor(), options, \\\"unfold\\\");\\n        };\\n\\n        /**\\n          * Utility function to fold all foldable regions in a document\\n          * @param {CodeMirror} cm the CodeMirror instance\\n          */\\n        CodeMirror.commands.foldAll = function (cm) {\\n            cm.operation(function () {\\n                var i, e;\\n                for (i = cm.firstLine(), e = cm.lastLine(); i <= e; i++) {\\n                    cm.foldCode(CodeMirror.Pos(i, 0), null, \\\"fold\\\");\\n                }\\n            });\\n        };\\n\\n        /**\\n          * Utility function to unfold all folded regions in a document\\n          * @param {CodeMirror} cm the CodeMirror instance\\n          * @param {?number} from the line number for the beginning of the region to unfold\\n          * @param {?number} to the line number for the end of the region to unfold\\n          */\\n        CodeMirror.commands.unfoldAll = function (cm, from, to) {\\n            from = from || cm.firstLine();\\n            to = to || cm.lastLine();\\n            cm.operation(function () {\\n                var i, e;\\n                for (i = from, e = to; i <= e; i++) {\\n                    if (cm.isFolded(i)) { cm.unfoldCode(i, {range: cm._lineFolds[i]}); }\\n                }\\n            });\\n        };\\n\\n        /**\\n          * Folds the specified range. The descendants of any fold regions within the range are also folded up to\\n          * a level set globally in the `maxFoldLevel\\' preferences\\n          * @param {CodeMirror} cm the CodeMirror instance\\n          * @param {?number} start the line number for the beginning of the region to fold\\n          * @param {?number} end the line number for the end of the region to fold\\n          */\\n        CodeMirror.commands.foldToLevel = function (cm, start, end) {\\n            var rf = CodeMirror.fold.auto;\\n            function foldLevel(n, from, to) {\\n                if (n > 0) {\\n                    var i = from, range;\\n                    while (i < to) {\\n                        range = rf(cm, CodeMirror.Pos(i, 0));\\n                        if (range) {\\n                            //call fold level for the range just folded\\n                            foldLevel(n - 1, range.from.line + 1, range.to.line - 1);\\n                            cm.foldCode(CodeMirror.Pos(i, 0), null, \\\"fold\\\");\\n                            i = range.to.line + 1;\\n                        } else {\\n                            i++;\\n                        }\\n                    }\\n                }\\n            }\\n            cm.operation(function () {\\n                start = start === undefined ? cm.firstLine() : start;\\n                end = end || cm.lastLine();\\n                foldLevel(prefs.getSetting(\\\"maxFoldLevel\\\"), start, end);\\n            });\\n        };\\n\\n        /**\\n          * Helper to combine an array of fold range finders into one\\n          */\\n        CodeMirror.registerHelper(\\\"fold\\\", \\\"combine\\\", function () {\\n            var funcs = Array.prototype.slice.call(arguments, 0);\\n            return function (cm, start) {\\n                var i;\\n                for (i = 0; i < funcs.length; ++i) {\\n                    var found = funcs[i] && funcs[i](cm, start);\\n                    if (found) {\\n                        return found;\\n                    }\\n                }\\n            };\\n        });\\n\\n        /**\\n          * Creates a helper which returns the appropriate fold function based on the mode of the current position in\\n          * a document.\\n          * @param {CodeMirror} cm the CodeMirror instance\\n          * @param {number} start the current position in the document\\n          */\\n        CodeMirror.registerHelper(\\\"fold\\\", \\\"auto\\\", function (cm, start) {\\n            var helpers = cm.getHelpers(start, \\\"fold\\\"), i, cur;\\n            //ensure mode helper is loaded if there is one\\n            var mode = cm.getMode().name;\\n            var modeHelper = CodeMirror.fold[mode];\\n            if (modeHelper && helpers.indexOf(modeHelper) < 0) {\\n                helpers.push(modeHelper);\\n            }\\n            for (i = 0; i < helpers.length; i++) {\\n                cur = helpers[i](cm, start);\\n                if (cur) { return cur; }\\n            }\\n        });\\n    }\\n\\n    exports.init = init;\\n});\\n\\n//# sourceURL=/foldhelpers/foldcode.js\");\n\n","eval(\"/**\\n * Fold range finder based on line indentations. Ignores blank lines and commented lines\\n * @author Patrick Oladimeji\\n * @date 12/27/13 21:54:41 PM\\n */\\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\\n/*global define, brackets*/\\n\\ndefine(\\'foldhelpers/indentFold\\',[\\'require\\',\\'exports\\',\\'module\\'],function (require, exports, module) {\\n    \\\"use strict\\\";\\n    var CodeMirror  = brackets.getModule(\\\"thirdparty/CodeMirror2/lib/codemirror\\\"),\\n        cols        = CodeMirror.countColumn,\\n        pos         = CodeMirror.Pos;\\n\\n    function lastNonEmptyLineNumber(cm) {\\n        var lc = cm.lastLine(), line = cm.getLine(lc);\\n        while (lc > 0 && line.trim().length === 0) {\\n            lc--;\\n            line = cm.getLine(lc);\\n        }\\n        return lc;\\n    }\\n\\n    function indentFold(cm, start) {\\n        var lineText = cm.getLine(start.line), tabSize = cm.getOption(\\\"tabSize\\\");\\n\\n        var lineIndent = cols(lineText, null, tabSize), collapsible = false, lineCount = cm.lineCount();\\n        var token = cm.getTokenAt(pos(start.line, lineIndent + 1));\\n        //no folding for blank lines or commented lines\\n        if (lineText.trim().length === 0 || (token && token.type === \\\"comment\\\")) {\\n            return;\\n        }\\n        var i, indent, currentLine;\\n        for (i = start.line + 1; i < lineCount; i++) {\\n            currentLine = cm.getLine(i);\\n            indent = cols(currentLine, null, tabSize);\\n\\n            token = cm.getTokenAt(pos(i, indent + 1));\\n            //only fold for non blank lines or non commented lines\\n            if (currentLine.trim().length !== 0 && (token && token.type !== \\\"comment\\\")) {\\n                if (!collapsible) {\\n                    if (indent > lineIndent) {\\n                        collapsible = true;\\n                    }\\n                } else {\\n                    if (indent <= lineIndent) {\\n                        return {from: pos(start.line, lineText.length),\\n                                to: pos(i - 1, cm.getLine(i - 1).length)};\\n                    }\\n                }\\n\\n                if (indent === lineIndent || indent < lineIndent) {\\n                    return;\\n                }\\n            }\\n        }\\n        //use last nonempty line as the end of the folding region if there is no explicit end to this indent\\n        if (collapsible) {\\n            i = lastNonEmptyLineNumber(cm);\\n            return {from: pos(start.line, lineText.length), to: pos(i, cm.getLine(i).length)};\\n        }\\n    }\\n\\n    module.exports = indentFold;\\n});\\n\\n//# sourceURL=/foldhelpers/indentFold.js\");\n\n","eval(\"/*\\n* Copyright (c) 2013 Patrick Oladimeji. All rights reserved.\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a\\n* copy of this software and associated documentation files (the \\\"Software\\\"),\\n* to deal in the Software without restriction, including without limitation\\n* the rights to use, copy, modify, merge, publish, distribute, sublicense,\\n* and/or sell copies of the Software, and to permit persons to whom the\\n* Software is furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in\\n* all copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\\n* DEALINGS IN THE SOFTWARE.\\n*\\n*/\\n/**\\n * Code folding extension for brackets\\n * @author Patrick Oladimeji\\n * @date 10/24/13 9:35:26 AM\\n */\\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\\n/*global define, $, brackets*/\\ndefine(\\'main\\',[\\'require\\',\\'exports\\',\\'module\\',\\'Prefs\\',\\'foldhelpers/foldgutter\\',\\'foldhelpers/foldcode\\',\\'foldhelpers/indentFold\\'],function (require, exports, module) {\\n    \\\"use strict\\\";\\n    \\n    var CodeMirror              = brackets.getModule(\\\"thirdparty/CodeMirror2/lib/codemirror\\\"),\\n        Strings                 = brackets.getModule(\\\"strings\\\"),\\n        AppInit                 = brackets.getModule(\\\"utils/AppInit\\\"),\\n        CommandManager          = brackets.getModule(\\\"command/CommandManager\\\"),\\n        DocumentManager         = brackets.getModule(\\\"document/DocumentManager\\\"),\\n        Editor                  = brackets.getModule(\\\"editor/Editor\\\").Editor,\\n        EditorManager           = brackets.getModule(\\\"editor/EditorManager\\\"),\\n        ProjectManager          = brackets.getModule(\\\"project/ProjectManager\\\"),\\n        KeyBindingManager       = brackets.getModule(\\\"command/KeyBindingManager\\\"),\\n        ExtensionUtils          = brackets.getModule(\\\"utils/ExtensionUtils\\\"),\\n        Menus                   = brackets.getModule(\\\"command/Menus\\\"),\\n        prefs                   = require(\\\"Prefs\\\"),\\n        COLLAPSE_ALL            = \\\"codefolding.collapse.all\\\",\\n        COLLAPSE                = \\\"codefolding.collapse\\\",\\n        EXPAND                  = \\\"codefolding.expand\\\",\\n        EXPAND_ALL              = \\\"codefolding.expand.all\\\",\\n        GUTTER_NAME             = \\\"CodeMirror-foldgutter\\\",\\n        codeFoldingMenuDivider  = \\\"codefolding.divider\\\",\\n        collapseKey             = \\\"Ctrl-Alt-[\\\",\\n        expandKey               = \\\"Ctrl-Alt-]\\\",\\n        collapseAllKey          = \\\"Alt-1\\\",\\n        expandAllKey            = \\\"Shift-Alt-1\\\";\\n\\n    ExtensionUtils.loadStyleSheet(module, \\\"main.less\\\");\\n    \\n    // Load CodeMirror addons\\n    brackets.getModule([\\\"thirdparty/CodeMirror2/addon/fold/brace-fold\\\"]);\\n    brackets.getModule([\\\"thirdparty/CodeMirror2/addon/fold/comment-fold\\\"]);\\n    brackets.getModule([\\\"thirdparty/CodeMirror2/addon/fold/markdown-fold\\\"]);\\n\\n    // Still using slightly modified versions of the foldcode.js and foldgutter.js since we\\n    // need to modify the gutter click handler to take care of some collapse and expand features\\n    // e.g. collapsing all children when \\'alt\\' key is pressed\\n    var foldGutter              = require(\\\"foldhelpers/foldgutter\\\"),\\n        foldCode                = require(\\\"foldhelpers/foldcode\\\"),\\n        indentFold              = require(\\\"foldhelpers/indentFold\\\");\\n    \\n    \\n    /** Set to true when init() has run; set back to false after deinit() has run */\\n    var _isInitialized = false;\\n    \\n    /**\\n      * Restores the linefolds in the editor using values fetched from the preference store\\n      * Checks the document to ensure that changes have not been made (e.g., in a different editor)\\n      * to invalidate the saved line folds.\\n      * @param {Editor} editor  the editor whose saved line folds should be restored\\n      */\\n    function restoreLineFolds(editor) {\\n        var saveFolds = prefs.getSetting(\\\"saveFoldStates\\\");\\n        if (!editor || !saveFolds) {\\n            return;\\n        }\\n        var cm = editor._codeMirror;\\n        var path = editor.document.file.fullPath;\\n        var folds = cm._lineFolds || prefs.getFolds(path);\\n        cm._lineFolds = cm.getValidFolds(folds);\\n        prefs.setFolds(path, cm._lineFolds);\\n        Object.keys(cm._lineFolds).forEach(function (line) {\\n            cm.foldCode(Number(line));\\n        });\\n    }\\n\\n    /**\\n      * Saves the line folds in the editor using the preference storage\\n      * @param {Editor} editor the editor whose line folds should be saved\\n      */\\n    function saveLineFolds(editor) {\\n        var saveFolds = prefs.getSetting(\\\"saveFoldStates\\\");\\n        if (!editor || !saveFolds) {\\n            return;\\n        }\\n        var folds = editor._codeMirror._lineFolds || {};\\n        var path = editor.document.file.fullPath;\\n        if (Object.keys(folds).length) {\\n            prefs.setFolds(path, folds);\\n        } else {\\n            prefs.setFolds(path, undefined);\\n        }\\n    }\\n\\n    /**\\n      * Event handler for gutter click. Manages folding and unfolding code regions. If the Alt key\\n      * is pressed while clicking the fold gutter, child code fragments are also folded/unfolded\\n      * up to a level defined in the `maxFoldLevel\\' preference.\\n      * @param {!CodeMirror} cm the CodeMirror object\\n      * @param {number} line the line number for the clicked gutter\\n      * @param {string} gutter the name of the gutter element clicked\\n      * @param {!KeyboardEvent} event the underlying dom event triggered for the gutter click\\n      */\\n    function onGutterClick(cm, line, gutter, event) {\\n        var opts = cm.state.foldGutter.options, pos = CodeMirror.Pos(line);\\n        if (gutter !== opts.gutter) { return; }\\n        var range;\\n        var _lineFolds = cm._lineFolds;\\n        if (cm.isFolded(line)) {\\n            if (event.altKey) { // unfold code including children\\n                range = _lineFolds[line];\\n                CodeMirror.commands.unfoldAll(cm, range.from.line, range.to.line);\\n            } else {\\n                cm.unfoldCode(line, {range: _lineFolds[line]});\\n            }\\n        } else {\\n            if (event.altKey) {\\n                range = CodeMirror.fold.auto(cm, pos);\\n                if (range) {\\n                    CodeMirror.commands.foldToLevel(cm, range.from.line, range.to.line);\\n                }\\n            } else {\\n                cm.foldCode(line);\\n            }\\n        }\\n    }\\n\\n    /**\\n      * Collapses the code region nearest the current cursor position.\\n      * Nearest is found by searching from the current line and moving up the document until an\\n      * opening code-folding region is found.\\n      */\\n    function collapseCurrent() {\\n        var editor = EditorManager.getFocusedEditor();\\n        if (!editor) {\\n            return;\\n        }\\n        var cm = editor._codeMirror;\\n        var cursor = editor.getCursorPos(), i;\\n        // Move cursor up until a collapsible line is found\\n        for (i = cursor.line; i >= 0; i--) {\\n            if (cm.foldCode(i)) {\\n                editor.setCursorPos(i);\\n                return;\\n            }\\n        }\\n    }\\n\\n    /**\\n      * Expands the code region at the current cursor position.\\n      */\\n    function expandCurrent() {\\n        var editor = EditorManager.getFocusedEditor();\\n        if (editor) {\\n            var cursor = editor.getCursorPos(), cm = editor._codeMirror;\\n            cm.unfoldCode(cursor.line);\\n        }\\n    }\\n\\n    /**\\n      * Collapses all foldable regions in the current document. Folding is done up to a level \\'n\\'\\n      * which is defined in the `maxFoldLevel` preference. Levels refer to fold heirarchies e.g., for the following\\n      * code fragment, the function is level 1, the if statement is level 2 and the forEach is level 3\\n      *\\n      *     function sample() {\\n      *         if (debug) {\\n      *             logMessages.forEach(function (m) {\\n      *                 console.debug(m);\\n      *             });\\n      *         }\\n      *     }\\n      */\\n    function collapseAll() {\\n        var editor = EditorManager.getFocusedEditor();\\n        if (editor) {\\n            var cm = editor._codeMirror;\\n            CodeMirror.commands.foldToLevel(cm);\\n        }\\n    }\\n\\n    /**\\n      * Expands all folded regions in the current document\\n      */\\n    function expandAll() {\\n        var editor = EditorManager.getFocusedEditor();\\n        if (editor) {\\n            var cm = editor._codeMirror;\\n            CodeMirror.commands.unfoldAll(cm);\\n        }\\n    }\\n\\n    /**\\n      * Initialises and creates the code-folding gutter.\\n      * @param {Editor} editor the editor on which to initialise the fold gutter\\n      */\\n    function createGutter(editor) {\\n        var cm = editor._codeMirror;\\n        var path = editor.document.file.fullPath, _lineFolds = prefs.getFolds(path);\\n        _lineFolds = _lineFolds || {};\\n        cm._lineFolds = _lineFolds;\\n        var gutters = cm.getOption(\\\"gutters\\\").slice(0);\\n\\n        // Reuse any existing fold gutter\\n        if (gutters.indexOf(GUTTER_NAME) < 0) {\\n            var lnIndex = gutters.indexOf(\\\"CodeMirror-linenumbers\\\");\\n            $(editor.getRootElement()).addClass(\\\"folding-enabled\\\");\\n            gutters.splice(lnIndex + 1, 0, GUTTER_NAME);\\n            cm.setOption(\\\"gutters\\\",  gutters);\\n            cm.refresh();  // force recomputing gutter width - .folding-enabled class affects linenumbers gutter which has existing cached width\\n        }\\n        cm.setOption(\\\"foldGutter\\\", {onGutterClick: onGutterClick});\\n\\n        $(cm.getGutterElement()).on({\\n            mouseenter: function () {\\n                if (prefs.getSetting(\\\"hideUntilMouseover\\\")) {\\n                    foldGutter.updateInViewport(cm);\\n                } else {\\n                    $(editor.getRootElement()).addClass(\\\"over-gutter\\\");\\n                }\\n            },\\n            mouseleave: function () {\\n                if (prefs.getSetting(\\\"hideUntilMouseover\\\")) {\\n                    foldGutter.clearGutter(cm);\\n                } else {\\n                    $(editor.getRootElement()).removeClass(\\\"over-gutter\\\");\\n                }\\n            }\\n        });\\n    }\\n\\n    /**\\n     * Remove the fold gutter for a given CodeMirror instance.\\n     * @param {CodeMirror} cm the CodeMirror instance whose gutter should be removed\\n     */\\n    function removeGutter(editor) {\\n        var cm = editor._codeMirror;\\n        var gutters = cm.getOption(\\\"gutters\\\").slice(0);\\n        var index = gutters.indexOf(GUTTER_NAME);\\n        $(editor.getRootElement()).removeClass(\\\"folding-enabled\\\");\\n        gutters.splice(index, 1);\\n        cm.setOption(\\\"gutters\\\",  gutters);\\n        cm.refresh();  // force recomputing gutter width - .folding-enabled class affected linenumbers gutter\\n        CodeMirror.defineOption(\\\"foldGutter\\\", false, null);\\n    }\\n    \\n    /** Add gutter and restore saved expand/collapse state */\\n    function enableFoldingInEditor(editor) {\\n        if (editor._codeMirror.getOption(\\\"gutters\\\").indexOf(GUTTER_NAME) === -1) {\\n            createGutter(editor);\\n            restoreLineFolds(editor);\\n        }\\n    }\\n\\n    /**\\n      * When a brand new editor is seen, initialise fold-gutter and restore line folds in it. Save line folds in\\n      * departing editor in case it\\'s getting closed.\\n      * @param {object} event the event object\\n      * @param {Editor} current the current editor\\n      * @param {Editor} previous the previous editor\\n      */\\n    function onActiveEditorChanged(event, current, previous) {\\n        if (current) {\\n            enableFoldingInEditor(current);\\n        }\\n        if (previous) {\\n            saveLineFolds(previous);\\n        }\\n    }\\n\\n    /**\\n      * Saves the line folds in the current full editor before it is closed.\\n      */\\n    function saveBeforeClose() {\\n        // We\\'ve already saved all other open editors when they go active->inactive\\n        saveLineFolds(EditorManager.getActiveEditor());\\n    }\\n\\n    /**\\n     * Remove code-folding functionality\\n     */\\n    function deinit() {\\n        _isInitialized = false;\\n        \\n        KeyBindingManager.removeBinding(collapseKey);\\n        KeyBindingManager.removeBinding(expandKey);\\n        KeyBindingManager.removeBinding(collapseAllKey);\\n        KeyBindingManager.removeBinding(expandAllKey);\\n\\n        //remove menus\\n        Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).removeMenuDivider(codeFoldingMenuDivider.id);\\n        Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).removeMenuItem(COLLAPSE);\\n        Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).removeMenuItem(EXPAND);\\n        Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).removeMenuItem(COLLAPSE_ALL);\\n        Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).removeMenuItem(EXPAND_ALL);\\n        \\n        EditorManager.off(\\\".CodeFolding\\\");\\n        DocumentManager.off(\\\".CodeFolding\\\");\\n        ProjectManager.off(\\\".CodeFolding\\\");\\n\\n        // Remove gutter & revert collapsed sections in all currently open editors\\n        Editor.forEveryEditor(function (editor) {\\n            CodeMirror.commands.unfoldAll(editor._codeMirror);\\n            removeGutter(editor);\\n        });\\n    }\\n    \\n    /**\\n     * Enable code-folding functionality\\n     */\\n    function init() {\\n        _isInitialized = true;\\n        \\n        foldCode.init();\\n        foldGutter.init();\\n        \\n        // Many CodeMirror modes specify which fold helper should be used for that language. For a few that\\n        // don\\'t, we register helpers explicitly here. We also register a global helper for generic indent-based\\n        // folding, which cuts across all languages if enabled via preference.\\n        CodeMirror.registerGlobalHelper(\\\"fold\\\", \\\"indent\\\", function (mode, cm) {\\n            return prefs.getSetting(\\\"alwaysUseIndentFold\\\");\\n        }, indentFold);\\n\\n        CodeMirror.registerHelper(\\\"fold\\\", \\\"django\\\", CodeMirror.helpers.fold.brace);\\n        CodeMirror.registerHelper(\\\"fold\\\", \\\"tornado\\\", CodeMirror.helpers.fold.brace);\\n\\n        EditorManager.on(\\\"activeEditorChange.CodeFolding\\\", onActiveEditorChanged);\\n        DocumentManager.on(\\\"documentRefreshed.CodeFolding\\\", function (event, doc) {\\n            restoreLineFolds(doc._masterEditor);\\n        });\\n\\n        ProjectManager.on(\\\"beforeProjectClose.CodeFolding beforeAppClose.CodeFolding\\\", saveBeforeClose);\\n\\n        //create menus\\n        codeFoldingMenuDivider = Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).addMenuDivider();\\n        Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).addMenuItem(COLLAPSE_ALL);\\n        Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).addMenuItem(EXPAND_ALL);\\n        Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).addMenuItem(COLLAPSE);\\n        Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).addMenuItem(EXPAND);\\n        \\n        //register keybindings\\n        KeyBindingManager.addBinding(COLLAPSE_ALL, collapseAllKey);\\n        KeyBindingManager.addBinding(EXPAND_ALL, expandAllKey);\\n        KeyBindingManager.addBinding(COLLAPSE, collapseKey);\\n        KeyBindingManager.addBinding(EXPAND, expandKey);\\n\\n        // Add gutters & restore saved expand/collapse state in all currently open editors\\n        Editor.forEveryEditor(function (editor) {\\n            enableFoldingInEditor(editor);\\n        });\\n    }\\n    \\n    /**\\n      * Register change listener for the preferences file.\\n      */\\n    function watchPrefsForChanges() {\\n        prefs.prefsObject.on(\\\"change\\\", function (e, data) {\\n            if (data.ids.indexOf(\\\"enabled\\\") > -1) {\\n                // Check if enabled state mismatches whether code-folding is actually initialized (can\\'t assume\\n                // since preference change events can occur when the value hasn\\'t really changed)\\n                var isEnabled = prefs.getSetting(\\\"enabled\\\");\\n                if (isEnabled && !_isInitialized) {\\n                    init();\\n                } else if (!isEnabled && _isInitialized) {\\n                    deinit();\\n                }\\n            }\\n        });\\n    }\\n\\n    AppInit.htmlReady(function () {\\n        CommandManager.register(Strings.COLLAPSE_ALL, COLLAPSE_ALL, collapseAll);\\n        CommandManager.register(Strings.EXPAND_ALL, EXPAND_ALL, expandAll);\\n        CommandManager.register(Strings.COLLAPSE_CURRENT, COLLAPSE, collapseCurrent);\\n        CommandManager.register(Strings.EXPAND_CURRENT, EXPAND, expandCurrent);\\n        \\n        if (prefs.getSetting(\\\"enabled\\\")) {\\n            init();\\n        }\\n        watchPrefsForChanges();\\n    });\\n});\\n\\n//# sourceURL=/main.js\");\n\n"]}